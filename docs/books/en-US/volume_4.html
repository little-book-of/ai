<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Volume 4. Search and Planning – The Little Book of Artificial Intelligence</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../books/en-US/volume_5.html" rel="next">
<link href="../../books/en-US/volume_3.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-27c261d06b905028a18691de25d09dde.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../books/en-US/volume_4.html"><span class="chapter-title">Volume 4. Search and Planning</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">The Little Book of Artificial Intelligence</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Contents</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-US/volume_1.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Volume 1. First principles of Artificial Intelligence</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-US/volume_2.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Volume 2. Mathematicial Foundations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-US/volume_3.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Volume 3. Data and Representation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-US/volume_4.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">Volume 4. Search and Planning</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-US/volume_5.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Volume 5. Logic and Knowledge</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-US/volume_6.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Volume 6. Probabilistic Modeling and Inference</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#chapter-31.-state-spaces-and-problem-formulation" id="toc-chapter-31.-state-spaces-and-problem-formulation" class="nav-link active" data-scroll-target="#chapter-31.-state-spaces-and-problem-formulation">Chapter 31. State Spaces and Problem Formulation</a>
  <ul class="collapse">
  <li><a href="#defining-state-spaces-and-representation-choices" id="toc-defining-state-spaces-and-representation-choices" class="nav-link" data-scroll-target="#defining-state-spaces-and-representation-choices">301. Defining State Spaces and Representation Choices</a></li>
  <li><a href="#initial-states-goal-states-and-transition-models" id="toc-initial-states-goal-states-and-transition-models" class="nav-link" data-scroll-target="#initial-states-goal-states-and-transition-models">302. Initial States, Goal States, and Transition Models</a></li>
  <li><a href="#problem-formulation-examples-puzzles-navigation-games" id="toc-problem-formulation-examples-puzzles-navigation-games" class="nav-link" data-scroll-target="#problem-formulation-examples-puzzles-navigation-games">303. Problem Formulation Examples (Puzzles, Navigation, Games)</a></li>
  <li><a href="#abstraction-and-granularity-in-state-modeling" id="toc-abstraction-and-granularity-in-state-modeling" class="nav-link" data-scroll-target="#abstraction-and-granularity-in-state-modeling">304. Abstraction and Granularity in State Modeling</a></li>
  <li><a href="#state-explosion-and-strategies-for-reduction" id="toc-state-explosion-and-strategies-for-reduction" class="nav-link" data-scroll-target="#state-explosion-and-strategies-for-reduction">305. State Explosion and Strategies for Reduction</a></li>
  <li><a href="#canonical-forms-and-equivalence-classes" id="toc-canonical-forms-and-equivalence-classes" class="nav-link" data-scroll-target="#canonical-forms-and-equivalence-classes">306. Canonical Forms and Equivalence Classes</a></li>
  <li><a href="#canonical-forms-and-equivalence-classes-1" id="toc-canonical-forms-and-equivalence-classes-1" class="nav-link" data-scroll-target="#canonical-forms-and-equivalence-classes-1">306. Canonical Forms and Equivalence Classes</a></li>
  <li><a href="#implicit-vs.-explicit-state-space-representation" id="toc-implicit-vs.-explicit-state-space-representation" class="nav-link" data-scroll-target="#implicit-vs.-explicit-state-space-representation">307. Implicit vs.&nbsp;Explicit State Space Representation</a></li>
  <li><a href="#formal-properties-completeness-optimality-complexity" id="toc-formal-properties-completeness-optimality-complexity" class="nav-link" data-scroll-target="#formal-properties-completeness-optimality-complexity">308. Formal Properties: Completeness, Optimality, Complexity</a></li>
  <li><a href="#from-real-world-tasks-to-formal-problems" id="toc-from-real-world-tasks-to-formal-problems" class="nav-link" data-scroll-target="#from-real-world-tasks-to-formal-problems">309. From Real-World Tasks to Formal Problems</a></li>
  <li><a href="#case-study-formulating-search-problems-in-ai" id="toc-case-study-formulating-search-problems-in-ai" class="nav-link" data-scroll-target="#case-study-formulating-search-problems-in-ai">310. Case Study: Formulating Search Problems in AI</a></li>
  </ul></li>
  <li><a href="#chapter-32.-unformed-search-bfs-dfs-iterative-deepening" id="toc-chapter-32.-unformed-search-bfs-dfs-iterative-deepening" class="nav-link" data-scroll-target="#chapter-32.-unformed-search-bfs-dfs-iterative-deepening">Chapter 32. Unformed Search (BFS, DFS, Iterative Deepening)</a>
  <ul class="collapse">
  <li><a href="#concept-of-uninformed-blind-search" id="toc-concept-of-uninformed-blind-search" class="nav-link" data-scroll-target="#concept-of-uninformed-blind-search">311. Concept of Uninformed (Blind) Search</a></li>
  <li><a href="#breadth-first-search-mechanics-and-guarantees" id="toc-breadth-first-search-mechanics-and-guarantees" class="nav-link" data-scroll-target="#breadth-first-search-mechanics-and-guarantees">312. Breadth-First Search: Mechanics and Guarantees</a></li>
  <li><a href="#depth-first-search-mechanics-and-pitfalls" id="toc-depth-first-search-mechanics-and-pitfalls" class="nav-link" data-scroll-target="#depth-first-search-mechanics-and-pitfalls">313. Depth-First Search: Mechanics and Pitfalls</a></li>
  <li><a href="#uniform-cost-search-and-path-cost-functions" id="toc-uniform-cost-search-and-path-cost-functions" class="nav-link" data-scroll-target="#uniform-cost-search-and-path-cost-functions">314. Uniform-Cost Search and Path Cost Functions</a></li>
  <li><a href="#depth-limited-and-iterative-deepening-dfs" id="toc-depth-limited-and-iterative-deepening-dfs" class="nav-link" data-scroll-target="#depth-limited-and-iterative-deepening-dfs">315. Depth-Limited and Iterative Deepening DFS</a></li>
  <li><a href="#time-and-space-complexity-of-blind-search-methods" id="toc-time-and-space-complexity-of-blind-search-methods" class="nav-link" data-scroll-target="#time-and-space-complexity-of-blind-search-methods">316. Time and Space Complexity of Blind Search Methods</a></li>
  <li><a href="#completeness-and-optimality-trade-offs" id="toc-completeness-and-optimality-trade-offs" class="nav-link" data-scroll-target="#completeness-and-optimality-trade-offs">317. Completeness and Optimality Trade-offs</a></li>
  <li><a href="#comparative-analysis-of-bfs-dfs-ucs-and-iddfs" id="toc-comparative-analysis-of-bfs-dfs-ucs-and-iddfs" class="nav-link" data-scroll-target="#comparative-analysis-of-bfs-dfs-ucs-and-iddfs">318. Comparative Analysis of BFS, DFS, UCS, and IDDFS</a></li>
  <li><a href="#applications-of-uninformed-search-in-practice" id="toc-applications-of-uninformed-search-in-practice" class="nav-link" data-scroll-target="#applications-of-uninformed-search-in-practice">319. Applications of Uninformed Search in Practice</a></li>
  <li><a href="#worked-example-maze-solving-with-uninformed-methods" id="toc-worked-example-maze-solving-with-uninformed-methods" class="nav-link" data-scroll-target="#worked-example-maze-solving-with-uninformed-methods">320. Worked Example: Maze Solving with Uninformed Methods</a></li>
  </ul></li>
  <li><a href="#chapter-33.-informed-search-heuristics-a" id="toc-chapter-33.-informed-search-heuristics-a" class="nav-link" data-scroll-target="#chapter-33.-informed-search-heuristics-a">Chapter 33. Informed Search (Heuristics, A*)</a>
  <ul class="collapse">
  <li><a href="#the-role-of-heuristics-in-guiding-search" id="toc-the-role-of-heuristics-in-guiding-search" class="nav-link" data-scroll-target="#the-role-of-heuristics-in-guiding-search">321. The Role of Heuristics in Guiding Search</a></li>
  <li><a href="#designing-admissible-and-consistent-heuristics" id="toc-designing-admissible-and-consistent-heuristics" class="nav-link" data-scroll-target="#designing-admissible-and-consistent-heuristics">322. Designing Admissible and Consistent Heuristics</a></li>
  <li><a href="#greedy-best-first-search-advantages-and-risks" id="toc-greedy-best-first-search-advantages-and-risks" class="nav-link" data-scroll-target="#greedy-best-first-search-advantages-and-risks">323. Greedy Best-First Search: Advantages and Risks</a></li>
  <li><a href="#a-search-algorithm-intuition-and-properties" id="toc-a-search-algorithm-intuition-and-properties" class="nav-link" data-scroll-target="#a-search-algorithm-intuition-and-properties">324. A* Search: Algorithm, Intuition, and Properties</a></li>
  <li><a href="#weighted-a-and-speedoptimality-trade-offs" id="toc-weighted-a-and-speedoptimality-trade-offs" class="nav-link" data-scroll-target="#weighted-a-and-speedoptimality-trade-offs">325. Weighted A* and Speed–Optimality Trade-offs</a></li>
  <li><a href="#iterative-deepening-a-ida" id="toc-iterative-deepening-a-ida" class="nav-link" data-scroll-target="#iterative-deepening-a-ida">326. Iterative Deepening A* (IDA*)</a></li>
  <li><a href="#heuristic-evaluation-and-accuracy-measures" id="toc-heuristic-evaluation-and-accuracy-measures" class="nav-link" data-scroll-target="#heuristic-evaluation-and-accuracy-measures">327. Heuristic Evaluation and Accuracy Measures</a></li>
  <li><a href="#pattern-databases-and-domain-specific-heuristics" id="toc-pattern-databases-and-domain-specific-heuristics" class="nav-link" data-scroll-target="#pattern-databases-and-domain-specific-heuristics">328. Pattern Databases and Domain-Specific Heuristics</a></li>
  <li><a href="#applications-of-heuristic-search-routing-planning" id="toc-applications-of-heuristic-search-routing-planning" class="nav-link" data-scroll-target="#applications-of-heuristic-search-routing-planning">329. Applications of Heuristic Search (Routing, Planning)</a></li>
  <li><a href="#case-study-heuristic-search-in-puzzles-and-robotics" id="toc-case-study-heuristic-search-in-puzzles-and-robotics" class="nav-link" data-scroll-target="#case-study-heuristic-search-in-puzzles-and-robotics">330. Case Study: Heuristic Search in Puzzles and Robotics</a></li>
  </ul></li>
  <li><a href="#chapter-34.-constraint-satisfaction-problems" id="toc-chapter-34.-constraint-satisfaction-problems" class="nav-link" data-scroll-target="#chapter-34.-constraint-satisfaction-problems">Chapter 34. Constraint Satisfaction Problems</a>
  <ul class="collapse">
  <li><a href="#defining-csps-variables-domains-and-constraints" id="toc-defining-csps-variables-domains-and-constraints" class="nav-link" data-scroll-target="#defining-csps-variables-domains-and-constraints">331. Defining CSPs: Variables, Domains, and Constraints</a></li>
  <li><a href="#constraint-graphs-and-visualization" id="toc-constraint-graphs-and-visualization" class="nav-link" data-scroll-target="#constraint-graphs-and-visualization">332. Constraint Graphs and Visualization</a></li>
  <li><a href="#backtracking-search-for-csps" id="toc-backtracking-search-for-csps" class="nav-link" data-scroll-target="#backtracking-search-for-csps">333. Backtracking Search for CSPs</a></li>
  <li><a href="#constraint-propagation-and-inference-forward-checking-ac-3" id="toc-constraint-propagation-and-inference-forward-checking-ac-3" class="nav-link" data-scroll-target="#constraint-propagation-and-inference-forward-checking-ac-3">334. Constraint Propagation and Inference (Forward Checking, AC-3)</a></li>
  <li><a href="#heuristics-for-csps-mrv-degree-and-least-constraining-value" id="toc-heuristics-for-csps-mrv-degree-and-least-constraining-value" class="nav-link" data-scroll-target="#heuristics-for-csps-mrv-degree-and-least-constraining-value">335. Heuristics for CSPs: MRV, Degree, and Least-Constraining Value</a></li>
  <li><a href="#local-search-for-csps-min-conflicts" id="toc-local-search-for-csps-min-conflicts" class="nav-link" data-scroll-target="#local-search-for-csps-min-conflicts">336. Local Search for CSPs (Min-Conflicts)</a></li>
  <li><a href="#complexity-of-csp-solving" id="toc-complexity-of-csp-solving" class="nav-link" data-scroll-target="#complexity-of-csp-solving">337. Complexity of CSP Solving</a></li>
  <li><a href="#extensions-stochastic-and-dynamic-csps" id="toc-extensions-stochastic-and-dynamic-csps" class="nav-link" data-scroll-target="#extensions-stochastic-and-dynamic-csps">338. Extensions: Stochastic and Dynamic CSPs</a></li>
  <li><a href="#applications-scheduling-map-coloring-sudoku" id="toc-applications-scheduling-map-coloring-sudoku" class="nav-link" data-scroll-target="#applications-scheduling-map-coloring-sudoku">339. Applications: Scheduling, Map Coloring, Sudoku</a></li>
  <li><a href="#case-study-csp-solving-in-ai-planning" id="toc-case-study-csp-solving-in-ai-planning" class="nav-link" data-scroll-target="#case-study-csp-solving-in-ai-planning">340. Case Study: CSP Solving in AI Planning</a></li>
  </ul></li>
  <li><a href="#chapter-5.-local-search-and-metaheuristics" id="toc-chapter-5.-local-search-and-metaheuristics" class="nav-link" data-scroll-target="#chapter-5.-local-search-and-metaheuristics">Chapter 5. Local Search and Metaheuristics</a>
  <ul class="collapse">
  <li><a href="#hill-climbing-and-its-variants" id="toc-hill-climbing-and-its-variants" class="nav-link" data-scroll-target="#hill-climbing-and-its-variants">342. Hill Climbing and Its Variants</a></li>
  <li><a href="#simulated-annealing-escaping-local-optima" id="toc-simulated-annealing-escaping-local-optima" class="nav-link" data-scroll-target="#simulated-annealing-escaping-local-optima">343. Simulated Annealing: Escaping Local Optima</a></li>
  <li><a href="#genetic-algorithms-populations-and-crossover" id="toc-genetic-algorithms-populations-and-crossover" class="nav-link" data-scroll-target="#genetic-algorithms-populations-and-crossover">344. Genetic Algorithms: Populations and Crossover</a></li>
  <li><a href="#tabu-search-and-memory-based-methods" id="toc-tabu-search-and-memory-based-methods" class="nav-link" data-scroll-target="#tabu-search-and-memory-based-methods">345. Tabu Search and Memory-Based Methods</a></li>
  <li><a href="#ant-colony-optimization-and-swarm-intelligence" id="toc-ant-colony-optimization-and-swarm-intelligence" class="nav-link" data-scroll-target="#ant-colony-optimization-and-swarm-intelligence">346. Ant Colony Optimization and Swarm Intelligence</a></li>
  <li><a href="#comparative-advantages-and-limitations-of-metaheuristics" id="toc-comparative-advantages-and-limitations-of-metaheuristics" class="nav-link" data-scroll-target="#comparative-advantages-and-limitations-of-metaheuristics">347. Comparative Advantages and Limitations of Metaheuristics</a></li>
  <li><a href="#parameter-tuning-and-convergence-issues" id="toc-parameter-tuning-and-convergence-issues" class="nav-link" data-scroll-target="#parameter-tuning-and-convergence-issues">348. Parameter Tuning and Convergence Issues</a></li>
  <li><a href="#applications-in-optimization-design-routing" id="toc-applications-in-optimization-design-routing" class="nav-link" data-scroll-target="#applications-in-optimization-design-routing">349. Applications in Optimization, Design, Routing</a></li>
  <li><a href="#case-study-metaheuristics-for-combinatorial-problems" id="toc-case-study-metaheuristics-for-combinatorial-problems" class="nav-link" data-scroll-target="#case-study-metaheuristics-for-combinatorial-problems">350. Case Study: Metaheuristics for Combinatorial Problems</a></li>
  </ul></li>
  <li><a href="#game-search-and-adversarial-planning" id="toc-game-search-and-adversarial-planning" class="nav-link" data-scroll-target="#game-search-and-adversarial-planning">36. Game search and adversarial planning</a>
  <ul class="collapse">
  <li><a href="#two-player-zero-sum-games-as-search-problems" id="toc-two-player-zero-sum-games-as-search-problems" class="nav-link" data-scroll-target="#two-player-zero-sum-games-as-search-problems">351. Two-Player Zero-Sum Games as Search Problems</a></li>
  <li><a href="#minimax-algorithm-and-game-trees" id="toc-minimax-algorithm-and-game-trees" class="nav-link" data-scroll-target="#minimax-algorithm-and-game-trees">352. Minimax Algorithm and Game Trees</a></li>
  <li><a href="#alpha-beta-pruning-and-efficiency-gains" id="toc-alpha-beta-pruning-and-efficiency-gains" class="nav-link" data-scroll-target="#alpha-beta-pruning-and-efficiency-gains">353. Alpha-Beta Pruning and Efficiency Gains</a></li>
  <li><a href="#heuristic-evaluation-functions-for-games" id="toc-heuristic-evaluation-functions-for-games" class="nav-link" data-scroll-target="#heuristic-evaluation-functions-for-games">354. Heuristic Evaluation Functions for Games</a></li>
  <li><a href="#iterative-deepening-and-real-time-constraints" id="toc-iterative-deepening-and-real-time-constraints" class="nav-link" data-scroll-target="#iterative-deepening-and-real-time-constraints">355. Iterative Deepening and Real-Time Constraints</a></li>
  <li><a href="#chance-nodes-and-stochastic-games" id="toc-chance-nodes-and-stochastic-games" class="nav-link" data-scroll-target="#chance-nodes-and-stochastic-games">356. Chance Nodes and Stochastic Games</a></li>
  <li><a href="#multi-player-and-non-zero-sum-games" id="toc-multi-player-and-non-zero-sum-games" class="nav-link" data-scroll-target="#multi-player-and-non-zero-sum-games">357. Multi-Player and Non-Zero-Sum Games</a></li>
  <li><a href="#monte-carlo-tree-search-mcts" id="toc-monte-carlo-tree-search-mcts" class="nav-link" data-scroll-target="#monte-carlo-tree-search-mcts">358. Monte Carlo Tree Search (MCTS)</a></li>
  <li><a href="#applications-chess-go-and-real-time-strategy-games" id="toc-applications-chess-go-and-real-time-strategy-games" class="nav-link" data-scroll-target="#applications-chess-go-and-real-time-strategy-games">359. Applications: Chess, Go, and Real-Time Strategy Games</a></li>
  <li><a href="#case-study-modern-game-ai-systems" id="toc-case-study-modern-game-ai-systems" class="nav-link" data-scroll-target="#case-study-modern-game-ai-systems">360. Case Study: Modern Game AI Systems</a></li>
  </ul></li>
  <li><a href="#chapter-37.-planning-in-determistic-domains" id="toc-chapter-37.-planning-in-determistic-domains" class="nav-link" data-scroll-target="#chapter-37.-planning-in-determistic-domains">Chapter 37. Planning in Determistic Domains</a>
  <ul class="collapse">
  <li><a href="#classical-planning-problem-definition" id="toc-classical-planning-problem-definition" class="nav-link" data-scroll-target="#classical-planning-problem-definition">361. Classical Planning Problem Definition</a></li>
  <li><a href="#strips-representation-and-operators" id="toc-strips-representation-and-operators" class="nav-link" data-scroll-target="#strips-representation-and-operators">362. STRIPS Representation and Operators</a></li>
  <li><a href="#forward-and-backward-state-space-planning" id="toc-forward-and-backward-state-space-planning" class="nav-link" data-scroll-target="#forward-and-backward-state-space-planning">363. Forward and Backward State-Space Planning</a></li>
  <li><a href="#plan-space-planning-partial-order-planning" id="toc-plan-space-planning-partial-order-planning" class="nav-link" data-scroll-target="#plan-space-planning-partial-order-planning">364. Plan-Space Planning (Partial-Order Planning)</a></li>
  <li><a href="#graphplan-algorithm-and-planning-graphs" id="toc-graphplan-algorithm-and-planning-graphs" class="nav-link" data-scroll-target="#graphplan-algorithm-and-planning-graphs">365. Graphplan Algorithm and Planning Graphs</a></li>
  <li><a href="#heuristic-search-planners-e.g.-ff-planner" id="toc-heuristic-search-planners-e.g.-ff-planner" class="nav-link" data-scroll-target="#heuristic-search-planners-e.g.-ff-planner">366. Heuristic Search Planners (e.g., FF Planner)</a></li>
  <li><a href="#planning-domain-definition-language-pddl" id="toc-planning-domain-definition-language-pddl" class="nav-link" data-scroll-target="#planning-domain-definition-language-pddl">367. Planning Domain Definition Language (PDDL)</a></li>
  <li><a href="#temporal-and-resource-augmented-planning" id="toc-temporal-and-resource-augmented-planning" class="nav-link" data-scroll-target="#temporal-and-resource-augmented-planning">368. Temporal and Resource-Augmented Planning</a></li>
  <li><a href="#applications-in-robotics-and-logistics" id="toc-applications-in-robotics-and-logistics" class="nav-link" data-scroll-target="#applications-in-robotics-and-logistics">369. Applications in Robotics and Logistics</a></li>
  <li><a href="#case-study-deterministic-planning-systems" id="toc-case-study-deterministic-planning-systems" class="nav-link" data-scroll-target="#case-study-deterministic-planning-systems">370. Case Study: Deterministic Planning Systems</a></li>
  </ul></li>
  <li><a href="#chapter-38.-probabilistic-planning-and-pomdps" id="toc-chapter-38.-probabilistic-planning-and-pomdps" class="nav-link" data-scroll-target="#chapter-38.-probabilistic-planning-and-pomdps">Chapter 38. Probabilistic Planning and POMDPs</a>
  <ul class="collapse">
  <li><a href="#planning-under-uncertainty-motivation-and-models" id="toc-planning-under-uncertainty-motivation-and-models" class="nav-link" data-scroll-target="#planning-under-uncertainty-motivation-and-models">371. Planning Under Uncertainty: Motivation and Models</a></li>
  <li><a href="#markov-decision-processes-mdps-revisited" id="toc-markov-decision-processes-mdps-revisited" class="nav-link" data-scroll-target="#markov-decision-processes-mdps-revisited">372. Markov Decision Processes (MDPs) Revisited</a></li>
  <li><a href="#value-iteration-and-policy-iteration-for-planning" id="toc-value-iteration-and-policy-iteration-for-planning" class="nav-link" data-scroll-target="#value-iteration-and-policy-iteration-for-planning">373. Value Iteration and Policy Iteration for Planning</a></li>
  <li><a href="#partially-observable-mdps-pomdps" id="toc-partially-observable-mdps-pomdps" class="nav-link" data-scroll-target="#partially-observable-mdps-pomdps">374. Partially Observable MDPs (POMDPs)</a></li>
  <li><a href="#belief-states-and-their-representation" id="toc-belief-states-and-their-representation" class="nav-link" data-scroll-target="#belief-states-and-their-representation">375. Belief States and Their Representation</a></li>
  <li><a href="#approximate-methods-for-large-pomdps" id="toc-approximate-methods-for-large-pomdps" class="nav-link" data-scroll-target="#approximate-methods-for-large-pomdps">376. Approximate Methods for Large POMDPs</a></li>
  <li><a href="#monte-carlo-and-point-based-value-iteration" id="toc-monte-carlo-and-point-based-value-iteration" class="nav-link" data-scroll-target="#monte-carlo-and-point-based-value-iteration">377. Monte Carlo and Point-Based Value Iteration</a></li>
  <li><a href="#hierarchical-and-factored-probabilistic-planning" id="toc-hierarchical-and-factored-probabilistic-planning" class="nav-link" data-scroll-target="#hierarchical-and-factored-probabilistic-planning">378. Hierarchical and Factored Probabilistic Planning</a></li>
  <li><a href="#applications-dialogue-systems-and-robot-navigation" id="toc-applications-dialogue-systems-and-robot-navigation" class="nav-link" data-scroll-target="#applications-dialogue-systems-and-robot-navigation">379. Applications: Dialogue Systems and Robot Navigation</a></li>
  <li><a href="#case-study-pomdp-based-decision-making" id="toc-case-study-pomdp-based-decision-making" class="nav-link" data-scroll-target="#case-study-pomdp-based-decision-making">380. Case Study: POMDP-Based Decision Making</a></li>
  </ul></li>
  <li><a href="#chapter-39.-scheduling-and-resource-allocation" id="toc-chapter-39.-scheduling-and-resource-allocation" class="nav-link" data-scroll-target="#chapter-39.-scheduling-and-resource-allocation">Chapter 39. Scheduling and Resource Allocation</a>
  <ul class="collapse">
  <li><a href="#scheduling-as-a-search-and-optimization-problem" id="toc-scheduling-as-a-search-and-optimization-problem" class="nav-link" data-scroll-target="#scheduling-as-a-search-and-optimization-problem">381. Scheduling as a Search and Optimization Problem</a></li>
  <li><a href="#types-of-scheduling-problems-job-shop-flow-shop-task-scheduling" id="toc-types-of-scheduling-problems-job-shop-flow-shop-task-scheduling" class="nav-link" data-scroll-target="#types-of-scheduling-problems-job-shop-flow-shop-task-scheduling">382. Types of Scheduling Problems (Job-Shop, Flow-Shop, Task Scheduling)</a></li>
  <li><a href="#exact-algorithms-branch-and-bound-ilp" id="toc-exact-algorithms-branch-and-bound-ilp" class="nav-link" data-scroll-target="#exact-algorithms-branch-and-bound-ilp">383. Exact Algorithms: Branch-and-Bound, ILP</a></li>
  <li><a href="#heuristic-and-rule-based-scheduling-methods" id="toc-heuristic-and-rule-based-scheduling-methods" class="nav-link" data-scroll-target="#heuristic-and-rule-based-scheduling-methods">384. Heuristic and Rule-Based Scheduling Methods</a></li>
  <li><a href="#constraint-based-scheduling-systems" id="toc-constraint-based-scheduling-systems" class="nav-link" data-scroll-target="#constraint-based-scheduling-systems">385. Constraint-Based Scheduling Systems</a></li>
  <li><a href="#resource-allocation-with-limited-capacity" id="toc-resource-allocation-with-limited-capacity" class="nav-link" data-scroll-target="#resource-allocation-with-limited-capacity">386. Resource Allocation with Limited Capacity</a></li>
  <li><a href="#multi-objective-scheduling-and-trade-offs" id="toc-multi-objective-scheduling-and-trade-offs" class="nav-link" data-scroll-target="#multi-objective-scheduling-and-trade-offs">387. Multi-Objective Scheduling and Trade-Offs</a></li>
  <li><a href="#approximation-algorithms-for-scheduling" id="toc-approximation-algorithms-for-scheduling" class="nav-link" data-scroll-target="#approximation-algorithms-for-scheduling">388. Approximation Algorithms for Scheduling</a></li>
  <li><a href="#applications-manufacturing-cloud-computing-healthcare" id="toc-applications-manufacturing-cloud-computing-healthcare" class="nav-link" data-scroll-target="#applications-manufacturing-cloud-computing-healthcare">389. Applications: Manufacturing, Cloud Computing, Healthcare</a></li>
  <li><a href="#case-study-large-scale-scheduling-systems" id="toc-case-study-large-scale-scheduling-systems" class="nav-link" data-scroll-target="#case-study-large-scale-scheduling-systems">390. Case Study: Large-Scale Scheduling Systems</a></li>
  </ul></li>
  <li><a href="#chapter-40.-meta-reasoning-and-anytime-algorithms" id="toc-chapter-40.-meta-reasoning-and-anytime-algorithms" class="nav-link" data-scroll-target="#chapter-40.-meta-reasoning-and-anytime-algorithms">Chapter 40. Meta Reasoning and Anytime Algorithms</a>
  <ul class="collapse">
  <li><a href="#meta-reasoning-reasoning-about-reasoning" id="toc-meta-reasoning-reasoning-about-reasoning" class="nav-link" data-scroll-target="#meta-reasoning-reasoning-about-reasoning">391. Meta-Reasoning: Reasoning About Reasoning</a></li>
  <li><a href="#trade-offs-between-time-accuracy-and-computation" id="toc-trade-offs-between-time-accuracy-and-computation" class="nav-link" data-scroll-target="#trade-offs-between-time-accuracy-and-computation">392. Trade-Offs Between Time, Accuracy, and Computation</a></li>
  <li><a href="#bounded-rationality-and-resource-limitations" id="toc-bounded-rationality-and-resource-limitations" class="nav-link" data-scroll-target="#bounded-rationality-and-resource-limitations">393. Bounded Rationality and Resource Limitations</a></li>
  <li><a href="#anytime-algorithms-concept-and-design-principles" id="toc-anytime-algorithms-concept-and-design-principles" class="nav-link" data-scroll-target="#anytime-algorithms-concept-and-design-principles">394. Anytime Algorithms: Concept and Design Principles</a></li>
  <li><a href="#examples-of-anytime-search-and-planning" id="toc-examples-of-anytime-search-and-planning" class="nav-link" data-scroll-target="#examples-of-anytime-search-and-planning">395. Examples of Anytime Search and Planning</a></li>
  <li><a href="#performance-profiles-and-monitoring" id="toc-performance-profiles-and-monitoring" class="nav-link" data-scroll-target="#performance-profiles-and-monitoring">396. Performance Profiles and Monitoring</a></li>
  <li><a href="#interruptibility-and-graceful-degradation" id="toc-interruptibility-and-graceful-degradation" class="nav-link" data-scroll-target="#interruptibility-and-graceful-degradation">397. Interruptibility and Graceful Degradation</a></li>
  <li><a href="#metacontrol-allocating-computational-effort" id="toc-metacontrol-allocating-computational-effort" class="nav-link" data-scroll-target="#metacontrol-allocating-computational-effort">398. Metacontrol: Allocating Computational Effort</a></li>
  <li><a href="#applications-in-robotics-games-and-real-time-ai" id="toc-applications-in-robotics-games-and-real-time-ai" class="nav-link" data-scroll-target="#applications-in-robotics-games-and-real-time-ai">399. Applications in Robotics, Games, and Real-Time AI</a></li>
  <li><a href="#case-study-meta-reasoning-in-ai-systems" id="toc-case-study-meta-reasoning-in-ai-systems" class="nav-link" data-scroll-target="#case-study-meta-reasoning-in-ai-systems">400. Case Study: Meta-Reasoning in AI Systems</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">Volume 4. Search and Planning</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Paths</span> branch left and right,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">search</span> explores the tangled maze,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">a</span> goal shines ahead.</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="chapter-31.-state-spaces-and-problem-formulation" class="level2">
<h2 class="anchored" data-anchor-id="chapter-31.-state-spaces-and-problem-formulation">Chapter 31. State Spaces and Problem Formulation</h2>
<section id="defining-state-spaces-and-representation-choices" class="level3">
<h3 class="anchored" data-anchor-id="defining-state-spaces-and-representation-choices">301. Defining State Spaces and Representation Choices</h3>
<p>A state space is the universe of possibilities an agent must navigate. It contains all the configurations the system can be in, the actions that move between them, and the conditions that define success. Choosing how to represent the state space is the first and most crucial design step in any search or planning problem.</p>
<section id="picture-in-your-head" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head">Picture in Your Head</h4>
<p>Imagine a maze on graph paper. Each square you can stand in is a <em>state</em>. Each move north, south, east, or west is an <em>action</em> that transitions you to a new state. The start of the maze is the <em>initial state</em>. The exit is the <em>goal state</em>. The collection of all reachable squares, and the paths between them, is the <em>state space</em>.</p>
</section>
<section id="deep-dive" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive">Deep Dive</h4>
<p>State spaces are not just abstract sets; they encode trade-offs. A <em>fine-grained representation</em> captures every detail but may explode into billions of states. A <em>coarse-grained representation</em> simplifies the world, reducing complexity but sometimes losing critical distinctions. For instance, representing a robot’s location as exact coordinates may yield precision but overwhelm search; representing it as “room A, room B” reduces the space but hides exact positions.</p>
<p>Formally, a state space can be defined as a tuple <span class="math inline">\((S, A, T, s_0, G)\)</span>:</p>
<ul>
<li><span class="math inline">\(S\)</span>: set of possible states</li>
<li><span class="math inline">\(A\)</span>: set of actions</li>
<li><span class="math inline">\(T(s, a)\)</span>: transition model describing how actions transform states</li>
<li><span class="math inline">\(s_0\)</span>: initial state</li>
<li><span class="math inline">\(G\)</span>: set of goal states</li>
</ul>
<p>Choosing the representation influences every downstream property: whether the search is tractable, whether heuristics can be designed, and whether solutions are meaningful.</p>
</section>
<section id="tiny-code" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code">Tiny Code</h4>
<p>Here’s a minimal representation of a state space for a maze:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> namedtuple</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>State <span class="op">=</span> namedtuple(<span class="st">"State"</span>, [<span class="st">"x"</span>, <span class="st">"y"</span>])</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Actions: up, down, left, right</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>ACTIONS <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>), (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">0</span>)]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transition(state, action, maze):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Return next state if valid, else None."""</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> state.x <span class="op">+</span> action[<span class="dv">0</span>], state.y <span class="op">+</span> action[<span class="dv">1</span>]</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x, y) <span class="kw">in</span> maze:  <span class="co"># maze is a set of valid coordinates</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> State(x, y)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> State(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>goal <span class="op">=</span> State(<span class="dv">3</span>, <span class="dv">3</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This representation lets us enumerate possible states and transitions cleanly.</p>
</section>
<section id="why-it-matters" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters">Why It Matters</h4>
<p>The way you define the state space determines whether a problem is solvable in practice. A poor choice can make even simple problems intractable; a clever abstraction can make difficult tasks feasible. Every search and planning method that follows rests on this foundation.</p>
</section>
<section id="try-it-yourself" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself">Try It Yourself</h4>
<ol type="1">
<li>Represent the 8-puzzle as a state space. What are <span class="math inline">\(S, A, T, s_0, G\)</span>?</li>
<li>If a delivery robot must visit several addresses, how would you define states: exact coordinates, streets, or just “delivered/not delivered”?</li>
<li>Create a Python function that generates all possible moves in tic-tac-toe from a given board configuration.</li>
</ol>
</section>
</section>
<section id="initial-states-goal-states-and-transition-models" class="level3">
<h3 class="anchored" data-anchor-id="initial-states-goal-states-and-transition-models">302. Initial States, Goal States, and Transition Models</h3>
<p>Every search problem is anchored by three ingredients: where you start, where you want to go, and how you move between the two. The <em>initial state</em> defines the system’s starting point, the <em>goal state</em> (or states) define success, and the <em>transition model</em> specifies the rules for moving from one state to another.</p>
<section id="picture-in-your-head-1" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-1">Picture in Your Head</h4>
<p>Picture solving a Rubik’s Cube. The scrambled cube in your hands is the <em>initial state</em>. The solved cube—with uniform faces—is the <em>goal state</em>. Every twist of a face is a <em>transition</em>. The collection of all possible cube configurations reachable by twisting defines the problem space.</p>
</section>
<section id="deep-dive-1" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-1">Deep Dive</h4>
<ul>
<li>Initial State (<span class="math inline">\(s_0\)</span>): Often given explicitly. In navigation, it is the current location; in a puzzle, the starting arrangement.</li>
<li>Goal Test (<span class="math inline">\(G\)</span>): Can be a single target (e.g., “reach node X”), a set of targets (e.g., “any state with zero queens in conflict”), or a property to check dynamically (e.g., “is the cube solved?”).</li>
<li>Transition Model (<span class="math inline">\(T(s, a)\)</span>): Defines the effect of an action. It can be deterministic (each action leads to exactly one successor) or stochastic (an action leads to a distribution of successors).</li>
</ul>
<p>Mathematically, a problem instance is <span class="math inline">\((S, A, T, s_0, G)\)</span>. Defining each component clearly allows algorithms to explore possible paths systematically.</p>
</section>
<section id="tiny-code-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-1">Tiny Code</h4>
<p>Here’s a simple definition of initial, goal, and transitions in a grid world:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>State <span class="op">=</span> <span class="bu">tuple</span>  <span class="co"># (x, y)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>ACTIONS <span class="op">=</span> {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"up"</span>:    (<span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"down"</span>:  (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"left"</span>:  (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"right"</span>: (<span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>start_state <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>goal_state <span class="op">=</span> (<span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_goal(state):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> state <span class="op">==</span> goal_state</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> successors(state, maze):</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> state</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dx, dy <span class="kw">in</span> ACTIONS.values():</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        nx, ny <span class="op">=</span> x <span class="op">+</span> dx, y <span class="op">+</span> dy</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (nx, ny) <span class="kw">in</span> maze:</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> (nx, ny)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This code separates the <em>initial state</em> (<code>start_state</code>), the <em>goal test</em> (<code>is_goal</code>), and the <em>transition model</em> (<code>successors</code>).</p>
</section>
<section id="why-it-matters-1" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-1">Why It Matters</h4>
<p>Clearly defined initial states, goal conditions, and transitions make problems precise and solvable. Without them, algorithms have nothing to explore. Good definitions also influence efficiency: a too-general goal test or overly complex transitions can make a tractable problem infeasible.</p>
</section>
<section id="try-it-yourself-1" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-1">Try It Yourself</h4>
<ol type="1">
<li>Define the initial state, goal test, and transitions for the 8-queens puzzle.</li>
<li>For a robot vacuum, what should the goal be: every tile clean, or specific rooms clean?</li>
<li>Extend the grid-world code to allow diagonal moves as additional transitions.</li>
</ol>
</section>
</section>
<section id="problem-formulation-examples-puzzles-navigation-games" class="level3">
<h3 class="anchored" data-anchor-id="problem-formulation-examples-puzzles-navigation-games">303. Problem Formulation Examples (Puzzles, Navigation, Games)</h3>
<p>Problem formulation translates an informal task into a precise search problem. It means deciding what counts as a state, what actions are allowed, and how to test for a goal. The formulation is not unique; different choices produce different state spaces, which can radically affect difficulty.</p>
<section id="picture-in-your-head-2" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-2">Picture in Your Head</h4>
<p>Think of chess. You could represent the full board as a state with every piece’s position, or you could abstract positions into “winning/losing” classes. Both are valid formulations but lead to very different search landscapes.</p>
</section>
<section id="deep-dive-2" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-2">Deep Dive</h4>
<ul>
<li>Puzzles: In the 8-puzzle, a state is a board configuration; actions are sliding tiles; the goal is a sorted arrangement. The formulation is compact and well-defined.</li>
<li>Navigation: In a map, states can be intersections, actions are roads, and the goal is reaching a destination. For robots, states may be continuous coordinates, which requires discretization.</li>
<li>Games: In tic-tac-toe, states are board positions, actions are legal moves, and the goal test is a winning line. The problem can also be formulated as a minimax search tree.</li>
</ul>
<p>A key insight is that the formulation balances <em>fidelity</em> (how accurately it models reality) and <em>tractability</em> (how feasible it is to search). Overly detailed formulations explode in size; oversimplified ones may miss essential distinctions.</p>
</section>
<section id="tiny-code-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-2">Tiny Code</h4>
<p>Formulation of the 8-puzzle:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> namedtuple</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>Puzzle <span class="op">=</span> namedtuple(<span class="st">"Puzzle"</span>, [<span class="st">"tiles"</span>])  <span class="co"># flat list of length 9</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>GOAL <span class="op">=</span> Puzzle([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">0</span>])  <span class="co"># 0 = empty space</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> actions(state):</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> state.tiles.index(<span class="dv">0</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    moves <span class="op">=</span> []</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    row, col <span class="op">=</span> <span class="bu">divmod</span>(i, <span class="dv">3</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> row <span class="op">&gt;</span> <span class="dv">0</span>: moves.append(<span class="op">-</span><span class="dv">3</span>)  <span class="co"># up</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> row <span class="op">&lt;</span> <span class="dv">2</span>: moves.append(<span class="dv">3</span>)   <span class="co"># down</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="op">&gt;</span> <span class="dv">0</span>: moves.append(<span class="op">-</span><span class="dv">1</span>)  <span class="co"># left</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="op">&lt;</span> <span class="dv">2</span>: moves.append(<span class="dv">1</span>)   <span class="co"># right</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> moves</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transition(state, move):</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    tiles <span class="op">=</span> state.tiles[:]</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> tiles.index(<span class="dv">0</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> i <span class="op">+</span> move</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    tiles[i], tiles[j] <span class="op">=</span> tiles[j], tiles[i]</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Puzzle(tiles)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This defines states, actions, transitions, and the goal compactly.</p>
</section>
<section id="why-it-matters-2" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-2">Why It Matters</h4>
<p>Problem formulation is the foundation of intelligent behavior. A poor formulation leads to wasted computation or unsolvable problems. A clever formulation—like using abstractions or compact encodings—can make the difference between impossible and trivial.</p>
</section>
<section id="try-it-yourself-2" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-2">Try It Yourself</h4>
<ol type="1">
<li>Formulate Sudoku as a search problem: what are the states, actions, and goals?</li>
<li>Represent navigation in a city with states as intersections. How does complexity change if you represent every GPS coordinate?</li>
<li>Write a Python function that checks whether a tic-tac-toe board state is a goal state (win or draw).</li>
</ol>
</section>
</section>
<section id="abstraction-and-granularity-in-state-modeling" class="level3">
<h3 class="anchored" data-anchor-id="abstraction-and-granularity-in-state-modeling">304. Abstraction and Granularity in State Modeling</h3>
<p>Abstraction is the art of deciding which details matter in a problem and which can be ignored. Granularity refers to the level of detail chosen for states: fine-grained models capture every nuance, while coarse-grained models simplify. The trade-off is between precision and tractability.</p>
<section id="picture-in-your-head-3" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-3">Picture in Your Head</h4>
<p>Imagine planning a trip. At a coarse level, states might be “in Paris” or “in Rome.” At a finer level, states could be “at Gate 12 in Charles de Gaulle airport, holding boarding pass.” The first helps plan quickly, the second allows precise navigation but explodes the search space.</p>
</section>
<section id="deep-dive-3" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-3">Deep Dive</h4>
<ul>
<li>Fine-grained models: Rich in detail but computationally heavy. Example: robot location in continuous coordinates.</li>
<li>Coarse-grained models: Simplify search but may lose accuracy. Example: robot location represented by “room number.”</li>
<li>Hierarchical abstraction: Many systems combine both. A planner first reasons coarsely (which cities to visit) and later refines to finer details (which streets to walk).</li>
<li>Dynamic granularity: Some systems adjust the level of abstraction on the fly, zooming in when details matter and zooming out otherwise.</li>
</ul>
<p>Choosing the right granularity often determines whether a problem is solvable in practice. Abstraction is not just about saving computation; it also helps reveal structure and symmetries in the problem.</p>
</section>
<section id="tiny-code-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-3">Tiny Code</h4>
<p>Hierarchical navigation example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Coarse level: rooms connected by doors</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>rooms <span class="op">=</span> {</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"A"</span>: [<span class="st">"B"</span>],</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"B"</span>: [<span class="st">"A"</span>, <span class="st">"C"</span>],</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"C"</span>: [<span class="st">"B"</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Fine level: grid coordinates within each room</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>room_layouts <span class="op">=</span> {</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"A"</span>: {(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">0</span>,<span class="dv">1</span>)},</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"B"</span>: {(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">1</span>)},</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"C"</span>: {(<span class="dv">0</span>,<span class="dv">0</span>)}</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> coarse_path(start_room, goal_room):</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simple BFS at room level</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    q, visited <span class="op">=</span> deque([(start_room, [])]), <span class="bu">set</span>()</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        room, path <span class="op">=</span> q.popleft()</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> room <span class="op">==</span> goal_room:</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path <span class="op">+</span> [room]</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> room <span class="kw">in</span> visited: <span class="cf">continue</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        visited.add(room)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> neighbor <span class="kw">in</span> rooms[room]:</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            q.append((neighbor, path <span class="op">+</span> [room]))</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(coarse_path(<span class="st">"A"</span>, <span class="st">"C"</span>))  <span class="co"># ['A', 'B', 'C']</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This separates reasoning into a <em>coarse level</em> (rooms) and a <em>fine level</em> (coordinates inside each room).</p>
</section>
<section id="why-it-matters-3" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-3">Why It Matters</h4>
<p>Without abstraction, most real-world problems are intractable. With it, complex planning tasks can be decomposed into manageable steps. The granularity chosen directly affects performance, accuracy, and the interpretability of solutions.</p>
</section>
<section id="try-it-yourself-3" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-3">Try It Yourself</h4>
<ol type="1">
<li>Model a chess game with coarse granularity (“piece advantage”) and fine granularity (“exact piece positions”). Compare their usefulness.</li>
<li>In a delivery scenario, define states at city-level vs.&nbsp;street-level. Which level is best for high-level route planning?</li>
<li>Write code that allows switching between fine and coarse representations in a grid maze (cells vs.&nbsp;regions).</li>
</ol>
</section>
</section>
<section id="state-explosion-and-strategies-for-reduction" class="level3">
<h3 class="anchored" data-anchor-id="state-explosion-and-strategies-for-reduction">305. State Explosion and Strategies for Reduction</h3>
<p>The <em>state explosion problem</em> arises when the number of possible states in a system grows exponentially with the number of variables. Even simple rules can create an astronomical number of states, making brute-force search infeasible. Strategies for reduction aim to tame this explosion by pruning, compressing, or reorganizing the search space.</p>
<section id="picture-in-your-head-4" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-4">Picture in Your Head</h4>
<p>Think of trying every possible move in chess. There are about <span class="math inline">\(10^{120}\)</span> possible games—more than atoms in the observable universe. Without reduction strategies, search would drown in possibilities before reaching any useful result.</p>
</section>
<section id="deep-dive-4" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-4">Deep Dive</h4>
<ul>
<li>Symmetry Reduction: Many states are equivalent under symmetry. In puzzles, rotations or reflections don’t need separate exploration.</li>
<li>Canonicalization: Map equivalent states to a single “canonical” representative.</li>
<li>Pruning: Cut off branches that cannot possibly lead to a solution. Alpha-beta pruning in games is a classic example.</li>
<li>Abstraction: Simplify the state representation by ignoring irrelevant details.</li>
<li>Hierarchical Decomposition: Break the problem into smaller subproblems. Solve coarsely first, then refine.</li>
<li>Memoization and Hashing: Remember visited states to avoid revisiting.</li>
</ul>
<p>The goal is not to eliminate states but to avoid wasting computation on duplicates, irrelevant cases, or hopeless branches.</p>
</section>
<section id="tiny-code-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-4">Tiny Code</h4>
<p>A simple pruning technique in path search:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(state, goal, visited, limit<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [state]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(visited) <span class="op">&gt;</span> limit:  <span class="co"># depth limit to reduce explosion</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> next_state <span class="kw">in</span> successors(state):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> next_state <span class="kw">in</span> visited:  <span class="co"># avoid revisits</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        path <span class="op">=</span> dfs(next_state, goal, visited <span class="op">|</span> {next_state}, limit)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> path:</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> [state] <span class="op">+</span> path</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here, <em>depth limits</em> and <em>visited sets</em> cut down the number of explored states.</p>
</section>
<section id="why-it-matters-4" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-4">Why It Matters</h4>
<p>Unchecked state explosion makes many problems practically unsolvable. Strategies for reduction enable algorithms to scale, turning an impossible brute-force search into something that can return answers within realistic time and resource limits.</p>
</section>
<section id="try-it-yourself-4" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-4">Try It Yourself</h4>
<ol type="1">
<li>For tic-tac-toe, estimate the number of possible states. Then identify how many are symmetric duplicates.</li>
<li>Modify the DFS code to add pruning based on a cost bound (e.g., do not explore paths longer than the best found so far).</li>
<li>Consider Sudoku: what symmetries or pruning strategies can reduce the search space without losing valid solutions?</li>
</ol>
</section>
</section>
<section id="canonical-forms-and-equivalence-classes" class="level3">
<h3 class="anchored" data-anchor-id="canonical-forms-and-equivalence-classes">306. Canonical Forms and Equivalence Classes</h3>
<p>A canonical form is a standard representation chosen to stand for all states that are equivalent under some transformation. Equivalence classes group states that are essentially the same for the purpose of solving a problem. By mapping many states into one representative, search can avoid redundancy and shrink the state space dramatically.</p>
<section id="picture-in-your-head-5" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-5">Picture in Your Head</h4>
<p>Imagine sliding puzzles: two board positions that differ only by rotating the whole board are “the same” in terms of solvability. Instead of treating each rotated version separately, you can pick one arrangement as the <em>canonical form</em> and treat all others as belonging to the same equivalence class.</p>
</section>
<section id="deep-dive-5" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-5">Deep Dive</h4>
<ul>
<li><p>Equivalence relation: A rule defining when two states are considered the same (e.g., symmetry, renaming, rotation).</p></li>
<li><p>Equivalence class: The set of all states related to each other by that rule.</p></li>
<li><p>Canonicalization: The process of selecting a single representative state from each equivalence class.</p></li>
<li><p>Benefits: Reduces redundant exploration, improves efficiency, and often reveals deeper structure in the problem.</p></li>
<li><p>Examples:</p>
<ul>
<li>Tic-tac-toe boards rotated or reflected are equivalent.</li>
<li>In graph isomorphism, different adjacency lists may represent the same underlying graph.</li>
<li>In algebra, fractions like <span class="math inline">\(2/4\)</span> and <span class="math inline">\(1/2\)</span> reduce to a canonical form.</li>
</ul></li>
</ul>
</section>
<section id="tiny-code-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-5">Tiny Code</h4>
<p>Canonical representation of tic-tac-toe boards under rotation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rotate(board):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># board is a 3x3 list of lists</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="bu">list</span>(row) <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">zip</span>(<span class="op">*</span>board[::<span class="op">-</span><span class="dv">1</span>])]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> canonical(board):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># generate all rotations and reflections</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    transforms <span class="op">=</span> []</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> board</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        transforms.append(b)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        transforms.append([row[::<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> row <span class="kw">in</span> b])  <span class="co"># reflection</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> rotate(b)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># pick lexicographically smallest representation</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(<span class="bu">map</span>(<span class="bu">str</span>, transforms))</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>board <span class="op">=</span> [[<span class="st">"X"</span>,<span class="st">"O"</span>,<span class="st">""</span>],</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>         [<span class="st">""</span>,<span class="st">"X"</span>,<span class="st">""</span>],</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>         [<span class="st">"O"</span>,<span class="st">""</span>,<span class="st">""</span>]]</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(canonical(board))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This function ensures that all symmetric boards collapse into one canonical form.</p>
</section>
<section id="why-it-matters-5" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-5">Why It Matters</h4>
<p>Canonical forms and equivalence classes prevent wasted effort. By reducing redundancy, they make it feasible to search or reason in spaces that would otherwise be unmanageable. They also provide a principled way to compare states and ensure consistency across algorithms.</p>
</section>
<section id="try-it-yourself-5" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-5">Try It Yourself</h4>
<ol type="1">
<li>Define equivalence classes for the 8-puzzle based on board symmetries. How much does this shrink the search space?</li>
<li>Write a function that reduces fractions to canonical form. Compare efficiency when used in arithmetic.</li>
<li>For graph coloring, define a canonical labeling of nodes that removes symmetry from node renaming.</li>
</ol>
</section>
</section>
<section id="canonical-forms-and-equivalence-classes-1" class="level3">
<h3 class="anchored" data-anchor-id="canonical-forms-and-equivalence-classes-1">306. Canonical Forms and Equivalence Classes</h3>
<p>A canonical form is a standard way of representing a state so that equivalent states collapse into one representation. Equivalence classes are groups of states considered the same under a defined relation, such as rotation, reflection, or renaming. By mapping many possible states into fewer representatives, search avoids duplication and becomes more efficient.</p>
<section id="picture-in-your-head-6" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-6">Picture in Your Head</h4>
<p>Imagine tic-tac-toe boards. If you rotate the board by 90 degrees or flip it horizontally, the position is strategically identical. Treating these as distinct states wastes computation. Instead, all such boards can be grouped into an equivalence class with one canonical representative.</p>
</section>
<section id="deep-dive-6" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-6">Deep Dive</h4>
<p>Equivalence is defined by a relation <span class="math inline">\(\sim\)</span> that partitions the state space into disjoint sets. Each set is an equivalence class. Canonicalization selects one element (often the lexicographically smallest or otherwise normalized form) to stand for the whole class.</p>
<p>This matters because many problems have hidden symmetries that blow up the search space unnecessarily. By collapsing symmetries, algorithms can work on a smaller, more meaningful set of states.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 32%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th>Example Domain</th>
<th>Equivalence Relation</th>
<th>Canonical Form Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tic-tac-toe</td>
<td>Rotation, reflection</td>
<td>Smallest string encoding of the board</td>
</tr>
<tr class="even">
<td>8-puzzle</td>
<td>Rotations of the board</td>
<td>Chosen rotation as baseline</td>
</tr>
<tr class="odd">
<td>Graph isomorphism</td>
<td>Node relabeling</td>
<td>Canonical adjacency matrix</td>
</tr>
<tr class="even">
<td>Fractions</td>
<td>Multiplication by constant</td>
<td>Lowest terms (e.g., 1/2)</td>
</tr>
</tbody>
</table>
<p>Breaking down the process:</p>
<ol type="1">
<li>Define equivalence: Decide what makes two states “the same.”</li>
<li>Generate transformations: Rotate, reflect, or relabel to see all variants.</li>
<li>Choose canonical form: Pick a single representative, often by ordering.</li>
<li>Use during search: Replace every state with its canonical version before storing or exploring it.</li>
</ol>
</section>
<section id="tiny-code-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-6">Tiny Code</h4>
<p>Canonical representation for tic-tac-toe under rotation/reflection:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rotate(board):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="bu">list</span>(row) <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">zip</span>(<span class="op">*</span>board[::<span class="op">-</span><span class="dv">1</span>])]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> canonical(board):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    variants, b <span class="op">=</span> [], board</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        variants.append(b)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        variants.append([row[::<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> row <span class="kw">in</span> b])  <span class="co"># reflection</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> rotate(b)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(<span class="bu">map</span>(<span class="bu">str</span>, variants))  <span class="co"># pick smallest as canonical</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This ensures symmetric positions collapse into one representation.</p>
</section>
<section id="why-it-matters-6" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-6">Why It Matters</h4>
<p>Without canonicalization, search wastes effort revisiting states that are essentially the same. With it, the effective search space is dramatically smaller. This not only improves runtime but also ensures results are consistent and comparable across problems.</p>
</section>
<section id="try-it-yourself-6" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-6">Try It Yourself</h4>
<ol type="1">
<li>Define equivalence classes for Sudoku boards under row/column swaps. How many classes remain compared to the raw state count?</li>
<li>Write a Python function to canonicalize fractions by dividing numerator and denominator by their greatest common divisor.</li>
<li>Create a canonical labeling function for graphs so that isomorphic graphs produce identical adjacency matrices.</li>
</ol>
</section>
</section>
<section id="implicit-vs.-explicit-state-space-representation" class="level3">
<h3 class="anchored" data-anchor-id="implicit-vs.-explicit-state-space-representation">307. Implicit vs.&nbsp;Explicit State Space Representation</h3>
<p>A state space can be represented explicitly by enumerating all possible states or implicitly by defining rules that generate states on demand. Explicit representations are straightforward but memory-intensive. Implicit representations are more compact and flexible, often the only feasible option for large or infinite spaces.</p>
<section id="picture-in-your-head-7" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-7">Picture in Your Head</h4>
<p>Think of a chessboard. An explicit representation would list all legal board positions—an impossible task, since there are more than <span class="math inline">\(10^{40}\)</span>. An implicit representation instead encodes the rules of chess, generating moves as needed during play.</p>
</section>
<section id="deep-dive-7" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-7">Deep Dive</h4>
<p>Explicit representation works for small, finite domains. Every state is stored directly in memory, often as a graph with nodes and edges. It is useful for simple puzzles, like tic-tac-toe. Implicit representation defines states through functions and transitions. States are generated only when explored, saving memory and avoiding impossible enumeration.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 8%">
<col style="width: 25%">
<col style="width: 24%">
<col style="width: 30%">
<col style="width: 11%">
</colgroup>
<thead>
<tr class="header">
<th>Representation</th>
<th>How It Works</th>
<th>Pros</th>
<th>Cons</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Explicit</td>
<td>List every state and all transitions</td>
<td>Easy to visualize, simple implementation</td>
<td>Memory blowup, infeasible for large domains</td>
<td>Tic-tac-toe</td>
</tr>
<tr class="even">
<td>Implicit</td>
<td>Encode rules, generate successors on demand</td>
<td>Compact, scalable, handles infinite spaces</td>
<td>Requires more computation per step, harder to debug</td>
<td>Chess, Rubik’s Cube</td>
</tr>
</tbody>
</table>
<p>Most real-world problems (robotics, scheduling, planning) require implicit representation. Explicit graphs are valuable for teaching, visualization, and debugging.</p>
</section>
<section id="tiny-code-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-7">Tiny Code</h4>
<p>Explicit vs.&nbsp;implicit grid world:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Explicit: Precompute all states</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> [(x, y) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>) <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>)]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>transitions <span class="op">=</span> {s: [] <span class="cf">for</span> s <span class="kw">in</span> states}</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x, y <span class="kw">in</span> states:</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dx, dy <span class="kw">in</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>)]:</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (x<span class="op">+</span>dx, y<span class="op">+</span>dy) <span class="kw">in</span> states:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            transitions[(x,y)].append((x<span class="op">+</span>dx, y<span class="op">+</span>dy))</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Implicit: Generate on the fly</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> successors(state):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> state</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dx, dy <span class="kw">in</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>)]:</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> x<span class="op">+</span>dx <span class="op">&lt;</span> <span class="dv">3</span> <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> y<span class="op">+</span>dy <span class="op">&lt;</span> <span class="dv">3</span>:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> (x<span class="op">+</span>dx, y<span class="op">+</span>dy)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-7" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-7">Why It Matters</h4>
<p>Explicit graphs become impossible beyond toy domains. Implicit representations, by contrast, scale to real-world AI problems, from navigation to planning under uncertainty. The choice directly affects whether a problem can be solved in practice.</p>
</section>
<section id="try-it-yourself-7" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-7">Try It Yourself</h4>
<ol type="1">
<li>Represent tic-tac-toe explicitly by enumerating all states. Compare memory use to an implicit rule-based generator.</li>
<li>Implement an implicit representation of the 8-puzzle by defining a function that yields valid moves.</li>
<li>Consider representing all binary strings of length <span class="math inline">\(n\)</span>. Which approach is feasible for <span class="math inline">\(n=20\)</span>, and why?</li>
</ol>
</section>
</section>
<section id="formal-properties-completeness-optimality-complexity" class="level3">
<h3 class="anchored" data-anchor-id="formal-properties-completeness-optimality-complexity">308. Formal Properties: Completeness, Optimality, Complexity</h3>
<p>When analyzing search problems, three properties dominate: <em>completeness</em> (will the algorithm always find a solution if one exists?), <em>optimality</em> (will it find the best solution according to cost?), and <em>complexity</em> (how much time and memory does it need?). These criteria define whether a search method is practically useful.</p>
<section id="picture-in-your-head-8" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-8">Picture in Your Head</h4>
<p>Think of different strategies for finding your way out of a maze. A random walk might eventually stumble out, but it isn’t guaranteed (incomplete). Following the right-hand wall guarantees escape if the maze is simply connected (complete), but the path may be longer than necessary (not optimal). An exhaustive map search may guarantee the shortest path (optimal), but require far more time and memory (high complexity).</p>
</section>
<section id="deep-dive-8" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-8">Deep Dive</h4>
<p>Completeness ensures reliability: if a solution exists, the algorithm won’t miss it. Optimality ensures quality: the solution found is the best possible under the cost metric. Complexity ensures feasibility: the method can run within available resources. No algorithm scores perfectly on all three; trade-offs must be managed depending on the problem.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 40%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Definition</th>
<th>Example of Algorithm That Satisfies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Completeness</td>
<td>Finds a solution if one exists</td>
<td>Breadth-First Search in finite spaces</td>
</tr>
<tr class="even">
<td>Optimality</td>
<td>Always returns the lowest-cost solution</td>
<td>Uniform-Cost Search, A* (with admissible heuristic)</td>
</tr>
<tr class="odd">
<td>Time Complexity</td>
<td>Number of steps or operations vs.&nbsp;problem size</td>
<td>DFS: <span class="math inline">\(O(b^m)\)</span>, BFS: <span class="math inline">\(O(b^d)\)</span></td>
</tr>
<tr class="even">
<td>Space Complexity</td>
<td>Memory used vs.&nbsp;problem size</td>
<td>DFS: <span class="math inline">\(O(bm)\)</span>, BFS: <span class="math inline">\(O(b^d)\)</span></td>
</tr>
</tbody>
</table>
<p>Here, <span class="math inline">\(b\)</span> is branching factor, <span class="math inline">\(d\)</span> is solution depth, <span class="math inline">\(m\)</span> is maximum depth.</p>
</section>
<section id="tiny-code-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-8">Tiny Code</h4>
<p>A simple wrapper to test completeness and optimality in a grid search:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bfs(start, goal, successors):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    q, visited <span class="op">=</span> deque([(start, [])]), <span class="bu">set</span>([start])</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        state, path <span class="op">=</span> q.popleft()</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path <span class="op">+</span> [state]  <span class="co"># optimal in unit-cost graphs</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> successors(state):</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>                visited.add(nxt)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                q.append((nxt, path <span class="op">+</span> [state]))</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span>  <span class="co"># complete: returns None if no solution exists</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This BFS guarantees completeness and optimality in unweighted graphs but is expensive in memory.</p>
</section>
<section id="why-it-matters-8" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-8">Why It Matters</h4>
<p>Completeness tells us whether an algorithm can be trusted. Optimality ensures quality of outcomes. Complexity determines whether the method is usable in real-world scenarios. Understanding these trade-offs is essential for choosing or designing algorithms that balance practicality and guarantees.</p>
</section>
<section id="try-it-yourself-8" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-8">Try It Yourself</h4>
<ol type="1">
<li>Compare DFS and BFS on a small maze: which is complete, which is optimal?</li>
<li>For weighted graphs, test BFS vs.&nbsp;Uniform-Cost Search: which returns the lowest-cost path?</li>
<li>Write a table summarizing completeness, optimality, time, and space complexity for BFS, DFS, UCS, and A*.</li>
</ol>
</section>
</section>
<section id="from-real-world-tasks-to-formal-problems" class="level3">
<h3 class="anchored" data-anchor-id="from-real-world-tasks-to-formal-problems">309. From Real-World Tasks to Formal Problems</h3>
<p>AI systems begin with messy, real-world tasks: driving a car, solving a puzzle, scheduling flights. To make these tractable, we reformulate them into formal search problems with defined states, actions, transitions, and goals. The art of problem-solving lies in this translation.</p>
<section id="picture-in-your-head-9" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-9">Picture in Your Head</h4>
<p>Think of a delivery robot. The real-world task is: “Deliver this package.” Formally, this becomes:</p>
<ul>
<li>States: robot’s position and package status</li>
<li>Actions: move, pick up, drop off</li>
<li>Transitions: movement rules, pickup/dropoff rules</li>
<li>Goal: package delivered to the correct address</li>
</ul>
<p>The messy task has been distilled into a search problem.</p>
</section>
<section id="deep-dive-9" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-9">Deep Dive</h4>
<p>Formulating problems involves several steps, each introducing simplifications to make the system solvable:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 28%">
<col style="width: 49%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Real-World Example</th>
<th>Formalization</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Identify entities</td>
<td>Delivery robot, packages, map</td>
<td>Define states with robot position + package status</td>
</tr>
<tr class="even">
<td>Define possible actions</td>
<td>Move, pick up, drop off</td>
<td>Operators that update the state</td>
</tr>
<tr class="odd">
<td>Set transition rules</td>
<td>Movement only on roads</td>
<td>Transition function restricting moves</td>
</tr>
<tr class="even">
<td>State the goal</td>
<td>Package at destination</td>
<td>Goal test on state variables</td>
</tr>
</tbody>
</table>
<p>This translation is rarely perfect. Too much detail (every atom’s position) leads to intractability. Too little detail (just “package delivered”) leaves out critical constraints. The challenge is striking the right balance.</p>
</section>
<section id="tiny-code-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-9">Tiny Code</h4>
<p>Formalizing a delivery problem in code:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>State <span class="op">=</span> <span class="bu">tuple</span>  <span class="co"># (location, has_package)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> successors(state, roads, destination):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    loc, has_pkg <span class="op">=</span> state</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Move actions</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nxt <span class="kw">in</span> roads[loc]:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> (nxt, has_pkg)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pick up</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> loc <span class="op">==</span> <span class="st">"warehouse"</span> <span class="kw">and</span> <span class="kw">not</span> has_pkg:</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> (loc, <span class="va">True</span>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Drop off</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> loc <span class="op">==</span> destination <span class="kw">and</span> has_pkg:</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> (loc, <span class="va">False</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> (<span class="st">"warehouse"</span>, <span class="va">False</span>)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>goal <span class="op">=</span> (<span class="st">"customer"</span>, <span class="va">False</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-9" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-9">Why It Matters</h4>
<p>Real-world tasks are inherently ambiguous. Formalization removes ambiguity, making problems precise, analyzable, and solvable by algorithms. Good formulations bridge messy human goals and structured computational models.</p>
</section>
<section id="try-it-yourself-9" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-9">Try It Yourself</h4>
<ol type="1">
<li>Take the task “solve Sudoku.” Write down the state representation, actions, transitions, and goal test.</li>
<li>Formalize “planning a vacation itinerary” as a search problem. What would the states and goals be?</li>
<li>In Python, model the Towers of Hanoi problem with states as peg configurations and actions as legal disk moves.</li>
</ol>
</section>
</section>
<section id="case-study-formulating-search-problems-in-ai" class="level3">
<h3 class="anchored" data-anchor-id="case-study-formulating-search-problems-in-ai">310. Case Study: Formulating Search Problems in AI</h3>
<p>Case studies show how real tasks become solvable search problems. By walking through examples, we see how to define states, actions, transitions, and goals in practice. This demonstrates the generality of search as a unifying framework across domains.</p>
<section id="picture-in-your-head-10" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-10">Picture in Your Head</h4>
<p>Imagine three problems side by side: solving the 8-puzzle, routing a taxi in a city, and playing tic-tac-toe. Though they look different, each can be expressed as “start from an initial state, apply actions through transitions, and reach a goal.”</p>
</section>
<section id="deep-dive-10" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-10">Deep Dive</h4>
<p>Let’s compare three formulations directly:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 10%">
<col style="width: 28%">
<col style="width: 30%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>Task</th>
<th>States</th>
<th>Actions</th>
<th>Goal Condition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8-puzzle</td>
<td>Board configurations (3×3 grid)</td>
<td>Slide blank up/down/left/right</td>
<td>Tiles in numerical order</td>
</tr>
<tr class="even">
<td>Taxi routing</td>
<td>Car at location, passenger info</td>
<td>Drive to adjacent node, pick/drop</td>
<td>Passenger delivered to destination</td>
</tr>
<tr class="odd">
<td>Tic-tac-toe</td>
<td>Board positions with X/O/empty</td>
<td>Place symbol in empty cell</td>
<td>X or O has winning line</td>
</tr>
</tbody>
</table>
<p>Observations:</p>
<ul>
<li>The abstraction level differs. Taxi routing ignores fuel and traffic; tic-tac-toe ignores physical time to draw moves.</li>
<li>The transition model ensures only legal states are reachable.</li>
<li>The goal test captures success succinctly, even if many different states qualify.</li>
</ul>
<p>These case studies highlight the flexibility of search problem formulation: the same formal template applies across puzzles, navigation, and games.</p>
</section>
<section id="tiny-code-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-10">Tiny Code</h4>
<p>Minimal formalization for tic-tac-toe:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> successors(board, player):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, cell <span class="kw">in</span> <span class="bu">enumerate</span>(board):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cell <span class="op">==</span> <span class="st">" "</span>:</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>            new_board <span class="op">=</span> board[:i] <span class="op">+</span> player <span class="op">+</span> board[i<span class="op">+</span><span class="dv">1</span>:]</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> new_board</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_goal(board):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    wins <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>),</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            (<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">6</span>),(<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">7</span>),(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">8</span>),</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            (<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">8</span>),(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>)]</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a,b,c <span class="kw">in</span> wins:</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> board[a] <span class="op">!=</span> <span class="st">" "</span> <span class="kw">and</span> board[a] <span class="op">==</span> board[b] <span class="op">==</span> board[c]:</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here, <code>board</code> is a 9-character string, <code>"X"</code>, <code>"O"</code>, or <code>" "</code>. Successors generate valid moves; <code>is_goal</code> checks for victory.</p>
</section>
<section id="why-it-matters-10" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-10">Why It Matters</h4>
<p>Case studies show that wildly different problems reduce to the same structure. This universality is why search and planning form the backbone of AI. Once a task is formalized, we can apply general-purpose algorithms without redesigning from scratch.</p>
</section>
<section id="try-it-yourself-10" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-10">Try It Yourself</h4>
<ol type="1">
<li>Formulate the Rubik’s Cube as a search problem: what are states, actions, transitions, and goals?</li>
<li>Model a warehouse robot’s task of retrieving an item and returning it to base. Write down the problem definition.</li>
<li>Create a Python generator that yields all legal knight moves in chess from a given square.</li>
</ol>
</section>
</section>
</section>
<section id="chapter-32.-unformed-search-bfs-dfs-iterative-deepening" class="level2">
<h2 class="anchored" data-anchor-id="chapter-32.-unformed-search-bfs-dfs-iterative-deepening">Chapter 32. Unformed Search (BFS, DFS, Iterative Deepening)</h2>
<section id="concept-of-uninformed-blind-search" class="level3">
<h3 class="anchored" data-anchor-id="concept-of-uninformed-blind-search">311. Concept of Uninformed (Blind) Search</h3>
<p>Uninformed search, also called blind search, explores a problem space without any additional knowledge about the goal beyond what is provided in the problem definition. It systematically generates and examines states, but it does not use heuristics to guide the search toward promising areas. The methods rely purely on structure: what the states are, what actions are possible, and whether a goal has been reached.</p>
<section id="picture-in-your-head-11" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-11">Picture in Your Head</h4>
<p>Imagine looking for a book in a dark library without a flashlight. You start at one shelf and check every book in order, row by row. You have no idea whether the book is closer or farther away—you simply keep exploring until you stumble upon it. That’s uninformed search.</p>
</section>
<section id="deep-dive-11" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-11">Deep Dive</h4>
<p>Uninformed search algorithms differ in how they explore, but they share the property of <em>ignorance</em> about goal proximity. The only guidance comes from:</p>
<ul>
<li>Initial state: where search begins</li>
<li>Successor function: how new states are generated</li>
<li>Goal test: whether the goal has been reached</li>
</ul>
<p>Comparison of common uninformed methods:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 22%">
<col style="width: 11%">
<col style="width: 14%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Exploration Order</th>
<th>Completeness</th>
<th>Optimality</th>
<th>Time/Space Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Breadth-First</td>
<td>Expands shallowest first</td>
<td>Yes (finite)</td>
<td>Yes (unit cost)</td>
<td><span class="math inline">\(O(b^d)\)</span></td>
</tr>
<tr class="even">
<td>Depth-First</td>
<td>Expands deepest first</td>
<td>Not always</td>
<td>No</td>
<td><span class="math inline">\(O(b^m)\)</span></td>
</tr>
<tr class="odd">
<td>Uniform-Cost</td>
<td>Expands lowest path cost</td>
<td>Yes</td>
<td>Yes</td>
<td><span class="math inline">\(O(b^{1+\lfloor C^*/\epsilon \rfloor})\)</span></td>
</tr>
<tr class="even">
<td>Iterative Deep.</td>
<td>Depth limits increasing</td>
<td>Yes</td>
<td>Yes (unit cost)</td>
<td><span class="math inline">\(O(b^d)\)</span></td>
</tr>
</tbody>
</table>
<p>Here <span class="math inline">\(b\)</span> = branching factor, <span class="math inline">\(d\)</span> = depth of shallowest solution, <span class="math inline">\(m\)</span> = max depth.</p>
</section>
<section id="tiny-code-11" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-11">Tiny Code</h4>
<p>General skeleton for blind search:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bfs(start, goal, successors):</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    q, visited <span class="op">=</span> deque([(start, [])]), {start}</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        state, path <span class="op">=</span> q.popleft()</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path <span class="op">+</span> [state]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> successors(state):</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>                visited.add(nxt)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>                q.append((nxt, path <span class="op">+</span> [state]))</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This BFS explores blindly until the goal is found.</p>
</section>
<section id="why-it-matters-11" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-11">Why It Matters</h4>
<p>Uninformed search provides the foundation for more advanced methods. It is simple, systematic, and guarantees correctness in some conditions. But its inefficiency in large state spaces shows why heuristics are crucial for scaling to real-world problems.</p>
</section>
<section id="try-it-yourself-11" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-11">Try It Yourself</h4>
<ol type="1">
<li>Run BFS and DFS on a small maze and compare the order of visited states.</li>
<li>For the 8-puzzle, count the number of nodes expanded by BFS to find the shortest solution.</li>
<li>Implement Iterative Deepening Search and verify it finds optimal solutions while saving memory compared to BFS.</li>
</ol>
</section>
</section>
<section id="breadth-first-search-mechanics-and-guarantees" class="level3">
<h3 class="anchored" data-anchor-id="breadth-first-search-mechanics-and-guarantees">312. Breadth-First Search: Mechanics and Guarantees</h3>
<p>Breadth-First Search (BFS) explores a state space layer by layer, expanding all nodes at depth <span class="math inline">\(d\)</span> before moving to depth <span class="math inline">\(d+1\)</span>. It is the canonical example of an uninformed search method: systematic, complete, and—when all actions have equal cost—optimal.</p>
<section id="picture-in-your-head-12" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-12">Picture in Your Head</h4>
<p>Imagine ripples in a pond. Drop a stone, and the waves spread outward evenly. BFS explores states in the same way: starting from the initial state, it expands outward uniformly, guaranteeing the shallowest solution is found first.</p>
</section>
<section id="deep-dive-12" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-12">Deep Dive</h4>
<p>BFS works by maintaining a queue of frontier states. Each step dequeues the oldest node, expands it, and enqueues its children.</p>
<p>Key properties:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 77%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>BFS Characteristic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Completeness</td>
<td>Guaranteed if branching factor <span class="math inline">\(b\)</span> is finite</td>
</tr>
<tr class="even">
<td>Optimality</td>
<td>Guaranteed in unit-cost domains</td>
</tr>
<tr class="odd">
<td>Time Complexity</td>
<td><span class="math inline">\(O(b^d)\)</span>, where <span class="math inline">\(d\)</span> is depth of the shallowest solution</td>
</tr>
<tr class="even">
<td>Space Complexity</td>
<td><span class="math inline">\(O(b^d)\)</span>, since all frontier nodes must be stored</td>
</tr>
</tbody>
</table>
<p>The memory cost is often the limiting factor. While DFS explores deep without much memory, BFS can quickly exhaust storage even in modest problems.</p>
</section>
<section id="tiny-code-12" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-12">Tiny Code</h4>
<p>Implementation of BFS:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bfs(start, goal, successors):</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    frontier <span class="op">=</span> deque([start])</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    parents <span class="op">=</span> {start: <span class="va">None</span>}</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> frontier:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> frontier.popleft()</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># reconstruct path</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> state <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>                path.append(state)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> parents[state]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> successors(state):</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> parents:</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>                parents[nxt] <span class="op">=</span> state</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>                frontier.append(nxt)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-12" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-12">Why It Matters</h4>
<p>BFS is often the first algorithm taught in AI and graph theory because of its simplicity and strong guarantees. It is the baseline for evaluating other search strategies: complete, optimal (for equal costs), and predictable, though memory-hungry.</p>
</section>
<section id="try-it-yourself-12" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-12">Try It Yourself</h4>
<ol type="1">
<li>Use BFS to solve a 3×3 sliding puzzle from a simple scrambled configuration.</li>
<li>Apply BFS to a grid maze with obstacles and confirm it finds the shortest path.</li>
<li>Estimate how many nodes BFS would generate for a branching factor of 3 and solution depth of 12.</li>
</ol>
</section>
</section>
<section id="depth-first-search-mechanics-and-pitfalls" class="level3">
<h3 class="anchored" data-anchor-id="depth-first-search-mechanics-and-pitfalls">313. Depth-First Search: Mechanics and Pitfalls</h3>
<p>Depth-First Search (DFS) explores by going as deep as possible along one branch before backtracking. It is simple and memory-efficient, but it sacrifices completeness in infinite spaces and does not guarantee optimal solutions.</p>
<section id="picture-in-your-head-13" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-13">Picture in Your Head</h4>
<p>Imagine exploring a cave with only one flashlight. You follow one tunnel all the way until it dead-ends, then backtrack and try the next. If the cave has infinitely winding passages, you might never return to check other tunnels that actually lead to the exit.</p>
</section>
<section id="deep-dive-13" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-13">Deep Dive</h4>
<p>DFS maintains a stack (explicit or via recursion) for exploration. Each step takes the newest node and expands it.</p>
<p>Properties of DFS:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 79%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>DFS Characteristic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Completeness</td>
<td>No (fails in infinite spaces); Yes if finite and depth-limited</td>
</tr>
<tr class="even">
<td>Optimality</td>
<td>No (may find longer solution first)</td>
</tr>
<tr class="odd">
<td>Time Complexity</td>
<td><span class="math inline">\(O(b^m)\)</span>, where <span class="math inline">\(m\)</span> is maximum depth</td>
</tr>
<tr class="even">
<td>Space Complexity</td>
<td><span class="math inline">\(O(bm)\)</span>, much smaller than BFS</td>
</tr>
</tbody>
</table>
<p>DFS is attractive for memory reasons, but dangerous in domains with deep or infinite paths. A variation, <em>Depth-Limited Search</em>, imposes a maximum depth to ensure termination. Iterative Deepening combines DFS efficiency with BFS completeness.</p>
</section>
<section id="tiny-code-13" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-13">Tiny Code</h4>
<p>Recursive DFS with path reconstruction:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(state, goal, successors, visited<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> visited <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [state]</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    visited.add(state)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nxt <span class="kw">in</span> successors(state):</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> dfs(nxt, goal, successors, visited)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> path:</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> [state] <span class="op">+</span> path</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-13" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-13">Why It Matters</h4>
<p>DFS shows that not all uninformed searches are equally reliable. It demonstrates the trade-off between memory efficiency and search guarantees. Understanding its limitations is key to appreciating more robust methods like Iterative Deepening.</p>
</section>
<section id="try-it-yourself-13" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-13">Try It Yourself</h4>
<ol type="1">
<li>Run DFS on a maze with cycles. What happens if you forget to mark visited states?</li>
<li>Compare memory usage of DFS and BFS on the same tree with branching factor 3 and depth 10.</li>
<li>Modify DFS into a depth-limited version that stops at depth 5. What kinds of solutions might it miss?</li>
</ol>
</section>
</section>
<section id="uniform-cost-search-and-path-cost-functions" class="level3">
<h3 class="anchored" data-anchor-id="uniform-cost-search-and-path-cost-functions">314. Uniform-Cost Search and Path Cost Functions</h3>
<p>Uniform-Cost Search (UCS) expands the node with the lowest cumulative path cost from the start state. Unlike BFS, which assumes all steps cost the same, UCS handles varying action costs and guarantees the cheapest solution. It is essentially Dijkstra’s algorithm framed as a search procedure.</p>
<section id="picture-in-your-head-14" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-14">Picture in Your Head</h4>
<p>Imagine planning a road trip. Instead of simply counting the number of roads traveled (like BFS), you care about the total distance or fuel cost. UCS expands the cheapest partial trip first, ensuring that when you reach the destination, it’s along the least costly route.</p>
</section>
<section id="deep-dive-14" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-14">Deep Dive</h4>
<p>UCS generalizes BFS by replacing “depth” with “path cost.” Instead of a FIFO queue, it uses a priority queue ordered by cumulative cost <span class="math inline">\(g(n)\)</span>.</p>
<p>Key properties:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>UCS Characteristic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Completeness</td>
<td>Yes, if costs are nonnegative</td>
</tr>
<tr class="even">
<td>Optimality</td>
<td>Yes, returns minimum-cost solution</td>
</tr>
<tr class="odd">
<td>Time Complexity</td>
<td><span class="math inline">\(O(b^{1+\lfloor C^*/\epsilon \rfloor})\)</span>, where <span class="math inline">\(C^*\)</span> is cost of optimal solution and <span class="math inline">\(\epsilon\)</span> is minimum action cost</td>
</tr>
<tr class="even">
<td>Space Complexity</td>
<td>Proportional to number of nodes stored in priority queue</td>
</tr>
</tbody>
</table>
<p>This means UCS can explore very deeply if there are many low-cost actions. Still, it is essential when path costs vary, such as in routing or scheduling problems.</p>
</section>
<section id="tiny-code-14" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-14">Tiny Code</h4>
<p>UCS with priority queue:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ucs(start, goal, successors):</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    frontier <span class="op">=</span> [(<span class="dv">0</span>, start)]  <span class="co"># (cost, state)</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    parents <span class="op">=</span> {start: <span class="va">None</span>}</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    costs <span class="op">=</span> {start: <span class="dv">0</span>}</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> frontier:</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        cost, state <span class="op">=</span> heapq.heappop(frontier)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>            <span class="co"># reconstruct path</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> state <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>                path.append(state)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> parents[state]</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>], cost</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt, step_cost <span class="kw">in</span> successors(state):</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>            new_cost <span class="op">=</span> cost <span class="op">+</span> step_cost</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> costs <span class="kw">or</span> new_cost <span class="op">&lt;</span> costs[nxt]:</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>                costs[nxt] <span class="op">=</span> new_cost</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>                parents[nxt] <span class="op">=</span> state</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(frontier, (new_cost, nxt))</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span>, <span class="bu">float</span>(<span class="st">"inf"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here, <code>successors(state)</code> yields <code>(next_state, cost)</code> pairs.</p>
</section>
<section id="why-it-matters-14" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-14">Why It Matters</h4>
<p>Many real problems involve unequal action costs—driving longer roads, taking expensive flights, or making risky moves. UCS guarantees the cheapest valid solution, providing a foundation for algorithms like A* that extend it with heuristics.</p>
</section>
<section id="try-it-yourself-14" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-14">Try It Yourself</h4>
<ol type="1">
<li>Use UCS to find the cheapest path in a weighted graph with varying edge costs.</li>
<li>Compare BFS and UCS on a graph where some edges have cost 10 and others cost 1. What differences emerge?</li>
<li>Implement a delivery problem where roads have distances and confirm UCS finds the shortest total distance.</li>
</ol>
</section>
</section>
<section id="depth-limited-and-iterative-deepening-dfs" class="level3">
<h3 class="anchored" data-anchor-id="depth-limited-and-iterative-deepening-dfs">315. Depth-Limited and Iterative Deepening DFS</h3>
<p>Depth-Limited Search (DLS) is a variant of DFS that halts exploration beyond a fixed depth limit <span class="math inline">\(L\)</span>. Iterative Deepening Depth-First Search (IDDFS) combines DLS with repetition: it runs DLS with limits <span class="math inline">\(1, 2, 3, …\)</span> until the goal is found. This balances the memory efficiency of DFS with the completeness and optimality of BFS.</p>
<section id="picture-in-your-head-15" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-15">Picture in Your Head</h4>
<p>Think of searching for a lost key in a building. With DLS, you say: “I’ll only check up to the 3rd floor.” With IDDFS, you first check 1 floor, then 2, then 3, and so on, ensuring you’ll eventually find the key on the shallowest floor while not missing deeper floors entirely.</p>
</section>
<section id="deep-dive-15" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-15">Deep Dive</h4>
<ul>
<li>DLS: Prevents infinite descent in graphs with cycles or infinite depth. But if the solution lies deeper than <span class="math inline">\(L\)</span>, it will be missed.</li>
<li>IDDFS: Repeatedly increases <span class="math inline">\(L\)</span>. Though it revisits states, the overhead is acceptable because most search cost lies at the deepest level.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 10%">
<col style="width: 36%">
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Completeness</th>
<th>Optimality</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DLS</td>
<td>No (if solution deeper than <span class="math inline">\(L\)</span>)</td>
<td>No</td>
<td><span class="math inline">\(O(b^L)\)</span></td>
<td><span class="math inline">\(O(bL)\)</span></td>
</tr>
<tr class="even">
<td>IDDFS</td>
<td>Yes</td>
<td>Yes (unit-cost)</td>
<td><span class="math inline">\(O(b^d)\)</span></td>
<td><span class="math inline">\(O(bd)\)</span></td>
</tr>
</tbody>
</table>
<p>Here <span class="math inline">\(b\)</span> = branching factor, <span class="math inline">\(d\)</span> = solution depth, <span class="math inline">\(L\)</span> = depth limit.</p>
</section>
<section id="tiny-code-15" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-15">Tiny Code</h4>
<p>Depth-Limited Search with Iterative Deepening:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dls(state, goal, successors, limit):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [state]</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> limit <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nxt <span class="kw">in</span> successors(state):</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        path <span class="op">=</span> dls(nxt, goal, successors, limit<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> path:</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> [state] <span class="op">+</span> path</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iddfs(start, goal, successors, max_depth<span class="op">=</span><span class="dv">50</span>):</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> limit <span class="kw">in</span> <span class="bu">range</span>(max_depth<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        path <span class="op">=</span> dls(start, goal, successors, limit)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> path:</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-15" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-15">Why It Matters</h4>
<p>DLS introduces a safeguard against infinite paths, while IDDFS offers a near-perfect compromise: low memory like DFS, guaranteed completeness, and optimality like BFS (for unit-cost problems). This makes IDDFS a practical baseline for uninformed search.</p>
</section>
<section id="try-it-yourself-15" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-15">Try It Yourself</h4>
<ol type="1">
<li>Use DLS on a maze and test with different depth limits. At what <span class="math inline">\(L\)</span> does it first succeed?</li>
<li>Compare memory usage of IDDFS vs.&nbsp;BFS on a tree of depth 10 and branching factor 3.</li>
<li>Prove to yourself why re-expansion overhead in IDDFS is negligible compared to the cost of exploring the deepest level.</li>
</ol>
</section>
</section>
<section id="time-and-space-complexity-of-blind-search-methods" class="level3">
<h3 class="anchored" data-anchor-id="time-and-space-complexity-of-blind-search-methods">316. Time and Space Complexity of Blind Search Methods</h3>
<p>Blind search algorithms—BFS, DFS, UCS, IDDFS—can be compared by their time and space demands. Complexity depends on three parameters: branching factor (<span class="math inline">\(b\)</span>), depth of the shallowest solution (<span class="math inline">\(d\)</span>), and maximum search depth (<span class="math inline">\(m\)</span>). Understanding these trade-offs guides algorithm selection.</p>
<section id="picture-in-your-head-16" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-16">Picture in Your Head</h4>
<p>Visualize a tree where each node has <span class="math inline">\(b\)</span> children. As you descend levels, the number of nodes explodes exponentially: level 0 has 1 node, level 1 has <span class="math inline">\(b\)</span>, level 2 has <span class="math inline">\(b^2\)</span>, and so on. This growth pattern dominates the time and memory cost of search.</p>
</section>
<section id="deep-dive-16" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-16">Deep Dive</h4>
<p>For each algorithm, we measure:</p>
<ul>
<li>Time complexity: number of nodes generated.</li>
<li>Space complexity: number of nodes stored simultaneously.</li>
<li>Completeness/Optimality: whether a solution is guaranteed and whether it is the best one.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 8%">
<col style="width: 37%">
<col style="width: 20%">
<col style="width: 19%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th>Complete?</th>
<th>Optimal?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BFS</td>
<td><span class="math inline">\(O(b^d)\)</span></td>
<td><span class="math inline">\(O(b^d)\)</span></td>
<td>Yes</td>
<td>Yes (unit-cost)</td>
</tr>
<tr class="even">
<td>DFS</td>
<td><span class="math inline">\(O(b^m)\)</span></td>
<td><span class="math inline">\(O(bm)\)</span></td>
<td>No (infinite spaces)</td>
<td>No</td>
</tr>
<tr class="odd">
<td>DLS</td>
<td><span class="math inline">\(O(b^L)\)</span></td>
<td><span class="math inline">\(O(bL)\)</span></td>
<td>No (if <span class="math inline">\(L &lt; d\)</span>)</td>
<td>No</td>
</tr>
<tr class="even">
<td>IDDFS</td>
<td><span class="math inline">\(O(b^d)\)</span></td>
<td><span class="math inline">\(O(bd)\)</span></td>
<td>Yes</td>
<td>Yes (unit-cost)</td>
</tr>
<tr class="odd">
<td>UCS</td>
<td><span class="math inline">\(O(b^{1+\lfloor C^*/\epsilon \rfloor})\)</span></td>
<td>Large (priority queue)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>Where:</p>
<ul>
<li><span class="math inline">\(b\)</span>: branching factor</li>
<li><span class="math inline">\(d\)</span>: solution depth</li>
<li><span class="math inline">\(m\)</span>: max depth</li>
<li><span class="math inline">\(C^*\)</span>: optimal solution cost</li>
<li><span class="math inline">\(\epsilon\)</span>: minimum edge cost</li>
</ul>
<p>Observation: BFS explodes in memory, DFS is frugal but risky, UCS grows heavy under uneven costs, and IDDFS strikes a balance.</p>
</section>
<section id="tiny-code-16" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-16">Tiny Code</h4>
<p>Estimate complexity by node counting:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> estimate_nodes(branching_factor, depth):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(branching_factori <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(depth<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"BFS nodes (b=3, d=5):"</span>, estimate_nodes(<span class="dv">3</span>, <span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This shows the exponential blow-up at deeper levels.</p>
</section>
<section id="why-it-matters-16" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-16">Why It Matters</h4>
<p>Complexity analysis reveals which algorithms scale and which collapse. In practice, the exponential explosion makes uninformed search impractical for large problems. Still, knowing these trade-offs is vital for algorithm choice and for motivating heuristics.</p>
</section>
<section id="try-it-yourself-16" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-16">Try It Yourself</h4>
<ol type="1">
<li>Calculate how many nodes BFS explores when <span class="math inline">\(b=2\)</span>, <span class="math inline">\(d=12\)</span>. Compare with DFS at <span class="math inline">\(m=20\)</span>.</li>
<li>Implement IDDFS and log how many times nodes at each depth are re-expanded.</li>
<li>Analyze how UCS behaves when some edges have very small costs. What happens to the frontier size?</li>
</ol>
</section>
</section>
<section id="completeness-and-optimality-trade-offs" class="level3">
<h3 class="anchored" data-anchor-id="completeness-and-optimality-trade-offs">317. Completeness and Optimality Trade-offs</h3>
<p>Search algorithms often trade completeness (guaranteeing a solution if one exists) against optimality (guaranteeing the best solution). Rarely can both be achieved without cost in time or space. Choosing an algorithm means deciding which property matters most for the task at hand.</p>
<section id="picture-in-your-head-17" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-17">Picture in Your Head</h4>
<p>Imagine searching for a restaurant. One strategy: walk down every street until you eventually find one—complete, but not optimal. Another: only go to the first one you see—fast, but possibly not the best. A third: look at a map and carefully compare all routes—optimal, but time-consuming.</p>
</section>
<section id="deep-dive-17" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-17">Deep Dive</h4>
<p>Different uninformed algorithms illustrate the trade-offs:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 20%">
<col style="width: 18%">
<col style="width: 23%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Completeness</th>
<th>Optimality</th>
<th>Strength</th>
<th>Weakness</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BFS</td>
<td>Yes (finite spaces)</td>
<td>Yes (unit cost)</td>
<td>Simple, reliable</td>
<td>Memory blow-up</td>
</tr>
<tr class="even">
<td>DFS</td>
<td>No (infinite spaces)</td>
<td>No</td>
<td>Low memory</td>
<td>May never find solution</td>
</tr>
<tr class="odd">
<td>UCS</td>
<td>Yes</td>
<td>Yes (cost-optimal)</td>
<td>Handles weighted graphs</td>
<td>Can be slow/space-intensive</td>
</tr>
<tr class="even">
<td>IDDFS</td>
<td>Yes</td>
<td>Yes (unit cost)</td>
<td>Balanced</td>
<td>Repeated work</td>
</tr>
</tbody>
</table>
<p>Insights:</p>
<ul>
<li>Completeness without optimality: DFS may find <em>a</em> solution quickly but not the shortest.</li>
<li>Optimality without feasibility: UCS ensures the cheapest path but may exhaust memory.</li>
<li>Balanced compromises: IDDFS balances memory efficiency with guarantees for unit-cost domains.</li>
</ul>
<p>This spectrum shows why no algorithm is “best” universally—problem requirements dictate the right trade-off.</p>
</section>
<section id="tiny-code-17" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-17">Tiny Code</h4>
<p>Comparing BFS vs.&nbsp;DFS on the same graph:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compare(start, goal, successors):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># BFS</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    bfs_q, bfs_visited <span class="op">=</span> deque([(start, [])]), {start}</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> bfs_q:</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        s, path <span class="op">=</span> bfs_q.popleft()</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s <span class="op">==</span> goal:</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>            bfs_path <span class="op">=</span> path <span class="op">+</span> [s]</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> successors(s):</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> bfs_visited:</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>                bfs_visited.add(nxt)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>                bfs_q.append((nxt, path<span class="op">+</span>[s]))</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># DFS</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    stack, dfs_visited <span class="op">=</span> [(start, [])], <span class="bu">set</span>()</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    dfs_path <span class="op">=</span> <span class="va">None</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> stack:</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>        s, path <span class="op">=</span> stack.pop()</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s <span class="op">==</span> goal:</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>            dfs_path <span class="op">=</span> path <span class="op">+</span> [s]</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>        dfs_visited.add(s)</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> successors(s):</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> dfs_visited:</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>                stack.append((nxt, path<span class="op">+</span>[s]))</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> bfs_path, dfs_path</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-17" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-17">Why It Matters</h4>
<p>Completeness and optimality define the reliability and quality of solutions. Understanding where each algorithm sits on the trade-off curve is essential for making informed choices in practical AI systems.</p>
</section>
<section id="try-it-yourself-17" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-17">Try It Yourself</h4>
<ol type="1">
<li>Construct a weighted graph where DFS finds a suboptimal path while UCS finds the cheapest.</li>
<li>Run IDDFS on a puzzle and confirm it finds the shallowest solution, unlike DFS.</li>
<li>Analyze a domain (like pathfinding in maps): is completeness or optimality more critical? Why?</li>
</ol>
</section>
</section>
<section id="comparative-analysis-of-bfs-dfs-ucs-and-iddfs" class="level3">
<h3 class="anchored" data-anchor-id="comparative-analysis-of-bfs-dfs-ucs-and-iddfs">318. Comparative Analysis of BFS, DFS, UCS, and IDDFS</h3>
<p>Different uninformed search strategies solve problems with distinct strengths and weaknesses. Comparing them side by side highlights their practical trade-offs in terms of completeness, optimality, time, and space. This comparison is the foundation for deciding which algorithm fits a given problem.</p>
<section id="picture-in-your-head-18" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-18">Picture in Your Head</h4>
<p>Think of four friends exploring a forest:</p>
<ul>
<li>BFS walks outward in circles, guaranteeing the shortest route but carrying a huge backpack (memory).</li>
<li>DFS charges down one trail, light on supplies, but risks getting lost forever.</li>
<li>UCS carefully calculates the cost of every step, always choosing the cheapest route.</li>
<li>IDDFS mixes patience and strategy: it searches a little deeper each time, eventually finding the shortest path without carrying too much.</li>
</ul>
</section>
<section id="deep-dive-18" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-18">Deep Dive</h4>
<p>The algorithms can be summarized as follows:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 14%">
<col style="width: 13%">
<col style="width: 28%">
<col style="width: 15%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Completeness</th>
<th>Optimality</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BFS</td>
<td>Yes (finite spaces)</td>
<td>Yes (unit-cost)</td>
<td><span class="math inline">\(O(b^d)\)</span></td>
<td><span class="math inline">\(O(b^d)\)</span></td>
<td>Explodes in memory quickly</td>
</tr>
<tr class="even">
<td>DFS</td>
<td>No (infinite spaces)</td>
<td>No</td>
<td><span class="math inline">\(O(b^m)\)</span></td>
<td><span class="math inline">\(O(bm)\)</span></td>
<td>Very memory efficient</td>
</tr>
<tr class="odd">
<td>UCS</td>
<td>Yes (positive costs)</td>
<td>Yes (cost-optimal)</td>
<td><span class="math inline">\(O(b^{1+\lfloor C^*/\epsilon \rfloor})\)</span></td>
<td>High (priority queue)</td>
<td>Expands cheapest nodes first</td>
</tr>
<tr class="even">
<td>IDDFS</td>
<td>Yes</td>
<td>Yes (unit-cost)</td>
<td><span class="math inline">\(O(b^d)\)</span></td>
<td><span class="math inline">\(O(bd)\)</span></td>
<td>Balanced; re-expands nodes</td>
</tr>
</tbody>
</table>
<p>Here, <span class="math inline">\(b\)</span> = branching factor, <span class="math inline">\(d\)</span> = shallowest solution depth, <span class="math inline">\(m\)</span> = maximum depth, <span class="math inline">\(C^*\)</span> = optimal solution cost, <span class="math inline">\(\epsilon\)</span> = minimum action cost.</p>
<p>Key insights:</p>
<ul>
<li>BFS is reliable but memory-heavy.</li>
<li>DFS is efficient in memory but risky.</li>
<li>UCS is essential when edge costs vary.</li>
<li>IDDFS offers a near-ideal balance for unit-cost problems.</li>
</ul>
</section>
<section id="tiny-code-18" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-18">Tiny Code</h4>
<p>Skeleton for benchmarking algorithms:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> benchmark(algorithms, start, goal, successors):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> {}</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name, alg <span class="kw">in</span> algorithms.items():</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        path <span class="op">=</span> alg(start, goal, successors)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        results[name] <span class="op">=</span> <span class="bu">len</span>(path) <span class="cf">if</span> path <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Example use:</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co"># algorithms = {"BFS": bfs, "DFS": dfs, "IDDFS": iddfs, "UCS": lambda s,g,succ: ucs(s,g,succ)[0]}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This lets you compare solution lengths and performance side by side.</p>
</section>
<section id="why-it-matters-18" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-18">Why It Matters</h4>
<p>Comparative analysis clarifies when to use each algorithm. For small problems, BFS suffices; for memory-limited domains, DFS or IDDFS shines; for weighted domains, UCS is indispensable. Recognizing these trade-offs ensures algorithms are applied effectively.</p>
</section>
<section id="try-it-yourself-18" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-18">Try It Yourself</h4>
<ol type="1">
<li>Build a graph with unit costs and test BFS, DFS, and IDDFS. Compare solution depth.</li>
<li>Create a weighted graph with costs 1–10. Run UCS and show it outperforms BFS.</li>
<li>Measure memory usage of BFS vs.&nbsp;IDDFS at increasing depths. Which scales better?</li>
</ol>
</section>
</section>
<section id="applications-of-uninformed-search-in-practice" class="level3">
<h3 class="anchored" data-anchor-id="applications-of-uninformed-search-in-practice">319. Applications of Uninformed Search in Practice</h3>
<p>Uninformed search algorithms are often considered academic, but they underpin real applications where structure is simple, costs are uniform, or heuristics are unavailable. They serve as baselines, debugging tools, and sometimes practical solutions in constrained environments.</p>
<section id="picture-in-your-head-19" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-19">Picture in Your Head</h4>
<p>Imagine a robot in a factory maze with no map. It blindly tries every corridor systematically (BFS) or probes deeply into one direction (DFS) until it finds the exit. Even without “smarts,” persistence alone can solve the task.</p>
</section>
<section id="deep-dive-19" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-19">Deep Dive</h4>
<p>Uninformed search appears in many domains:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 41%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Use of Uninformed Search</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Puzzle solving</td>
<td>Explore all configurations systematically</td>
<td>8-puzzle, Towers of Hanoi</td>
</tr>
<tr class="even">
<td>Robotics</td>
<td>Mapless navigation in structured spaces</td>
<td>Cleaning robot exploring corridors</td>
</tr>
<tr class="odd">
<td>Verification</td>
<td>Model checking of finite-state systems</td>
<td>Ensuring software never reaches unsafe state</td>
</tr>
<tr class="even">
<td>Networking</td>
<td>Path discovery in unweighted graphs</td>
<td>Flooding algorithms</td>
</tr>
<tr class="odd">
<td>Education</td>
<td>Teaching baselines for AI</td>
<td>Compare to heuristics and advanced planners</td>
</tr>
</tbody>
</table>
<p>Key insight: while not scalable to massive problems, uninformed search gives guarantees where heuristic design is hard or impossible. It also exposes the boundaries of brute-force exploration.</p>
</section>
<section id="tiny-code-19" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-19">Tiny Code</h4>
<p>Simple robot exploration using BFS:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> explore(start, is_goal, successors):</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    q, visited <span class="op">=</span> deque([start]), {start}</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> q.popleft()</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_goal(state):</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> state</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> successors(state):</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>                visited.add(nxt)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>                q.append(nxt)</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This structure can solve mazes, verify finite automata, or explore puzzles.</p>
</section>
<section id="why-it-matters-19" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-19">Why It Matters</h4>
<p>Uninformed search shows that even “dumb” strategies have practical value. They ensure correctness, provide optimality under certain conditions, and establish a performance baseline for smarter algorithms. Many real-world systems start with uninformed search before adding heuristics.</p>
</section>
<section id="try-it-yourself-19" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-19">Try It Yourself</h4>
<ol type="1">
<li>Implement BFS to solve the Towers of Hanoi for 3 disks. How many states are generated?</li>
<li>Use DFS to search a file system directory tree. What risks appear if cycles (symlinks) exist?</li>
<li>In a simple graph with equal edge weights, test BFS against UCS. Do they behave differently?</li>
</ol>
</section>
</section>
<section id="worked-example-maze-solving-with-uninformed-methods" class="level3">
<h3 class="anchored" data-anchor-id="worked-example-maze-solving-with-uninformed-methods">320. Worked Example: Maze Solving with Uninformed Methods</h3>
<p>Mazes are a classic testbed for uninformed search. They provide a clear state space (grid positions), simple transitions (moves up, down, left, right), and a goal (exit). Applying BFS, DFS, UCS, and IDDFS to the same maze highlights their contrasting behaviors in practice.</p>
<section id="picture-in-your-head-20" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-20">Picture in Your Head</h4>
<p>Picture a square maze drawn on graph paper. Each cell is either open or blocked. Starting at the entrance, BFS explores outward evenly, DFS dives deep into corridors, UCS accounts for weighted paths (like muddy vs.&nbsp;dry tiles), and IDDFS steadily deepens until it finds the exit.</p>
</section>
<section id="deep-dive-20" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-20">Deep Dive</h4>
<p>Formulation of the maze problem:</p>
<ul>
<li>States: grid coordinates <span class="math inline">\((x,y)\)</span>.</li>
<li>Actions: move to an adjacent open cell.</li>
<li>Transition model: valid moves respect maze walls.</li>
<li>Goal: reach the designated exit cell.</li>
</ul>
<p>Comparison of methods on the same maze:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 25%">
<col style="width: 33%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Exploration Style</th>
<th>Guarantees</th>
<th>Typical Behavior</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BFS</td>
<td>Expands layer by layer</td>
<td>Complete, optimal (unit-cost)</td>
<td>Finds shortest path but stores many nodes</td>
</tr>
<tr class="even">
<td>DFS</td>
<td>Goes deep first</td>
<td>Incomplete (infinite spaces), not optimal</td>
<td>Can get lost in dead-ends</td>
</tr>
<tr class="odd">
<td>UCS</td>
<td>Expands lowest cumulative cost</td>
<td>Complete, optimal</td>
<td>Handles weighted tiles, but queue grows large</td>
</tr>
<tr class="even">
<td>IDDFS</td>
<td>Repeated DFS with deeper limits</td>
<td>Complete, optimal (unit-cost)</td>
<td>Re-explores nodes but uses little memory</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-20" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-20">Tiny Code</h4>
<p>Maze setup and BFS solution:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>maze <span class="op">=</span> [</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"S..#"</span>,</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">".##."</span>,</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"...E"</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> (<span class="dv">0</span>,<span class="dv">0</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>goal <span class="op">=</span> (<span class="dv">2</span>,<span class="dv">3</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> successors(state):</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> state</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dx, dy <span class="kw">in</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>)]:</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        nx, ny <span class="op">=</span> x<span class="op">+</span>dx, y<span class="op">+</span>dy</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nx <span class="op">&lt;</span> <span class="bu">len</span>(maze) <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> ny <span class="op">&lt;</span> <span class="bu">len</span>(maze[<span class="dv">0</span>]):</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> maze[nx][ny] <span class="op">!=</span> <span class="st">"#"</span>:</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">yield</span> (nx, ny)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bfs(start, goal):</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    q, parents <span class="op">=</span> deque([start]), {start: <span class="va">None</span>}</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> q.popleft()</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s <span class="op">==</span> goal:</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> s <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>                path.append(s)</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>                s <span class="op">=</span> parents[s]</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> successors(s):</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> parents:</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>                parents[nxt] <span class="op">=</span> s</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>                q.append(nxt)</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(bfs(start, goal))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-20" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-20">Why It Matters</h4>
<p>Mazes demonstrate in concrete terms how search algorithms differ. BFS guarantees the shortest path but may use a lot of memory. DFS uses almost no memory but risks missing the goal. UCS extends BFS to handle varying costs. IDDFS balances memory and completeness. These trade-offs generalize beyond mazes into real-world planning and navigation.</p>
</section>
<section id="try-it-yourself-20" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-20">Try It Yourself</h4>
<ol type="1">
<li>Modify the maze so that some cells have higher traversal costs. Compare BFS vs.&nbsp;UCS.</li>
<li>Implement DFS on the same maze. Which path does it find first?</li>
<li>Run IDDFS on the maze and measure how many times the shallow nodes are re-expanded.</li>
</ol>
</section>
</section>
</section>
<section id="chapter-33.-informed-search-heuristics-a" class="level2">
<h2 class="anchored" data-anchor-id="chapter-33.-informed-search-heuristics-a">Chapter 33. Informed Search (Heuristics, A*)</h2>
<section id="the-role-of-heuristics-in-guiding-search" class="level3">
<h3 class="anchored" data-anchor-id="the-role-of-heuristics-in-guiding-search">321. The Role of Heuristics in Guiding Search</h3>
<p>Heuristics are strategies that estimate how close a state is to a goal. In search, they act as “rules of thumb” that guide algorithms to promising areas of the state space. Unlike uninformed methods, which expand blindly, heuristic search leverages domain knowledge to prioritize paths that are more likely to succeed quickly.</p>
<section id="picture-in-your-head-21" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-21">Picture in Your Head</h4>
<p>Think of hiking toward a mountain peak. Without a map, you could wander randomly (uninformed search). With a compass pointing toward the peak, you have a heuristic: “move uphill in the general direction of the summit.” It doesn’t guarantee the shortest path, but it avoids wasting time in valleys that lead nowhere.</p>
</section>
<section id="deep-dive-21" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-21">Deep Dive</h4>
<p>Heuristics fundamentally change how search proceeds:</p>
<ul>
<li>Definition: A heuristic function <span class="math inline">\(h(n)\)</span> estimates the cost from state <span class="math inline">\(n\)</span> to the goal.</li>
<li>Use in search: Nodes with lower <span class="math inline">\(h(n)\)</span> values are explored first.</li>
<li>Accuracy trade-off: Good heuristics reduce search drastically; poor ones can mislead.</li>
<li>Source of heuristics: Often derived from problem relaxations, abstractions, or learned from data.</li>
</ul>
<p>Comparison of search with and without heuristics:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 18%">
<col style="width: 30%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Knowledge Used</th>
<th>Node Expansion Pattern</th>
<th>Efficiency</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BFS / UCS</td>
<td>No heuristic</td>
<td>Systematic (depth or cost)</td>
<td>Explores broadly</td>
</tr>
<tr class="even">
<td>Greedy / A*</td>
<td>Heuristic <span class="math inline">\(h(n)\)</span></td>
<td>Guided toward goal</td>
<td>Much faster if heuristic is good</td>
</tr>
</tbody>
</table>
<p>Heuristics don’t need to be perfect—they only need to bias search in a helpful direction. Their quality can be measured in terms of <em>admissibility</em> (never overestimates) and <em>consistency</em> (triangle inequality).</p>
</section>
<section id="tiny-code-21" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-21">Tiny Code</h4>
<p>A heuristic-driven search skeleton:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> greedy_search(start, goal, successors, heuristic):</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    frontier <span class="op">=</span> [(heuristic(start), start)]</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    parents <span class="op">=</span> {start: <span class="va">None</span>}</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> frontier:</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>        _, state <span class="op">=</span> heapq.heappop(frontier)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> state <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>                path.append(state)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> parents[state]</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> successors(state):</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> parents:</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>                parents[nxt] <span class="op">=</span> state</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(frontier, (heuristic(nxt), nxt))</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here the heuristic biases search toward states that “look” closer to the goal.</p>
</section>
<section id="why-it-matters-21" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-21">Why It Matters</h4>
<p>Heuristics transform brute-force search into practical problem solving. They make algorithms scalable by cutting down explored states. Modern AI systems—from GPS routing to game-playing agents—depend heavily on well-designed heuristics.</p>
</section>
<section id="try-it-yourself-21" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-21">Try It Yourself</h4>
<ol type="1">
<li>For the 8-puzzle, define two heuristics: (a) number of misplaced tiles, (b) Manhattan distance. Compare their effectiveness.</li>
<li>Implement greedy search on a grid maze with a heuristic = straight-line distance to the goal.</li>
<li>Think about domains like Sudoku or chess: what heuristics might you use to guide search?</li>
</ol>
</section>
</section>
<section id="designing-admissible-and-consistent-heuristics" class="level3">
<h3 class="anchored" data-anchor-id="designing-admissible-and-consistent-heuristics">322. Designing Admissible and Consistent Heuristics</h3>
<p>A heuristic is admissible if it never overestimates the true cost to reach the goal, and consistent (or monotonic) if it respects the triangle inequality: the estimated cost from one state to the goal is always less than or equal to the step cost plus the estimated cost from the successor. These properties ensure that algorithms like A* remain both complete and optimal.</p>
<section id="picture-in-your-head-22" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-22">Picture in Your Head</h4>
<p>Imagine driving with a GPS that estimates remaining distance. If it always tells you a number less than or equal to the actual miles left, it’s admissible. If, every time you pass through an intermediate city, the GPS updates smoothly without sudden contradictions, it’s consistent.</p>
</section>
<section id="deep-dive-22" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-22">Deep Dive</h4>
<p>Admissibility and consistency are cornerstones of heuristic design:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 53%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Formal Definition</th>
<th>Consequence</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Admissible</td>
<td><span class="math inline">\(h(n) \leq h^*(n)\)</span>, where <span class="math inline">\(h^*(n)\)</span> is true cost</td>
<td>Guarantees optimality in A*</td>
</tr>
<tr class="even">
<td>Consistent</td>
<td><span class="math inline">\(h(n) \leq c(n,a,n') + h(n')\)</span> for every edge</td>
<td>Ensures A* never reopens nodes</td>
</tr>
</tbody>
</table>
<ul>
<li>Admissibility is about accuracy—never being too optimistic.</li>
<li>Consistency is about stability—ensuring the heuristic doesn’t “jump” and mislead the search.</li>
<li>All consistent heuristics are admissible, but not all admissible heuristics are consistent.</li>
</ul>
<p>Examples in practice:</p>
<ul>
<li>In the 8-puzzle, Manhattan distance is both admissible and consistent.</li>
<li>Number of misplaced tiles is admissible but weaker (less informative).</li>
<li>A heuristic that always returns 0 is trivially admissible but useless.</li>
</ul>
</section>
<section id="tiny-code-22" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-22">Tiny Code</h4>
<p>Manhattan distance heuristic for the 8-puzzle:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> manhattan_distance(state, goal):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> value <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">9</span>):  <span class="co"># tiles 1–8</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> <span class="bu">divmod</span>(state.index(value), <span class="dv">3</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        x2, y2 <span class="op">=</span> <span class="bu">divmod</span>(goal.index(value), <span class="dv">3</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        dist <span class="op">+=</span> <span class="bu">abs</span>(x1 <span class="op">-</span> x2) <span class="op">+</span> <span class="bu">abs</span>(y1 <span class="op">-</span> y2)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This heuristic never overestimates the true moves needed, so it is admissible and consistent.</p>
</section>
<section id="why-it-matters-22" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-22">Why It Matters</h4>
<p>Admissible and consistent heuristics make A* powerful: efficient, complete, and optimal. Poor heuristics may still work but can cause inefficiency or even break guarantees. Designing heuristics carefully is what bridges the gap between theory and practical search.</p>
</section>
<section id="try-it-yourself-22" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-22">Try It Yourself</h4>
<ol type="1">
<li>Prove that Manhattan distance in the 8-puzzle is admissible. Can you also prove it is consistent?</li>
<li>Design a heuristic for the Towers of Hanoi: what admissible estimate could guide search?</li>
<li>Experiment with a non-admissible heuristic (e.g., Manhattan distance × 2). What happens to A*’s optimality?</li>
</ol>
</section>
</section>
<section id="greedy-best-first-search-advantages-and-risks" class="level3">
<h3 class="anchored" data-anchor-id="greedy-best-first-search-advantages-and-risks">323. Greedy Best-First Search: Advantages and Risks</h3>
<p>Greedy Best-First Search expands the node that appears closest to the goal according to a heuristic <span class="math inline">\(h(n)\)</span>. It ignores the path cost already accumulated, focusing only on estimated distance to the goal. This makes it fast in many cases but unreliable in terms of optimality and sometimes completeness.</p>
<section id="picture-in-your-head-23" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-23">Picture in Your Head</h4>
<p>Imagine following a shining beacon on the horizon. You always walk toward the brightest light, assuming it’s the shortest way. Sometimes it leads directly to the goal. Other times, you discover cliffs, rivers, or dead ends that force you to backtrack—because the beacon didn’t account for obstacles.</p>
</section>
<section id="deep-dive-23" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-23">Deep Dive</h4>
<p>Mechanics:</p>
<ul>
<li>Priority queue ordered by <span class="math inline">\(h(n)\)</span> only.</li>
<li>No guarantee of shortest path, since it ignores actual path cost <span class="math inline">\(g(n)\)</span>.</li>
<li>May get stuck in loops without cycle-checking.</li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Property</th>
<th>Characteristic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Completeness</td>
<td>No (unless finite space + cycle checks)</td>
</tr>
<tr class="even">
<td>Optimality</td>
<td>No</td>
</tr>
<tr class="odd">
<td>Time Complexity</td>
<td>Highly variable, depends on heuristic accuracy</td>
</tr>
<tr class="even">
<td>Space Complexity</td>
<td>Can be large (similar to BFS)</td>
</tr>
</tbody>
</table>
<p>Advantages:</p>
<ul>
<li>Fast when heuristics are good.</li>
<li>Easy to implement.</li>
<li>Works well in domains where goal proximity strongly correlates with heuristic.</li>
</ul>
<p>Risks:</p>
<ul>
<li>May expand many irrelevant nodes if heuristic is misleading.</li>
<li>Can oscillate between states if heuristic is poorly designed.</li>
<li>Not suitable when optimality is required.</li>
</ul>
</section>
<section id="tiny-code-23" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-23">Tiny Code</h4>
<p>Greedy Best-First Search implementation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> greedy_best_first(start, goal, successors, heuristic):</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    frontier <span class="op">=</span> [(heuristic(start), start)]</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    parents <span class="op">=</span> {start: <span class="va">None</span>}</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> frontier:</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        _, state <span class="op">=</span> heapq.heappop(frontier)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># reconstruct path</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> state <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>                path.append(state)</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> parents[state]</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> successors(state):</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> parents:</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>                parents[nxt] <span class="op">=</span> state</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(frontier, (heuristic(nxt), nxt))</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-23" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-23">Why It Matters</h4>
<p>Greedy Best-First is the foundation of more powerful methods like A*. It demonstrates how heuristics can speed up search, but also how ignoring cost information can cause failure. Understanding its strengths and weaknesses motivates the need for algorithms that balance both <span class="math inline">\(g(n)\)</span> and <span class="math inline">\(h(n)\)</span>.</p>
</section>
<section id="try-it-yourself-23" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-23">Try It Yourself</h4>
<ol type="1">
<li>Run Greedy Best-First on a weighted maze using straight-line distance as heuristic. Does it always find the shortest path?</li>
<li>Construct a problem where the heuristic misleads Greedy Search into a dead-end. How does it behave?</li>
<li>Compare the performance of BFS, UCS, and Greedy Best-First on the same grid. Which explores fewer nodes?</li>
</ol>
</section>
</section>
<section id="a-search-algorithm-intuition-and-properties" class="level3">
<h3 class="anchored" data-anchor-id="a-search-algorithm-intuition-and-properties">324. A* Search: Algorithm, Intuition, and Properties</h3>
<p>A* search balances the actual path cost so far (<span class="math inline">\(g(n)\)</span>) with the heuristic estimate to the goal (<span class="math inline">\(h(n)\)</span>). By minimizing the combined function</p>
<p><span class="math display">\[
f(n) = g(n) + h(n),
\]</span></p>
<p>A* searches efficiently while guaranteeing optimal solutions if <span class="math inline">\(h(n)\)</span> is admissible (never overestimates).</p>
<section id="picture-in-your-head-24" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-24">Picture in Your Head</h4>
<p>Imagine navigating a city with both a pedometer (tracking how far you’ve already walked) and a GPS arrow pointing to the destination. A* combines both pieces of information: it prefers routes that are short so far <em>and</em> appear promising for reaching the goal.</p>
</section>
<section id="deep-dive-24" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-24">Deep Dive</h4>
<p>Key mechanics:</p>
<ul>
<li>Maintains a priority queue ordered by <span class="math inline">\(f(n)\)</span>.</li>
<li>Expands the node with the lowest <span class="math inline">\(f(n)\)</span>.</li>
<li>Uses <span class="math inline">\(g(n)\)</span> to track cost accumulated so far and <span class="math inline">\(h(n)\)</span> for estimated future cost.</li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 50%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Condition</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Completeness</td>
<td>If branching factor is finite and step costs ≥ ε</td>
<td>Always finds a solution</td>
</tr>
<tr class="even">
<td>Optimality</td>
<td>If heuristic is admissible (and consistent)</td>
<td>Always finds an optimal solution</td>
</tr>
<tr class="odd">
<td>Time</td>
<td>Exponential in depth <span class="math inline">\(d\)</span> in worst case</td>
<td>But usually far fewer nodes expanded</td>
</tr>
<tr class="even">
<td>Space</td>
<td>Stores frontier + explored nodes</td>
<td>Often memory-limiting factor</td>
</tr>
</tbody>
</table>
<p>Heuristic Quality:</p>
<ul>
<li>A more <em>informed</em> heuristic (closer to true cost) reduces expansions.</li>
<li>If <span class="math inline">\(h(n) = 0\)</span>, A* degenerates to Uniform-Cost Search.</li>
<li>If <span class="math inline">\(h(n)\)</span> is perfect, A* expands only the optimal path.</li>
</ul>
</section>
<section id="tiny-code-24" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-24">Tiny Code</h4>
<p>A simple A* implementation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> astar(start, goal, successors, heuristic):</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    frontier <span class="op">=</span> [(heuristic(start), <span class="dv">0</span>, start)]  <span class="co"># (f, g, state)</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    parents <span class="op">=</span> {start: <span class="va">None</span>}</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    g_cost <span class="op">=</span> {start: <span class="dv">0</span>}</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> frontier:</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        f, g, state <span class="op">=</span> heapq.heappop(frontier)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> state <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>                path.append(state)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> parents[state]</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>], g</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt, step_cost <span class="kw">in</span> successors(state):</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>            new_g <span class="op">=</span> g <span class="op">+</span> step_cost</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> g_cost <span class="kw">or</span> new_g <span class="op">&lt;</span> g_cost[nxt]:</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>                g_cost[nxt] <span class="op">=</span> new_g</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>                parents[nxt] <span class="op">=</span> state</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(frontier, (new_g <span class="op">+</span> heuristic(nxt), new_g, nxt))</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span>, <span class="bu">float</span>(<span class="st">"inf"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-24" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-24">Why It Matters</h4>
<p>A* is the workhorse of search: efficient, general, and optimal under broad conditions. It powers route planners, puzzle solvers, robotics navigation, and more. Its brilliance lies in its balance of <em>what has been done</em> (<span class="math inline">\(g\)</span>) and <em>what remains</em> (<span class="math inline">\(h\)</span>).</p>
</section>
<section id="try-it-yourself-24" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-24">Try It Yourself</h4>
<ol type="1">
<li>Implement A* for the 8-puzzle using both misplaced-tile and Manhattan heuristics. Compare performance.</li>
<li>Build a weighted grid maze and use straight-line distance as <span class="math inline">\(h\)</span>. Measure nodes expanded vs.&nbsp;UCS.</li>
<li>Experiment with an inadmissible heuristic (e.g., multiply Manhattan distance by 2). Does A* remain optimal?</li>
</ol>
</section>
</section>
<section id="weighted-a-and-speedoptimality-trade-offs" class="level3">
<h3 class="anchored" data-anchor-id="weighted-a-and-speedoptimality-trade-offs">325. Weighted A* and Speed–Optimality Trade-offs</h3>
<p>Weighted A* modifies standard A* by scaling the heuristic:</p>
<p><span class="math display">\[
f(n) = g(n) + w \cdot h(n), \quad w &gt; 1
\]</span></p>
<p>This biases the search toward nodes that <em>appear</em> closer to the goal, reducing exploration and increasing speed. The trade-off: solutions are found faster, but they may not be optimal.</p>
<section id="picture-in-your-head-25" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-25">Picture in Your Head</h4>
<p>Imagine rushing to catch a train. Instead of carefully balancing both the distance already walked and the distance left, you exaggerate the GPS arrow’s advice, following the heuristic more aggressively. You’ll get there quickly—but maybe not along the shortest route.</p>
</section>
<section id="deep-dive-25" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-25">Deep Dive</h4>
<p>Weighted A* interpolates between two extremes:</p>
<ul>
<li>When <span class="math inline">\(w = 1\)</span>, it reduces to standard A*.</li>
<li>As <span class="math inline">\(w \to \infty\)</span>, it behaves like Greedy Best-First Search, ignoring path cost <span class="math inline">\(g(n)\)</span>.</li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 29%">
<col style="width: 57%">
</colgroup>
<thead>
<tr class="header">
<th>Weight <span class="math inline">\(w\)</span></th>
<th>Behavior</th>
<th>Guarantees</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(w = 1\)</span></td>
<td>Standard A*</td>
<td>Optimal</td>
</tr>
<tr class="even">
<td><span class="math inline">\(w &gt; 1\)</span></td>
<td>Biased toward heuristic</td>
<td>Completeness (with admissible h), not optimal</td>
</tr>
<tr class="odd">
<td>Large <span class="math inline">\(w\)</span></td>
<td>Greedy-like</td>
<td>Fast, risky</td>
</tr>
</tbody>
</table>
<p>Approximation: with an admissible heuristic, Weighted A* guarantees finding a solution whose cost is at most <span class="math inline">\(w\)</span> times the optimal.</p>
<p>Practical uses:</p>
<ul>
<li>Robotics, where real-time decisions matter more than strict optimality.</li>
<li>Large planning domains, where optimality is too expensive.</li>
<li>Anytime planning, where a quick solution is refined later.</li>
</ul>
</section>
<section id="tiny-code-25" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-25">Tiny Code</h4>
<p>Weighted A* implementation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> weighted_astar(start, goal, successors, heuristic, w<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    frontier <span class="op">=</span> [(heuristic(start)<span class="op">*</span>w, <span class="dv">0</span>, start)]</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    parents <span class="op">=</span> {start: <span class="va">None</span>}</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    g_cost <span class="op">=</span> {start: <span class="dv">0</span>}</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> frontier:</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>        f, g, state <span class="op">=</span> heapq.heappop(frontier)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> state <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>                path.append(state)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> parents[state]</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>], g</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt, step_cost <span class="kw">in</span> successors(state):</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>            new_g <span class="op">=</span> g <span class="op">+</span> step_cost</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> g_cost <span class="kw">or</span> new_g <span class="op">&lt;</span> g_cost[nxt]:</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>                g_cost[nxt] <span class="op">=</span> new_g</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>                parents[nxt] <span class="op">=</span> state</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>                f_new <span class="op">=</span> new_g <span class="op">+</span> w<span class="op">*</span>heuristic(nxt)</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(frontier, (f_new, new_g, nxt))</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span>, <span class="bu">float</span>(<span class="st">"inf"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-25" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-25">Why It Matters</h4>
<p>Weighted A* highlights the tension between efficiency and guarantees. In practice, many systems prefer a <em>good enough</em> solution quickly rather than waiting for the absolute best. Weighted A* provides a principled way to tune this balance.</p>
</section>
<section id="try-it-yourself-25" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-25">Try It Yourself</h4>
<ol type="1">
<li>Solve the 8-puzzle with Weighted A* using <span class="math inline">\(w=2\)</span>. How does the number of nodes expanded compare to standard A*?</li>
<li>In a grid world with varying costs, test solutions at <span class="math inline">\(w=1, 2, 5\)</span>. How far from optimal are the paths?</li>
<li>Think about an autonomous drone: why might Weighted A* be more useful than exact A*?</li>
</ol>
</section>
</section>
<section id="iterative-deepening-a-ida" class="level3">
<h3 class="anchored" data-anchor-id="iterative-deepening-a-ida">326. Iterative Deepening A* (IDA*)</h3>
<p>Iterative Deepening A* (IDA*) combines the memory efficiency of Iterative Deepening with the informed power of A*. Instead of storing a full frontier in a priority queue, it uses depth-first exploration bounded by an <span class="math inline">\(f(n)\)</span> limit, where <span class="math inline">\(f(n) = g(n) + h(n)\)</span>. The bound increases step by step until a solution is found.</p>
<section id="picture-in-your-head-26" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-26">Picture in Your Head</h4>
<p>Imagine climbing a mountain with a budget of energy. First you allow yourself 10 units of effort—if you fail, you try again with 15, then 20. Each time, you push farther, guided by your compass (the heuristic). Eventually you reach the peak without ever needing to keep a giant map of every possible path.</p>
</section>
<section id="deep-dive-26" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-26">Deep Dive</h4>
<p>Key mechanism:</p>
<ul>
<li>Use DFS but prune nodes with <span class="math inline">\(f(n) &gt;\)</span> current threshold.</li>
<li>If no solution is found, increase the threshold to the smallest <span class="math inline">\(f\)</span> that exceeded it.</li>
<li>Repeat until a solution is found.</li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Property</th>
<th>Characteristic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Completeness</td>
<td>Yes, if branching factor finite</td>
</tr>
<tr class="even">
<td>Optimality</td>
<td>Yes, with admissible heuristic</td>
</tr>
<tr class="odd">
<td>Time Complexity</td>
<td><span class="math inline">\(O(b^d)\)</span>, but with multiple iterations</td>
</tr>
<tr class="even">
<td>Space Complexity</td>
<td><span class="math inline">\(O(bd)\)</span>, like DFS</td>
</tr>
</tbody>
</table>
<p>IDA* is attractive for problems with large branching factors where A*’s memory is prohibitive, e.g., puzzles like the 15-puzzle.</p>
</section>
<section id="tiny-code-26" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-26">Tiny Code</h4>
<p>IDA* implementation sketch:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ida_star(start, goal, successors, heuristic):</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(path, g, bound):</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> path[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        f <span class="op">=</span> g <span class="op">+</span> heuristic(state)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> f <span class="op">&gt;</span> bound:</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> f, <span class="va">None</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> f, path</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>        minimum <span class="op">=</span> <span class="bu">float</span>(<span class="st">"inf"</span>)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt, cost <span class="kw">in</span> successors(state):</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> path:  <span class="co"># avoid cycles</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>                new_bound, result <span class="op">=</span> dfs(path<span class="op">+</span>[nxt], g<span class="op">+</span>cost, bound)</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> result:</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> new_bound, result</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>                minimum <span class="op">=</span> <span class="bu">min</span>(minimum, new_bound)</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> minimum, <span class="va">None</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    bound <span class="op">=</span> heuristic(start)</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> [start]</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>        new_bound, result <span class="op">=</span> dfs(path, <span class="dv">0</span>, bound)</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> result:</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> result</span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> new_bound <span class="op">==</span> <span class="bu">float</span>(<span class="st">"inf"</span>):</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>        bound <span class="op">=</span> new_bound</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-26" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-26">Why It Matters</h4>
<p>IDA* solves the key weakness of A*: memory blow-up. By combining iterative deepening with heuristics, it finds optimal solutions while using linear space. This made it historically important in solving large puzzles and remains useful when memory is tight.</p>
</section>
<section id="try-it-yourself-26" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-26">Try It Yourself</h4>
<ol type="1">
<li>Implement IDA* for the 8-puzzle. Compare memory usage vs.&nbsp;A*.</li>
<li>Test IDA* with Manhattan distance heuristic. Does it always return the same solution as A*?</li>
<li>Explore the effect of heuristic strength: what happens if you replace Manhattan with “tiles misplaced”?</li>
</ol>
</section>
</section>
<section id="heuristic-evaluation-and-accuracy-measures" class="level3">
<h3 class="anchored" data-anchor-id="heuristic-evaluation-and-accuracy-measures">327. Heuristic Evaluation and Accuracy Measures</h3>
<p>Heuristics differ in quality. Some are weak, providing little guidance, while others closely approximate the true cost-to-go. Evaluating heuristics means measuring how effective they are at reducing search effort while preserving optimality. Accuracy determines how much work an algorithm like A* must do.</p>
<section id="picture-in-your-head-27" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-27">Picture in Your Head</h4>
<p>Imagine two GPS devices. One always underestimates travel time by a lot, telling you “5 minutes left” when you’re really 30 minutes away. The other is nearly precise, saying “28 minutes left.” Both are admissible (never overestimate), but the second clearly saves you wasted effort by narrowing the search.</p>
</section>
<section id="deep-dive-27" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-27">Deep Dive</h4>
<p>Heuristics can be evaluated using several metrics:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 8%">
<col style="width: 65%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>Metric</th>
<th>Definition</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Accuracy</td>
<td>Average closeness of <span class="math inline">\(h(n)\)</span> to true cost <span class="math inline">\(h^*(n)\)</span></td>
<td>Better accuracy = fewer nodes expanded</td>
</tr>
<tr class="even">
<td>Informedness</td>
<td>Ordering quality: does <span class="math inline">\(h\)</span> rank states similarly to <span class="math inline">\(h^*\)</span>?</td>
<td>High informedness improves efficiency</td>
</tr>
<tr class="odd">
<td>Dominance</td>
<td>A heuristic <span class="math inline">\(h_1\)</span> dominates <span class="math inline">\(h_2\)</span> if <span class="math inline">\(h_1(n) \geq h_2(n)\)</span> for all <span class="math inline">\(n\)</span>, with at least one strict &gt;</td>
<td>Stronger heuristics dominate weaker ones</td>
</tr>
<tr class="even">
<td>Consistency</td>
<td>Triangle inequality: <span class="math inline">\(h(n) \leq c(n,a,n') + h(n')\)</span></td>
<td>Ensures A* avoids reopening nodes</td>
</tr>
</tbody>
</table>
<p>Insights:</p>
<ul>
<li>Stronger heuristics expand fewer nodes but may be harder to compute.</li>
<li>Dominance provides a formal way to compare heuristics: always prefer the dominant one.</li>
<li>Sometimes, combining heuristics (e.g., max of two admissible ones) gives better performance.</li>
</ul>
</section>
<section id="tiny-code-27" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-27">Tiny Code</h4>
<p>Comparing two heuristics in the 8-puzzle:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> misplaced_tiles(state, goal):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">9</span>) <span class="cf">if</span> state[i] <span class="op">!=</span> goal[i] <span class="kw">and</span> state[i] <span class="op">!=</span> <span class="dv">0</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> manhattan_distance(state, goal):</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> value <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">9</span>):</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> <span class="bu">divmod</span>(state.index(value), <span class="dv">3</span>)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>        x2, y2 <span class="op">=</span> <span class="bu">divmod</span>(goal.index(value), <span class="dv">3</span>)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>        dist <span class="op">+=</span> <span class="bu">abs</span>(x1 <span class="op">-</span> x2) <span class="op">+</span> <span class="bu">abs</span>(y1 <span class="op">-</span> y2)</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Dominance check: Manhattan always &gt;= misplaced</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here, Manhattan dominates misplaced tiles because it always provides at least as large an estimate and sometimes strictly larger.</p>
</section>
<section id="why-it-matters-27" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-27">Why It Matters</h4>
<p>Heuristic evaluation determines whether search is practical. A poor heuristic can make A* behave like uniform-cost search. A good heuristic shrinks the search space dramatically. Knowing how to compare and combine heuristics is essential for designing efficient AI systems.</p>
</section>
<section id="try-it-yourself-27" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-27">Try It Yourself</h4>
<ol type="1">
<li>Measure node expansions for A* using misplaced tiles vs.&nbsp;Manhattan distance in the 8-puzzle. Which dominates?</li>
<li>Construct a domain where two heuristics are incomparable (neither dominates the other). What happens if you combine them with <code>max</code>?</li>
<li>Write code that, given two heuristics, tests whether one dominates the other across sampled states.</li>
</ol>
</section>
</section>
<section id="pattern-databases-and-domain-specific-heuristics" class="level3">
<h3 class="anchored" data-anchor-id="pattern-databases-and-domain-specific-heuristics">328. Pattern Databases and Domain-Specific Heuristics</h3>
<p>A <em>pattern database</em> (PDB) is a precomputed lookup table storing the exact cost to solve simplified versions of a problem. During search, the heuristic is computed by mapping the current state to the pattern and retrieving the stored value. PDBs produce strong, admissible heuristics tailored to specific domains.</p>
<section id="picture-in-your-head-28" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-28">Picture in Your Head</h4>
<p>Think of solving a Rubik’s Cube. Instead of estimating moves from scratch each time, you carry a cheat sheet: for every possible arrangement of a subset of the cube’s tiles, you already know the exact number of moves required. When solving the full cube, you consult this sheet for guidance.</p>
</section>
<section id="deep-dive-28" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-28">Deep Dive</h4>
<p>Pattern databases work by reducing the original problem to smaller subproblems:</p>
<ul>
<li>Define pattern: choose a subset of pieces or features to track.</li>
<li>Precompute: perform exhaustive search on the reduced problem, storing exact solution lengths.</li>
<li>Lookup: during actual search, map the full state to the pattern state and use the stored cost as <span class="math inline">\(h(n)\)</span>.</li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 19%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Admissibility</td>
<td>PDB values are exact lower bounds, so they never overestimate</td>
</tr>
<tr class="even">
<td>Informativeness</td>
<td>PDBs provide much stronger guidance than simple heuristics</td>
</tr>
<tr class="odd">
<td>Cost</td>
<td>Large memory usage, heavy precomputation</td>
</tr>
<tr class="even">
<td>Composability</td>
<td>Multiple PDBs can be combined (e.g., additive heuristics)</td>
</tr>
</tbody>
</table>
<p>Classic applications:</p>
<ul>
<li>8-puzzle / 15-puzzle: PDBs track a subset of tiles.</li>
<li>Rubik’s Cube: PDBs store moves for specific cube pieces.</li>
<li>Planning problems: abstract action sets yield tractable PDBs.</li>
</ul>
</section>
<section id="tiny-code-28" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-28">Tiny Code</h4>
<p>Simple PDB construction for the 8-puzzle (subset of tiles):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_pdb(goal, pattern):</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    pdb <span class="op">=</span> {}</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> deque([(goal, <span class="dv">0</span>)])</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> {<span class="bu">tuple</span>(goal): <span class="dv">0</span>}</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        state, cost <span class="op">=</span> q.popleft()</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        key <span class="op">=</span> <span class="bu">tuple</span>(x <span class="cf">if</span> x <span class="kw">in</span> pattern <span class="cf">else</span> <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> state)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> key <span class="kw">not</span> <span class="kw">in</span> pdb:</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>            pdb[key] <span class="op">=</span> cost</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> state.index(<span class="dv">0</span>)</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> <span class="bu">divmod</span>(i, <span class="dv">3</span>)</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx, dy <span class="kw">in</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>)]:</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>            nx, ny <span class="op">=</span> x<span class="op">+</span>dx, y<span class="op">+</span>dy</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nx <span class="op">&lt;</span> <span class="dv">3</span> <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> ny <span class="op">&lt;</span> <span class="dv">3</span>:</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>                j <span class="op">=</span> nx<span class="op">*</span><span class="dv">3</span> <span class="op">+</span> ny</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>                new_state <span class="op">=</span> state[:]</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>                new_state[i], new_state[j] <span class="op">=</span> new_state[j], new_state[i]</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>                t <span class="op">=</span> <span class="bu">tuple</span>(new_state)</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> t <span class="kw">not</span> <span class="kw">in</span> seen:</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>                    seen[t] <span class="op">=</span> cost<span class="op">+</span><span class="dv">1</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>                    q.append((new_state, cost<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pdb</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>goal <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">0</span>]</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>pdb <span class="op">=</span> build_pdb(goal, {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>})</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-28" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-28">Why It Matters</h4>
<p>Pattern databases represent a leap in heuristic design: they shift effort from runtime to precomputation, enabling far stronger heuristics. This approach has solved benchmark problems that were once considered intractable, setting milestones in AI planning and puzzle solving.</p>
</section>
<section id="try-it-yourself-28" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-28">Try It Yourself</h4>
<ol type="1">
<li>Build a small PDB for the 8-puzzle with tiles {1,2,3} and test it as a heuristic in A*.</li>
<li>Explore memory trade-offs: how does PDB size grow with pattern size?</li>
<li>Consider another domain (like Sokoban). What patterns could you use to design an admissible PDB heuristic?</li>
</ol>
</section>
</section>
<section id="applications-of-heuristic-search-routing-planning" class="level3">
<h3 class="anchored" data-anchor-id="applications-of-heuristic-search-routing-planning">329. Applications of Heuristic Search (Routing, Planning)</h3>
<p>Heuristic search is used whenever brute-force exploration is infeasible. By using domain knowledge to guide exploration, it enables practical solutions for routing, task planning, resource scheduling, and robotics. These applications demonstrate how theory translates into real-world problem solving.</p>
<section id="picture-in-your-head-29" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-29">Picture in Your Head</h4>
<p>Think of Google Maps. When you request directions, the system doesn’t try every possible route. Instead, it uses heuristics like “straight-line distance” to guide A* toward plausible paths, pruning billions of alternatives.</p>
</section>
<section id="deep-dive-29" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-29">Deep Dive</h4>
<p>Heuristic search appears across domains:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 49%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Application</th>
<th>Heuristic Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Routing</td>
<td>Road navigation, airline paths</td>
<td>Euclidean or geodesic distance</td>
</tr>
<tr class="even">
<td>Robotics</td>
<td>Path planning for arms, drones, autonomous vehicles</td>
<td>Distance-to-goal, obstacle penalties</td>
</tr>
<tr class="odd">
<td>Task Planning</td>
<td>Multi-step workflows, logistics, manufacturing</td>
<td>Relaxed action counts</td>
</tr>
<tr class="even">
<td>Games</td>
<td>Move selection, puzzle solving</td>
<td>Material advantage, piece distances</td>
</tr>
<tr class="odd">
<td>Scheduling</td>
<td>Job-shop, cloud resources</td>
<td>Estimated slack or workload</td>
</tr>
</tbody>
</table>
<p>Key insight: heuristics exploit <em>structure</em>—geometry in routing, relaxations in planning, domain-specific scoring in games. Without them, search would drown in combinatorial explosion.</p>
</section>
<section id="tiny-code-29" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-29">Tiny Code</h4>
<p>A* for grid routing with Euclidean heuristic:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq, math</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> astar(start, goal, successors, heuristic):</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    frontier <span class="op">=</span> [(heuristic(start, goal), <span class="dv">0</span>, start)]</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    parents <span class="op">=</span> {start: <span class="va">None</span>}</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    g_cost <span class="op">=</span> {start: <span class="dv">0</span>}</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> frontier:</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>        f, g, state <span class="op">=</span> heapq.heappop(frontier)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> state <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>                path.append(state)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> parents[state]</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>], g</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt, cost <span class="kw">in</span> successors(state):</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>            new_g <span class="op">=</span> g <span class="op">+</span> cost</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> g_cost <span class="kw">or</span> new_g <span class="op">&lt;</span> g_cost[nxt]:</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>                g_cost[nxt] <span class="op">=</span> new_g</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>                parents[nxt] <span class="op">=</span> state</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>                f_new <span class="op">=</span> new_g <span class="op">+</span> heuristic(nxt, goal)</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(frontier, (f_new, new_g, nxt))</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span>, <span class="bu">float</span>(<span class="st">"inf"</span>)</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> heuristic(p, q):  <span class="co"># Euclidean distance</span></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.dist(p, q)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-29" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-29">Why It Matters</h4>
<p>Heuristic search powers real systems people use daily: navigation apps, robotics, manufacturing schedulers. Its success lies in embedding knowledge into algorithms, turning theoretical models into scalable solutions.</p>
</section>
<section id="try-it-yourself-29" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-29">Try It Yourself</h4>
<ol type="1">
<li>Modify the routing code to use Manhattan distance instead of Euclidean. Which works better in grid-like maps?</li>
<li>Design a heuristic for a warehouse robot with obstacles. How does it differ from plain distance?</li>
<li>For job scheduling, think of a heuristic that estimates completion time. How would it guide search?</li>
</ol>
</section>
</section>
<section id="case-study-heuristic-search-in-puzzles-and-robotics" class="level3">
<h3 class="anchored" data-anchor-id="case-study-heuristic-search-in-puzzles-and-robotics">330. Case Study: Heuristic Search in Puzzles and Robotics</h3>
<p>Puzzles and robotics highlight how heuristics transform intractable search problems into solvable ones. In puzzles, heuristics cut down combinatorial blow-up. In robotics, they make motion planning feasible in continuous, obstacle-filled environments.</p>
<section id="picture-in-your-head-30" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-30">Picture in Your Head</h4>
<p>Picture solving the 15-puzzle. Without heuristics, you’d search billions of states. With Manhattan distance as a heuristic, the search narrows dramatically. Now picture a robot navigating a cluttered warehouse: instead of exploring every possible motion, it follows heuristics like “distance to goal” or “clearance from obstacles” to stay efficient and safe.</p>
</section>
<section id="deep-dive-30" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-30">Deep Dive</h4>
<p>Case studies:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 19%">
<col style="width: 16%">
<col style="width: 27%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Problem</th>
<th>Heuristic Used</th>
<th>Impact</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8/15-puzzle</td>
<td>Tile rearrangement</td>
<td>Manhattan distance, pattern databases</td>
<td>Reduces billions of states to manageable expansions</td>
</tr>
<tr class="even">
<td>Rubik’s Cube</td>
<td>Color reconfiguration</td>
<td>Precomputed pattern databases</td>
<td>Enables solving optimally in minutes</td>
</tr>
<tr class="odd">
<td>Robotics (mobile)</td>
<td>Path through obstacles</td>
<td>Euclidean or geodesic distance</td>
<td>Guides search through free space</td>
</tr>
<tr class="even">
<td>Robotics (manipulation)</td>
<td>Arm motion planning</td>
<td>Distance in configuration space</td>
<td>Narrows down feasible arm trajectories</td>
</tr>
</tbody>
</table>
<p>Key insight: heuristics exploit <em>domain structure</em>. In puzzles, they model how many steps tiles are “out of place.” In robotics, they approximate geometric effort to the goal. Without such estimates, both domains would be hopelessly large.</p>
</section>
<section id="tiny-code-30" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-30">Tiny Code</h4>
<p>Applying A* with Manhattan heuristic for the 8-puzzle:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> manhattan(state, goal):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">9</span>):</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> <span class="bu">divmod</span>(state.index(v), <span class="dv">3</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>        x2, y2 <span class="op">=</span> <span class="bu">divmod</span>(goal.index(v), <span class="dv">3</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>        dist <span class="op">+=</span> <span class="bu">abs</span>(x1 <span class="op">-</span> x2) <span class="op">+</span> <span class="bu">abs</span>(y1 <span class="op">-</span> y2)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co"># state and goal as flat lists of 9 elements, 0 = blank</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-30" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-30">Why It Matters</h4>
<p>These domains illustrate the leap from theory to practice. Heuristic search is not just abstract—it enables solving real problems in logistics, games, and robotics. Without heuristics, these domains remain out of reach; with them, they become tractable.</p>
</section>
<section id="try-it-yourself-30" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-30">Try It Yourself</h4>
<ol type="1">
<li>Implement Manhattan distance for the 15-puzzle and compare performance with misplaced tiles.</li>
<li>For a 2D robot maze with obstacles, test A* with Euclidean vs.&nbsp;Manhattan heuristics. Which performs better?</li>
<li>Design a heuristic for a robotic arm: how would you estimate “distance” in joint space?</li>
</ol>
</section>
</section>
</section>
<section id="chapter-34.-constraint-satisfaction-problems" class="level2">
<h2 class="anchored" data-anchor-id="chapter-34.-constraint-satisfaction-problems">Chapter 34. Constraint Satisfaction Problems</h2>
<section id="defining-csps-variables-domains-and-constraints" class="level3">
<h3 class="anchored" data-anchor-id="defining-csps-variables-domains-and-constraints">331. Defining CSPs: Variables, Domains, and Constraints</h3>
<p>A <em>Constraint Satisfaction Problem</em> (CSP) is defined by three components:</p>
<ol type="1">
<li>Variables. the unknowns to assign values to.</li>
<li>Domains. the possible values each variable can take.</li>
<li>Constraints. rules restricting allowable combinations of values. The goal is to assign a value to every variable such that all constraints are satisfied.</li>
</ol>
<section id="picture-in-your-head-31" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-31">Picture in Your Head</h4>
<p>Think of coloring a map. The variables are the regions, the domain is the set of available colors, and the constraints are “no two adjacent regions can share the same color.” A valid coloring is a solution to the CSP.</p>
</section>
<section id="deep-dive-31" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-31">Deep Dive</h4>
<p>CSPs provide a powerful abstraction: many problems reduce naturally to variables, domains, and constraints.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 20%">
<col style="width: 64%">
</colgroup>
<thead>
<tr class="header">
<th>Element</th>
<th>Role</th>
<th>Example (Sudoku)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Variables</td>
<td>Unknowns</td>
<td>81 cells</td>
</tr>
<tr class="even">
<td>Domains</td>
<td>Possible values</td>
<td>Digits 1–9</td>
</tr>
<tr class="odd">
<td>Constraints</td>
<td>Restrictions</td>
<td>Row/column/box must contain all digits uniquely</td>
</tr>
</tbody>
</table>
<ul>
<li><p>Constraint types:</p>
<ul>
<li>Unary: apply to a single variable (e.g., “x ≠ 3”).</li>
<li>Binary: involve pairs of variables (e.g., “x ≠ y”).</li>
<li>Global: involve many variables (e.g., “all-different”).</li>
</ul></li>
<li><p>Solution space: all variable assignments consistent with constraints.</p></li>
<li><p>Search: often requires backtracking and inference to prune invalid states.</p></li>
</ul>
<p>CSPs unify diverse problems: scheduling, assignment, resource allocation, puzzles. They are studied because they combine logical structure with combinatorial complexity.</p>
</section>
<section id="tiny-code-31" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-31">Tiny Code</h4>
<p>Encoding a map-coloring CSP:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>variables <span class="op">=</span> [<span class="st">"WA"</span>, <span class="st">"NT"</span>, <span class="st">"SA"</span>, <span class="st">"Q"</span>, <span class="st">"NSW"</span>, <span class="st">"V"</span>]</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>domains <span class="op">=</span> {var: [<span class="st">"red"</span>, <span class="st">"green"</span>, <span class="st">"blue"</span>] <span class="cf">for</span> var <span class="kw">in</span> variables}</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>constraints <span class="op">=</span> {</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"WA"</span>,<span class="st">"NT"</span>), (<span class="st">"WA"</span>,<span class="st">"SA"</span>), (<span class="st">"NT"</span>,<span class="st">"SA"</span>),</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"NT"</span>,<span class="st">"Q"</span>), (<span class="st">"SA"</span>,<span class="st">"Q"</span>), (<span class="st">"SA"</span>,<span class="st">"NSW"</span>),</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"SA"</span>,<span class="st">"V"</span>), (<span class="st">"Q"</span>,<span class="st">"NSW"</span>), (<span class="st">"NSW"</span>,<span class="st">"V"</span>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_valid(assignment):</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (a,b) <span class="kw">in</span> constraints:</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a <span class="kw">in</span> assignment <span class="kw">and</span> b <span class="kw">in</span> assignment:</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> assignment[a] <span class="op">==</span> assignment[b]:</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-31" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-31">Why It Matters</h4>
<p>CSPs form a backbone of AI because they provide a uniform framework for many practical problems. By understanding variables, domains, and constraints, we can model real-world challenges in a way that search and inference techniques can solve.</p>
</section>
<section id="try-it-yourself-31" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-31">Try It Yourself</h4>
<ol type="1">
<li>Model Sudoku as a CSP: define variables, domains, and constraints.</li>
<li>Define a CSP for job assignment: workers (variables), tasks (domains), and restrictions (constraints).</li>
<li>Extend the map-coloring example to include a new territory and test if your CSP solver adapts.</li>
</ol>
</section>
</section>
<section id="constraint-graphs-and-visualization" class="level3">
<h3 class="anchored" data-anchor-id="constraint-graphs-and-visualization">332. Constraint Graphs and Visualization</h3>
<p>A constraint graph is a visual representation of a CSP. Each variable is a node, and constraints are edges (for binary constraints) or hyperedges (for higher-order constraints). This graphical view makes relationships among variables explicit and enables specialized inference algorithms.</p>
<section id="picture-in-your-head-32" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-32">Picture in Your Head</h4>
<p>Imagine drawing circles for each region in a map-coloring problem. Whenever two regions must differ in color, you connect their circles with a line. The resulting web of nodes and edges is the constraint graph, showing which variables directly interact.</p>
</section>
<section id="deep-dive-32" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-32">Deep Dive</h4>
<p>Constraint graphs help in analyzing problem structure:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 86%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nodes</td>
<td>Represent CSP variables</td>
</tr>
<tr class="even">
<td>Edges</td>
<td>Represent binary constraints (e.g., “x ≠ y”)</td>
</tr>
<tr class="odd">
<td>Hyperedges</td>
<td>Represent global constraints (e.g., “all-different”)</td>
</tr>
<tr class="even">
<td>Degree</td>
<td>Number of constraints on a variable; higher degree means tighter coupling</td>
</tr>
<tr class="odd">
<td>Graph structure</td>
<td>Determines algorithmic efficiency (e.g., tree-structured CSPs are solvable in polynomial time)</td>
</tr>
</tbody>
</table>
<p>Benefits:</p>
<ul>
<li>Visualization: clarifies dependencies.</li>
<li>Decomposition: if the graph splits into subgraphs, each subproblem can be solved independently.</li>
<li>Algorithm design: many CSP algorithms (arc-consistency, tree-decomposition) rely directly on graph structure.</li>
</ul>
</section>
<section id="tiny-code-32" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-32">Tiny Code</h4>
<p>Using <code>networkx</code> to visualize a map-coloring constraint graph:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>variables <span class="op">=</span> [<span class="st">"WA"</span>, <span class="st">"NT"</span>, <span class="st">"SA"</span>, <span class="st">"Q"</span>, <span class="st">"NSW"</span>, <span class="st">"V"</span>]</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="st">"WA"</span>,<span class="st">"NT"</span>), (<span class="st">"WA"</span>,<span class="st">"SA"</span>), (<span class="st">"NT"</span>,<span class="st">"SA"</span>), (<span class="st">"NT"</span>,<span class="st">"Q"</span>),</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>         (<span class="st">"SA"</span>,<span class="st">"Q"</span>), (<span class="st">"SA"</span>,<span class="st">"NSW"</span>), (<span class="st">"SA"</span>,<span class="st">"V"</span>), (<span class="st">"Q"</span>,<span class="st">"NSW"</span>), (<span class="st">"NSW"</span>,<span class="st">"V"</span>)]</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.Graph()</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>G.add_nodes_from(variables)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>G.add_edges_from(edges)</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>nx.draw(G, with_labels<span class="op">=</span><span class="va">True</span>, node_color<span class="op">=</span><span class="st">"lightblue"</span>, node_size<span class="op">=</span><span class="dv">1500</span>, font_size<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This produces a clear visualization of variables and their constraints.</p>
</section>
<section id="why-it-matters-32" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-32">Why It Matters</h4>
<p>Constraint graphs bridge theory and practice. They expose structural properties that can be exploited for efficiency and give human intuition a way to grasp problem complexity. For large CSPs, graph decomposition can be the difference between infeasibility and tractability.</p>
</section>
<section id="try-it-yourself-32" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-32">Try It Yourself</h4>
<ol type="1">
<li>Draw the constraint graph for Sudoku rows, columns, and 3×3 boxes. What structure emerges?</li>
<li>Split a constraint graph into independent subgraphs. Solve them separately—does it reduce complexity?</li>
<li>Explore how tree-structured graphs allow linear-time CSP solving with arc consistency.</li>
</ol>
</section>
</section>
<section id="backtracking-search-for-csps" class="level3">
<h3 class="anchored" data-anchor-id="backtracking-search-for-csps">333. Backtracking Search for CSPs</h3>
<p>Backtracking search is the fundamental algorithm for solving CSPs. It assigns values to variables one at a time, checks constraints, and backtracks whenever a violation occurs. While simple, it can be enhanced with heuristics and pruning to handle large problems effectively.</p>
<section id="picture-in-your-head-33" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-33">Picture in Your Head</h4>
<p>Think of filling out a Sudoku grid. You try a number in one cell. If it doesn’t cause a contradiction, you continue. If later you hit an impossibility, you erase recent choices and backtrack to an earlier decision point.</p>
</section>
<section id="deep-dive-33" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-33">Deep Dive</h4>
<p>Basic backtracking procedure:</p>
<ol type="1">
<li>Choose an unassigned variable.</li>
<li>Assign a value from its domain.</li>
<li>Check consistency with constraints.</li>
<li>If consistent, recurse to assign the next variable.</li>
<li>If no valid value exists, backtrack.</li>
</ol>
<p>Properties:</p>
<ul>
<li>Completeness: Guaranteed to find a solution if one exists.</li>
<li>Optimality: Not relevant (solutions are just “satisfying” assignments).</li>
<li>Time complexity: <span class="math inline">\(O(d^n)\)</span>, where <span class="math inline">\(d\)</span> = domain size, <span class="math inline">\(n\)</span> = number of variables.</li>
<li>Space complexity: <span class="math inline">\(O(n)\)</span>, since it only stores assignments.</li>
</ul>
<p>Enhancements:</p>
<ul>
<li>Variable ordering (e.g., MRV heuristic).</li>
<li>Value ordering (e.g., least-constraining value).</li>
<li>Constraint propagation (forward checking, arc consistency).</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Variant</th>
<th>Benefit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Naïve backtracking</td>
<td>Simple, brute-force baseline</td>
</tr>
<tr class="even">
<td>With MRV heuristic</td>
<td>Reduces branching early</td>
</tr>
<tr class="odd">
<td>With forward checking</td>
<td>Detects conflicts sooner</td>
</tr>
<tr class="even">
<td>With full arc consistency</td>
<td>Further pruning of search space</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-33" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-33">Tiny Code</h4>
<p>A simple backtracking CSP solver:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backtrack(assignment, variables, domains, constraints):</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(assignment) <span class="op">==</span> <span class="bu">len</span>(variables):</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> assignment</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> <span class="bu">next</span>(v <span class="cf">for</span> v <span class="kw">in</span> variables <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> assignment)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> value <span class="kw">in</span> domains[var]:</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>        assignment[var] <span class="op">=</span> value</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_valid(assignment, constraints):</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> backtrack(assignment, variables, domains, constraints)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> result:</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> result</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> assignment[var]</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: map-coloring CSP reuses is_valid() from earlier</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-33" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-33">Why It Matters</h4>
<p>Backtracking is the workhorse for CSPs. Although exponential in the worst case, with clever heuristics it solves many practical problems (Sudoku, map coloring, scheduling). It also provides the baseline against which advanced CSP algorithms are compared.</p>
</section>
<section id="try-it-yourself-33" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-33">Try It Yourself</h4>
<ol type="1">
<li>Solve the 4-color map problem using backtracking search. How many backtracks occur?</li>
<li>Add MRV heuristic to your solver. How does it change performance?</li>
<li>Implement forward checking: prune domain values of neighbors after each assignment. Compare speed.</li>
</ol>
</section>
</section>
<section id="constraint-propagation-and-inference-forward-checking-ac-3" class="level3">
<h3 class="anchored" data-anchor-id="constraint-propagation-and-inference-forward-checking-ac-3">334. Constraint Propagation and Inference (Forward Checking, AC-3)</h3>
<p>Constraint propagation reduces the search space by enforcing constraints <em>before</em> or <em>during</em> assignment. Instead of waiting to discover inconsistencies deep in the search tree, inference eliminates impossible values early. Two common techniques are forward checking and arc consistency (AC-3).</p>
<section id="picture-in-your-head-34" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-34">Picture in Your Head</h4>
<p>Think of Sudoku. If you place a “5” in a row, forward checking immediately rules out “5” from other cells in that row. AC-3 goes further: it keeps pruning until every possible value for every cell is still consistent with its neighbors.</p>
</section>
<section id="deep-dive-34" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-34">Deep Dive</h4>
<ul>
<li>Forward Checking: After assigning a variable, eliminate inconsistent values from neighboring domains. If any domain becomes empty, backtrack immediately.</li>
<li>Arc Consistency (AC-3): For every constraint <span class="math inline">\(X \neq Y\)</span>, ensure that for each value in <span class="math inline">\(X\)</span>’s domain, there exists some consistent value in <span class="math inline">\(Y\)</span>’s domain. If not, prune it. Repeat until no more pruning is possible.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 39%">
<col style="width: 10%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Strength</th>
<th>Overhead</th>
<th>When Useful</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Forward Checking</td>
<td>Catches direct contradictions</td>
<td>Low</td>
<td>During search</td>
</tr>
<tr class="even">
<td>AC-3</td>
<td>Ensures global arc consistency</td>
<td>Higher</td>
<td>Before &amp; during search</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-34" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-34">Tiny Code</h4>
<p>Forward checking and AC-3 implementation sketches:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward_check(var, value, domains, constraints):</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    pruned <span class="op">=</span> []</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (x,y) <span class="kw">in</span> constraints:</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">==</span> var:</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v <span class="kw">in</span> domains[y][:]:</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> v <span class="op">==</span> value:</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>                    domains[y].remove(v)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>                    pruned.append((y,v))</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pruned</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ac3(domains, constraints):</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    queue <span class="op">=</span> deque(constraints)</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>        (x,y) <span class="op">=</span> queue.popleft()</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> revise(domains, x, y):</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> domains[x]:</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (z, _) <span class="kw">in</span> constraints:</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> z <span class="op">==</span> x:</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>                    queue.append((z,y))</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> revise(domains, x, y):</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>    revised <span class="op">=</span> <span class="va">False</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> vx <span class="kw">in</span> domains[x][:]:</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(vx <span class="op">==</span> vy <span class="cf">for</span> vy <span class="kw">in</span> domains[y]):</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>            domains[x].remove(vx)</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>            revised <span class="op">=</span> <span class="va">True</span></span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> revised</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-34" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-34">Why It Matters</h4>
<p>Constraint propagation prevents wasted effort by cutting off doomed paths early. Forward checking is lightweight and effective, while AC-3 enforces a stronger global consistency. These techniques make backtracking search far more efficient in practice.</p>
</section>
<section id="try-it-yourself-34" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-34">Try It Yourself</h4>
<ol type="1">
<li>Implement forward checking in your map-coloring backtracking solver. Measure how many fewer backtracks occur.</li>
<li>Run AC-3 preprocessing on a Sudoku grid. How many values are pruned before search begins?</li>
<li>Compare solving times for pure backtracking vs.&nbsp;backtracking + AC-3 on a CSP with 20 variables.</li>
</ol>
</section>
</section>
<section id="heuristics-for-csps-mrv-degree-and-least-constraining-value" class="level3">
<h3 class="anchored" data-anchor-id="heuristics-for-csps-mrv-degree-and-least-constraining-value">335. Heuristics for CSPs: MRV, Degree, and Least-Constraining Value</h3>
<p>CSP backtracking search becomes vastly more efficient with smart heuristics. Three widely used strategies are:</p>
<ul>
<li>Minimum Remaining Values (MRV): choose the variable with the fewest legal values left.</li>
<li>Degree heuristic: break ties by choosing the variable with the most constraints on others.</li>
<li>Least-Constraining Value (LCV): when assigning, pick the value that rules out the fewest options for neighbors.</li>
</ul>
<section id="picture-in-your-head-35" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-35">Picture in Your Head</h4>
<p>Imagine seating guests at a wedding. If one guest has only two possible seats (MRV), assign them first. If multiple guests tie, prioritize the one who conflicts with the most people (Degree). When choosing a seat for them, pick the option that leaves the most flexibility for everyone else (LCV).</p>
</section>
<section id="deep-dive-35" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-35">Deep Dive</h4>
<p>These heuristics aim to reduce branching:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 10%">
<col style="width: 53%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Heuristic</th>
<th>Strategy</th>
<th>Benefit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MRV</td>
<td>Pick the variable with the tightest domain</td>
<td>Exposes dead ends early</td>
</tr>
<tr class="even">
<td>Degree</td>
<td>Among ties, pick the most constrained variable</td>
<td>Focuses on critical bottlenecks</td>
</tr>
<tr class="odd">
<td>LCV</td>
<td>Order values to preserve flexibility</td>
<td>Avoids unnecessary pruning</td>
</tr>
</tbody>
</table>
<p>Together, they greatly reduce wasted exploration. For example, in Sudoku, MRV focuses on cells with few candidates, Degree prioritizes those in crowded rows/columns, and LCV ensures choices don’t cripple other cells.</p>
</section>
<section id="tiny-code-35" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-35">Tiny Code</h4>
<p>Integrating MRV and LCV:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> select_unassigned_variable(assignment, variables, domains, constraints):</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># MRV</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    unassigned <span class="op">=</span> [v <span class="cf">for</span> v <span class="kw">in</span> variables <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> assignment]</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    mrv <span class="op">=</span> <span class="bu">min</span>(unassigned, key<span class="op">=</span><span class="kw">lambda</span> v: <span class="bu">len</span>(domains[v]))</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Degree tie-breaker</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    max_degree <span class="op">=</span> <span class="bu">max</span>(unassigned, key<span class="op">=</span><span class="kw">lambda</span> v: <span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> (a,b) <span class="kw">in</span> constraints <span class="cf">if</span> a<span class="op">==</span>v <span class="kw">or</span> b<span class="op">==</span>v))</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mrv <span class="cf">if</span> <span class="bu">len</span>(domains[mrv]) <span class="op">&lt;</span> <span class="bu">len</span>(domains[max_degree]) <span class="cf">else</span> max_degree</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> order_domain_values(var, domains, assignment, constraints):</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># LCV</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(domains[var], key<span class="op">=</span><span class="kw">lambda</span> val: conflicts(var, val, assignment, domains, constraints))</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> conflicts(var, val, assignment, domains, constraints):</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (x,y) <span class="kw">in</span> constraints:</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">==</span> var <span class="kw">and</span> y <span class="kw">not</span> <span class="kw">in</span> assignment:</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> v <span class="kw">in</span> domains[y] <span class="cf">if</span> v <span class="op">==</span> val)</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-35" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-35">Why It Matters</h4>
<p>Without heuristics, CSP search grows exponentially. MRV, Degree, and LCV work together to prune the space aggressively, making large-scale problems like Sudoku, scheduling, and timetabling solvable in practice.</p>
</section>
<section id="try-it-yourself-35" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-35">Try It Yourself</h4>
<ol type="1">
<li>Add MRV to your map-coloring backtracking solver. Compare the number of backtracks with a naïve variable order.</li>
<li>Extend with Degree heuristic. Does it help when maps get denser?</li>
<li>Implement LCV for Sudoku. Does it reduce search compared to random value ordering?</li>
</ol>
</section>
</section>
<section id="local-search-for-csps-min-conflicts" class="level3">
<h3 class="anchored" data-anchor-id="local-search-for-csps-min-conflicts">336. Local Search for CSPs (Min-Conflicts)</h3>
<p>Local search tackles CSPs by starting with a complete assignment (possibly inconsistent) and then iteratively repairing it. The min-conflicts heuristic chooses a variable in conflict and assigns it the value that minimizes the number of violated constraints. This method often solves large problems quickly, despite lacking systematic guarantees.</p>
<section id="picture-in-your-head-36" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-36">Picture in Your Head</h4>
<p>Think of seating guests at a wedding again. You start with everyone seated, but some conflicts remain (rivals sitting together). Instead of redoing the whole arrangement, you repeatedly move just the problematic guests to reduce the number of fights. Over time, the conflicts disappear.</p>
</section>
<section id="deep-dive-36" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-36">Deep Dive</h4>
<p>Mechanics of min-conflicts:</p>
<ol type="1">
<li><p>Begin with a random complete assignment.</p></li>
<li><p>While conflicts exist:</p>
<ul>
<li>Pick a conflicted variable.</li>
<li>Reassign it the value that causes the fewest conflicts.</li>
</ul></li>
<li><p>Stop when all constraints are satisfied or a limit is reached.</p></li>
</ol>
<p>Properties:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Characteristic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Completeness</td>
<td>No (can get stuck in local minima)</td>
</tr>
<tr class="even">
<td>Optimality</td>
<td>Not guaranteed</td>
</tr>
<tr class="odd">
<td>Time</td>
<td>Often linear in problem size (empirically efficient)</td>
</tr>
<tr class="even">
<td>Strength</td>
<td>Excels in large, loosely constrained CSPs (e.g., scheduling)</td>
</tr>
</tbody>
</table>
<p>Classic use case: solving the n-Queens problem. Min-conflicts can place thousands of queens on a chessboard with almost no backtracking.</p>
</section>
<section id="tiny-code-36" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-36">Tiny Code</h4>
<p>Min-conflicts for n-Queens:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_conflicts(n, max_steps<span class="op">=</span><span class="dv">10000</span>):</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Random initial assignment</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    queens <span class="op">=</span> [random.randint(<span class="dv">0</span>, n<span class="op">-</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> conflicts(col, row):</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">sum</span>(</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>            queens[c] <span class="op">==</span> row <span class="kw">or</span> <span class="bu">abs</span>(queens[c] <span class="op">-</span> row) <span class="op">==</span> <span class="bu">abs</span>(c <span class="op">-</span> col)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(n) <span class="cf">if</span> c <span class="op">!=</span> col</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_steps):</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>        conflicted <span class="op">=</span> [c <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(n) <span class="cf">if</span> conflicts(c, queens[c])]</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> conflicted:</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> queens</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>        col <span class="op">=</span> random.choice(conflicted)</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>        queens[col] <span class="op">=</span> <span class="bu">min</span>(<span class="bu">range</span>(n), key<span class="op">=</span><span class="kw">lambda</span> r: conflicts(col, r))</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-36" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-36">Why It Matters</h4>
<p>Local search with min-conflicts is one of the most practically effective CSP solvers. It scales where systematic backtracking would fail, and its simplicity makes it widely applicable in scheduling, planning, and optimization.</p>
</section>
<section id="try-it-yourself-36" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-36">Try It Yourself</h4>
<ol type="1">
<li>Run min-conflicts for the 8-Queens problem. How quickly does it converge?</li>
<li>Modify it for map-coloring: does it solve maps with many regions efficiently?</li>
<li>Test min-conflicts on Sudoku. Does it struggle more compared to backtracking + propagation?</li>
</ol>
</section>
</section>
<section id="complexity-of-csp-solving" class="level3">
<h3 class="anchored" data-anchor-id="complexity-of-csp-solving">337. Complexity of CSP Solving</h3>
<p>Constraint Satisfaction Problems are, in general, computationally hard. Deciding whether a CSP has a solution is NP-complete, meaning no known algorithm can solve all CSPs efficiently. However, special structures, heuristics, and propagation techniques often make real-world CSPs tractable.</p>
<section id="picture-in-your-head-37" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-37">Picture in Your Head</h4>
<p>Think of trying to schedule courses for a university. In theory, the number of possible timetables grows astronomically with courses, rooms, and times. In practice, structure (e.g., limited conflicts, departmental separations) keeps the problem solvable.</p>
</section>
<section id="deep-dive-37" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-37">Deep Dive</h4>
<ul>
<li>General CSP: NP-complete. Even binary CSPs with finite domains can encode SAT.</li>
<li>Tree-structured CSPs: solvable in linear time using arc consistency.</li>
<li>Width and decomposition: If the constraint graph has small <em>treewidth</em>, the problem is much easier.</li>
<li>Phase transitions: Random CSPs often shift from “almost always solvable” to “almost always unsolvable” at a critical constraint density.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 47%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th>CSP Type</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>General CSP</td>
<td>NP-complete</td>
</tr>
<tr class="even">
<td>Tree-structured CSP</td>
<td>Polynomial time</td>
</tr>
<tr class="odd">
<td>Bounded treewidth CSP</td>
<td>Polynomial (exponential only in width)</td>
</tr>
<tr class="even">
<td>Special cases (2-SAT, Horn clauses)</td>
<td>Polynomial</td>
</tr>
</tbody>
</table>
<p>This shows why structural analysis of constraint graphs is as important as search.</p>
</section>
<section id="tiny-code-37" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-37">Tiny Code</h4>
<p>Naïve CSP solver complexity estimation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> csp_complexity(n_vars, domain_size):</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> domain_size  n_vars  <span class="co"># worst-case possibilities</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"3 vars, domain=3:"</span>, csp_complexity(<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"10 vars, domain=3:"</span>, csp_complexity(<span class="dv">10</span>, <span class="dv">3</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Even 10 variables with domain size 3 give <span class="math inline">\(3^{10} = 59,049\)</span> possibilities—already large.</p>
</section>
<section id="why-it-matters-37" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-37">Why It Matters</h4>
<p>Understanding complexity sets realistic expectations. While CSPs can be hard in theory, practical strategies exploit structure to make them solvable. This duality—worst-case hardness vs.&nbsp;practical tractability—is central in AI problem solving.</p>
</section>
<section id="try-it-yourself-37" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-37">Try It Yourself</h4>
<ol type="1">
<li>Encode 3-SAT as a CSP and verify why it shows NP-completeness.</li>
<li>Build a tree-structured CSP and solve it with arc consistency. Compare runtime with backtracking.</li>
<li>Experiment with random CSPs of increasing density. Where does the “hardness peak” appear?</li>
</ol>
</section>
</section>
<section id="extensions-stochastic-and-dynamic-csps" class="level3">
<h3 class="anchored" data-anchor-id="extensions-stochastic-and-dynamic-csps">338. Extensions: Stochastic and Dynamic CSPs</h3>
<p>Classic CSPs assume fixed variables, domains, and constraints. In reality, uncertainty and change are common. Stochastic CSPs allow probabilistic elements in variables or constraints. Dynamic CSPs allow the problem itself to evolve over time, requiring continuous adaptation.</p>
<section id="picture-in-your-head-38" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-38">Picture in Your Head</h4>
<p>Imagine planning outdoor events. If the weather is uncertain, constraints like “must be outdoors” depend on probability (stochastic CSP). If new guests RSVP or a venue becomes unavailable, the CSP itself changes (dynamic CSP), forcing you to update assignments on the fly.</p>
</section>
<section id="deep-dive-38" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-38">Deep Dive</h4>
<ul>
<li>Stochastic CSPs: Some variables have probabilistic domains; constraints may involve probabilities of satisfaction. Goal: maximize likelihood of a consistent assignment.</li>
<li>Dynamic CSPs: Variables/constraints/domains can be added, removed, or changed. Solvers must reuse previous work instead of starting over.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 42%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Key Feature</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Stochastic CSP</td>
<td>Probabilistic variables or constraints</td>
<td>Scheduling under uncertain weather</td>
</tr>
<tr class="even">
<td>Dynamic CSP</td>
<td>Evolving structure over time</td>
<td>Real-time scheduling in manufacturing</td>
</tr>
</tbody>
</table>
<p>Techniques:</p>
<ul>
<li>For stochastic CSPs: expectimax search, probabilistic inference, scenario sampling.</li>
<li>For dynamic CSPs: incremental backtracking, maintaining arc consistency (MAC), constraint retraction.</li>
</ul>
</section>
<section id="tiny-code-38" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-38">Tiny Code</h4>
<p>Dynamic CSP update example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_csp(domains, constraints, new_constraint):</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    constraints.add(new_constraint)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># re-run consistency check</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (x,y) <span class="kw">in</span> constraints:</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> domains[x] <span class="kw">or</span> <span class="kw">not</span> domains[y]:</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: add new adjacency in map-coloring CSP</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>domains <span class="op">=</span> {<span class="st">"A"</span>: [<span class="st">"red"</span>,<span class="st">"blue"</span>], <span class="st">"B"</span>: [<span class="st">"red"</span>,<span class="st">"blue"</span>]}</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>constraints <span class="op">=</span> {(<span class="st">"A"</span>,<span class="st">"B"</span>)}</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(update_csp(domains, constraints, (<span class="st">"A"</span>,<span class="st">"C"</span>)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-38" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-38">Why It Matters</h4>
<p>Stochastic and dynamic CSPs model real-world complexity far better than static ones. They are crucial in robotics, adaptive scheduling, and planning under uncertainty, where conditions can change rapidly or outcomes are probabilistic.</p>
</section>
<section id="try-it-yourself-38" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-38">Try It Yourself</h4>
<ol type="1">
<li>Model a class-scheduling problem where classrooms may be unavailable with 10% probability. How would you encode it as a stochastic CSP?</li>
<li>Implement a dynamic CSP where tasks arrive over time. Can your solver adapt without restarting?</li>
<li>Compare static vs.&nbsp;dynamic Sudoku: how would the solver react if new numbers are revealed mid-solution?</li>
</ol>
</section>
</section>
<section id="applications-scheduling-map-coloring-sudoku" class="level3">
<h3 class="anchored" data-anchor-id="applications-scheduling-map-coloring-sudoku">339. Applications: Scheduling, Map Coloring, Sudoku</h3>
<p>Constraint Satisfaction Problems are widely applied in practical domains. Classic examples include scheduling (allocating resources across time), map coloring (graph coloring with adjacency constraints), and Sudoku (a global all-different puzzle). These cases showcase the versatility of CSPs in real-world and recreational problem solving.</p>
<section id="picture-in-your-head-39" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-39">Picture in Your Head</h4>
<p>Visualize a school schedule: teachers (variables) must be assigned to classes (domains) under constraints like “no two classes in the same room at once.” Or imagine coloring countries on a map: each region (variable) must have a color (domain) different from its neighbors. In Sudoku, every row, column, and 3×3 block must obey “all numbers different.”</p>
</section>
<section id="deep-dive-39" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-39">Deep Dive</h4>
<p>How CSPs apply to each domain:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 23%">
<col style="width: 20%">
<col style="width: 42%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Variables</th>
<th>Domains</th>
<th>Constraints</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Scheduling</td>
<td>Time slots, resources</td>
<td>Days, times, people</td>
<td>No conflicts in time or resource use</td>
</tr>
<tr class="even">
<td>Map coloring</td>
<td>Regions</td>
<td>Colors (e.g., 3–4)</td>
<td>Adjacent regions ≠ same color</td>
</tr>
<tr class="odd">
<td>Sudoku</td>
<td>81 grid cells</td>
<td>Digits 1–9</td>
<td>Rows, columns, and blocks all-different</td>
</tr>
</tbody>
</table>
<p>These applications show different constraint types:</p>
<ul>
<li>Binary constraints (map coloring adjacency).</li>
<li>Global constraints (Sudoku’s all-different).</li>
<li>Complex resource constraints (scheduling).</li>
</ul>
<p>Each requires different solving strategies, from backtracking with heuristics to constraint propagation and local search.</p>
</section>
<section id="tiny-code-39" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-39">Tiny Code</h4>
<p>Sudoku constraint check:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> valid_sudoku(board, row, col, num):</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check row</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num <span class="kw">in</span> board[row]:</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check column</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num <span class="kw">in</span> [board[r][col] <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">9</span>)]:</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check 3x3 block</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    start_r, start_c <span class="op">=</span> <span class="dv">3</span><span class="op">*</span>(row<span class="op">//</span><span class="dv">3</span>), <span class="dv">3</span><span class="op">*</span>(col<span class="op">//</span><span class="dv">3</span>)</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(start_r, start_r<span class="op">+</span><span class="dv">3</span>):</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(start_c, start_c<span class="op">+</span><span class="dv">3</span>):</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> board[r][c] <span class="op">==</span> num:</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-39" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-39">Why It Matters</h4>
<p>Scheduling optimizes resource usage, map coloring underlies many graph problems, and Sudoku illustrates the power of CSP techniques for puzzles. These examples demonstrate both the generality and practicality of CSPs across domains.</p>
</section>
<section id="try-it-yourself-39" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-39">Try It Yourself</h4>
<ol type="1">
<li>Encode exam scheduling for 3 classes with shared students. Can you find a conflict-free assignment?</li>
<li>Implement backtracking map coloring for Australia with 3 colors. Does it always succeed?</li>
<li>Use constraint propagation (AC-3) on a Sudoku puzzle. How many candidate numbers are eliminated before backtracking?</li>
</ol>
</section>
</section>
<section id="case-study-csp-solving-in-ai-planning" class="level3">
<h3 class="anchored" data-anchor-id="case-study-csp-solving-in-ai-planning">340. Case Study: CSP Solving in AI Planning</h3>
<p>AI planning can be framed as a Constraint Satisfaction Problem by treating actions, resources, and time steps as variables, and their requirements and interactions as constraints. This reformulation allows planners to leverage CSP techniques such as propagation, backtracking, and heuristics to efficiently search for valid plans.</p>
<section id="picture-in-your-head-40" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-40">Picture in Your Head</h4>
<p>Imagine scheduling a sequence of tasks for a robot: “pick up block,” “move to table,” “place block.” Each action has preconditions and effects. Represent each step as a variable, with domains being possible actions or resources. Constraints ensure that preconditions are satisfied, resources are not double-booked, and the final goal is reached.</p>
</section>
<section id="deep-dive-40" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-40">Deep Dive</h4>
<p>CSP-based planning works by:</p>
<ol type="1">
<li>Variables: represent actions at discrete time steps, or assignments of resources to tasks.</li>
<li>Domains: possible actions or resource choices.</li>
<li>Constraints: enforce logical preconditions, prevent conflicts, and ensure goals are achieved.</li>
</ol>
<p>Comparison to classical planning:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 31%">
<col style="width: 47%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>Classical Planning</th>
<th>CSP Formulation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Focus</td>
<td>Sequencing actions</td>
<td>Assigning variables</td>
</tr>
<tr class="even">
<td>Representation</td>
<td>STRIPS, PDDL operators</td>
<td>Variables + domains + constraints</td>
</tr>
<tr class="odd">
<td>Solving</td>
<td>Search in state space</td>
<td>Constraint propagation + search</td>
</tr>
</tbody>
</table>
<p>Benefits:</p>
<ul>
<li>Enables reuse of CSP solvers and propagation algorithms.</li>
<li>Can incorporate resource constraints directly.</li>
<li>Often more scalable for structured domains.</li>
</ul>
<p>Challenges:</p>
<ul>
<li>Requires discretization of time/actions.</li>
<li>Large planning horizons create very large CSPs.</li>
</ul>
</section>
<section id="tiny-code-40" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-40">Tiny Code</h4>
<p>Encoding a simplified planning CSP:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>variables <span class="op">=</span> [<span class="st">"step1"</span>, <span class="st">"step2"</span>, <span class="st">"step3"</span>]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>domains <span class="op">=</span> {</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"step1"</span>: [<span class="st">"pick_up"</span>],</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"step2"</span>: [<span class="st">"move"</span>, <span class="st">"wait"</span>],</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"step3"</span>: [<span class="st">"place"</span>]</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>constraints <span class="op">=</span> [</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"step1"</span>,<span class="st">"step2"</span>,<span class="st">"valid"</span>),</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"step2"</span>,<span class="st">"step3"</span>,<span class="st">"valid"</span>)</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_valid_plan(assignments):</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> assignments[<span class="st">"step1"</span>] <span class="op">==</span> <span class="st">"pick_up"</span> <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>           assignments[<span class="st">"step2"</span>] <span class="kw">in</span> {<span class="st">"move"</span>,<span class="st">"wait"</span>} <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>           assignments[<span class="st">"step3"</span>] <span class="op">==</span> <span class="st">"place"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-40" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-40">Why It Matters</h4>
<p>Casting planning as a CSP unifies problem solving: the same techniques used for Sudoku and scheduling can solve robotics, logistics, and workflow planning tasks. This perspective bridges logical planning and constraint-based reasoning, making AI planning more robust and versatile.</p>
</section>
<section id="try-it-yourself-40" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-40">Try It Yourself</h4>
<ol type="1">
<li>Encode a blocks-world problem as a CSP with 3 blocks and 3 steps. Can your solver find a valid sequence?</li>
<li>Extend the CSP to handle resources (e.g., only one gripper available). What new constraints are needed?</li>
<li>Compare solving time for the CSP approach vs.&nbsp;traditional state-space search. Which scales better?</li>
</ol>
</section>
</section>
</section>
<section id="chapter-5.-local-search-and-metaheuristics" class="level2">
<h2 class="anchored" data-anchor-id="chapter-5.-local-search-and-metaheuristics">Chapter 5. Local Search and Metaheuristics</h2>
<section id="hill-climbing-and-its-variants" class="level3">
<h3 class="anchored" data-anchor-id="hill-climbing-and-its-variants">342. Hill Climbing and Its Variants</h3>
<p>Hill climbing is the simplest local search method: start with a candidate solution, then repeatedly move to a better neighbor until no improvement is possible. Variants of hill climbing add randomness or allow sideways moves to escape traps.</p>
<section id="picture-in-your-head-41" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-41">Picture in Your Head</h4>
<p>Imagine hiking uphill in the fog. You always take the steepest upward path visible. You may end up on a small hill (local maximum) instead of the tallest mountain (global maximum). Variants of hill climbing add tricks like stepping sideways or occasionally going downhill to explore further.</p>
</section>
<section id="deep-dive-41" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-41">Deep Dive</h4>
<p>Hill climbing algorithm:</p>
<ol type="1">
<li>Start with a random state.</li>
<li>Evaluate its neighbors.</li>
<li>Move to the neighbor with the highest improvement.</li>
<li>Repeat until no neighbor is better.</li>
</ol>
<p>Challenges:</p>
<ul>
<li>Local maxima: getting stuck on a “small peak.”</li>
<li>Plateaus: flat regions with no direction of improvement.</li>
<li>Ridges: paths requiring zig-zagging.</li>
</ul>
<p>Variants:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 31%">
<col style="width: 41%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Variant</th>
<th>Strategy</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple hill climbing</td>
<td>Always move to a better neighbor</td>
<td>Fast, but easily stuck</td>
</tr>
<tr class="even">
<td>Steepest-ascent hill climbing</td>
<td>Pick the <em>best</em> neighbor</td>
<td>More informed, but slower</td>
</tr>
<tr class="odd">
<td>Random-restart hill climbing</td>
<td>Restart from random states</td>
<td>Escapes local maxima</td>
</tr>
<tr class="even">
<td>Sideways moves</td>
<td>Allow equal-cost steps</td>
<td>Helps cross plateaus</td>
</tr>
<tr class="odd">
<td>Stochastic hill climbing</td>
<td>Choose among improving moves at random</td>
<td>Adds diversity</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-41" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-41">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hill_climb(initial, neighbors, score, max_steps<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> initial</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_steps):</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        nbs <span class="op">=</span> neighbors(current)</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> <span class="bu">max</span>(nbs, key<span class="op">=</span>score, default<span class="op">=</span>current)</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> score(best) <span class="op">&lt;=</span> score(current):</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> current  <span class="co"># local max</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> best</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> random_restart(neighbors, score, restarts<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    best_overall <span class="op">=</span> <span class="va">None</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(restarts):</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>        initial <span class="op">=</span> neighbors(<span class="va">None</span>)[<span class="dv">0</span>]  <span class="co"># assume generator</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>        candidate <span class="op">=</span> hill_climb(initial, neighbors, score)</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> best_overall <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> score(candidate) <span class="op">&gt;</span> score(best_overall):</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>            best_overall <span class="op">=</span> candidate</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_overall</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-41" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-41">Why It Matters</h4>
<p>Hill climbing illustrates the strengths and limits of greedy local improvement. With modifications like random restarts, it becomes surprisingly powerful—able to solve large optimization problems efficiently, though without guarantees of optimality.</p>
</section>
<section id="try-it-yourself-41" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-41">Try It Yourself</h4>
<ol type="1">
<li>Implement hill climbing for the 8-Queens problem. How often does it get stuck?</li>
<li>Add sideways moves. Does it solve more instances?</li>
<li>Test random-restart hill climbing with 100 restarts. How close do solutions get to optimal?</li>
</ol>
</section>
</section>
<section id="simulated-annealing-escaping-local-optima" class="level3">
<h3 class="anchored" data-anchor-id="simulated-annealing-escaping-local-optima">343. Simulated Annealing: Escaping Local Optima</h3>
<p>Simulated annealing is a local search method that sometimes accepts worse moves to escape local optima. It is inspired by metallurgy: slowly cooling a material lets atoms settle into a low-energy, stable configuration. By controlling randomness with a “temperature” parameter, the algorithm balances exploration and exploitation.</p>
<section id="picture-in-your-head-42" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-42">Picture in Your Head</h4>
<p>Imagine climbing hills at night with a lantern. At first, you’re willing to wander randomly, even downhill, to explore the terrain. As the night wears on, you become more cautious, mostly climbing uphill and settling on the highest peak you’ve found.</p>
</section>
<section id="deep-dive-42" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-42">Deep Dive</h4>
<p>Mechanics:</p>
<ol type="1">
<li><p>Start with an initial solution.</p></li>
<li><p>At each step, pick a random neighbor.</p></li>
<li><p>If it’s better, move there.</p></li>
<li><p>If it’s worse, move there with probability:</p>
<p><span class="math display">\[
P = e^{-\Delta E / T}
\]</span></p>
<p>where <span class="math inline">\(\Delta E\)</span> is the cost increase, and <span class="math inline">\(T\)</span> is the current temperature.</p></li>
<li><p>Gradually decrease <span class="math inline">\(T\)</span> (the cooling schedule).</p></li>
</ol>
<p>Key ideas:</p>
<ul>
<li>High <span class="math inline">\(T\)</span>: many random moves, broad exploration.</li>
<li>Low <span class="math inline">\(T\)</span>: mostly greedy, focused search.</li>
<li>Cooling schedule determines balance: too fast risks premature convergence; too slow wastes time.</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Acceptance of worse moves</td>
<td>Escapes local optima</td>
</tr>
<tr class="even">
<td>Cooling schedule</td>
<td>Controls convergence quality</td>
</tr>
<tr class="odd">
<td>Final temperature</td>
<td>Determines stopping condition</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-42" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-42">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math, random</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulated_annealing(initial, neighbors, score, T<span class="op">=</span><span class="fl">1.0</span>, cooling<span class="op">=</span><span class="fl">0.99</span>, steps<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> initial</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> current</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(steps):</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> T <span class="op">&lt;=</span> <span class="fl">1e-6</span>:</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>        nxt <span class="op">=</span> random.choice(neighbors(current))</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>        delta <span class="op">=</span> score(nxt) <span class="op">-</span> score(current)</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> delta <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">or</span> random.random() <span class="op">&lt;</span> math.exp(delta <span class="op">/</span> T):</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> nxt</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> score(current) <span class="op">&gt;</span> score(best):</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> current</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>        T <span class="op">*=</span> cooling</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-42" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-42">Why It Matters</h4>
<p>Simulated annealing shows that randomness, when carefully controlled, can make local search much more powerful. It has been applied in scheduling, VLSI design, and optimization problems where deterministic greedy search fails.</p>
</section>
<section id="try-it-yourself-42" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-42">Try It Yourself</h4>
<ol type="1">
<li>Apply simulated annealing to the 8-Queens problem. How does it compare to pure hill climbing?</li>
<li>Experiment with different cooling rates (e.g., 0.99 vs 0.95). How does it affect solution quality?</li>
<li>Test on a traveling salesman problem (TSP) with 20 cities. Does annealing escape bad local tours?</li>
</ol>
</section>
</section>
<section id="genetic-algorithms-populations-and-crossover" class="level3">
<h3 class="anchored" data-anchor-id="genetic-algorithms-populations-and-crossover">344. Genetic Algorithms: Populations and Crossover</h3>
<p>Genetic algorithms (GAs) are a population-based search method inspired by natural evolution. Instead of improving a single candidate, they maintain a population of solutions that evolve through selection, crossover, and mutation. Over generations, the population tends to converge toward better solutions.</p>
<section id="picture-in-your-head-43" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-43">Picture in Your Head</h4>
<p>Imagine breeding plants. Each plant represents a solution. You select the healthiest plants, crossbreed them, and sometimes introduce random mutations. After many generations, the garden contains stronger, more adapted plants—analogous to better problem solutions.</p>
</section>
<section id="deep-dive-43" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-43">Deep Dive</h4>
<p>Main components of GAs:</p>
<ol type="1">
<li>Representation (chromosomes). typically strings, arrays, or encodings of candidate solutions.</li>
<li>Fitness function. evaluates how good a candidate is.</li>
<li>Selection. probabilistically favor fitter candidates to reproduce.</li>
<li>Crossover. combine two parent solutions to create offspring.</li>
<li>Mutation. introduce random changes to maintain diversity.</li>
</ol>
<p>Variants of crossover and mutation:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 35%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Example</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>One-point crossover</td>
<td>Swap halves of two parents</td>
<td>Combine building blocks</td>
</tr>
<tr class="even">
<td>Two-point crossover</td>
<td>Swap middle segments</td>
<td>Greater recombination</td>
</tr>
<tr class="odd">
<td>Uniform crossover</td>
<td>Randomly swap bits</td>
<td>Higher diversity</td>
</tr>
<tr class="even">
<td>Mutation</td>
<td>Flip bits, swap elements</td>
<td>Prevent premature convergence</td>
</tr>
</tbody>
</table>
<p>Properties:</p>
<ul>
<li>Exploration comes from mutation and diversity in the population.</li>
<li>Exploitation comes from selecting fitter individuals to reproduce.</li>
<li>Balancing these forces is key.</li>
</ul>
</section>
<section id="tiny-code-43" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-43">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> genetic_algorithm(population, fitness, generations<span class="op">=</span><span class="dv">100</span>, p_crossover<span class="op">=</span><span class="fl">0.8</span>, p_mutation<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(generations):</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Selection</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        parents <span class="op">=</span> random.choices(population, weights<span class="op">=</span>[fitness(ind) <span class="cf">for</span> ind <span class="kw">in</span> population], k<span class="op">=</span><span class="bu">len</span>(population))</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Crossover</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>        next_gen <span class="op">=</span> []</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(parents), <span class="dv">2</span>):</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>            p1, p2 <span class="op">=</span> parents[i], parents[(i<span class="op">+</span><span class="dv">1</span>) <span class="op">%</span> <span class="bu">len</span>(parents)]</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> random.random() <span class="op">&lt;</span> p_crossover:</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>                point <span class="op">=</span> random.randint(<span class="dv">1</span>, <span class="bu">len</span>(p1)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>                c1, c2 <span class="op">=</span> p1[:point] <span class="op">+</span> p2[point:], p2[:point] <span class="op">+</span> p1[point:]</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>                c1, c2 <span class="op">=</span> p1, p2</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>            next_gen.extend([c1, c2])</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Mutation</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ind <span class="kw">in</span> next_gen:</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> random.random() <span class="op">&lt;</span> p_mutation:</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>                idx <span class="op">=</span> random.randrange(<span class="bu">len</span>(ind))</span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>                ind <span class="op">=</span> ind[:idx] <span class="op">+</span> random.choice(<span class="st">"01"</span>) <span class="op">+</span> ind[idx<span class="op">+</span><span class="dv">1</span>:]</span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>        population <span class="op">=</span> next_gen</span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(population, key<span class="op">=</span>fitness)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-43" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-43">Why It Matters</h4>
<p>Genetic algorithms demonstrate how collective search via populations can outperform single-state methods. They’ve been applied in optimization, machine learning, design, and robotics, where the search space is too rugged for greedy or single-path exploration.</p>
</section>
<section id="try-it-yourself-43" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-43">Try It Yourself</h4>
<ol type="1">
<li>Implement a GA for the 8-Queens problem using binary encoding of queen positions.</li>
<li>Test GA on the traveling salesman problem with 10 cities. How does crossover help find shorter tours?</li>
<li>Experiment with mutation rates. Too low vs.&nbsp;too high—what happens to convergence?</li>
</ol>
</section>
</section>
<section id="tabu-search-and-memory-based-methods" class="level3">
<h3 class="anchored" data-anchor-id="tabu-search-and-memory-based-methods">345. Tabu Search and Memory-Based Methods</h3>
<p>Tabu Search is a local search method that uses memory to avoid cycling back to recently visited states. By keeping a tabu list of forbidden moves or solutions, it encourages exploration of new areas in the search space. Unlike hill climbing, which may loop endlessly, tabu search systematically pushes beyond local optima.</p>
<section id="picture-in-your-head-44" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-44">Picture in Your Head</h4>
<p>Imagine wandering a maze. Without memory, you might keep walking in circles. With a notebook of “places I just visited,” you avoid retracing your steps. This forces you to try new passages—even if they look less promising at first.</p>
</section>
<section id="deep-dive-44" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-44">Deep Dive</h4>
<p>Key features of tabu search:</p>
<ul>
<li>Tabu list: stores recently made moves or visited solutions for a fixed tenure.</li>
<li>Aspiration criterion: allows breaking tabu rules if a move yields a better solution than any seen before.</li>
<li>Neighborhood exploration: evaluates many neighbors, even worse ones, but avoids cycling.</li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Benefit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Short-term memory (tabu list)</td>
<td>Prevents cycles</td>
</tr>
<tr class="even">
<td>Aspiration</td>
<td>Keeps flexibility, avoids over-restriction</td>
</tr>
<tr class="odd">
<td>Intensification/diversification</td>
<td>Balance between exploiting good areas and exploring new ones</td>
</tr>
</tbody>
</table>
<p>Applications: scheduling, routing, and combinatorial optimization, where cycling is common.</p>
</section>
<section id="tiny-code-44" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-44">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tabu_search(initial, neighbors, score, max_iters<span class="op">=</span><span class="dv">100</span>, tabu_size<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> initial</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> current</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    tabu <span class="op">=</span> deque(maxlen<span class="op">=</span>tabu_size)</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_iters):</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>        candidate_moves <span class="op">=</span> [n <span class="cf">for</span> n <span class="kw">in</span> neighbors(current) <span class="cf">if</span> n <span class="kw">not</span> <span class="kw">in</span> tabu]</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> candidate_moves:</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>        next_state <span class="op">=</span> <span class="bu">max</span>(candidate_moves, key<span class="op">=</span>score)</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>        tabu.append(current)</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> next_state</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> score(current) <span class="op">&gt;</span> score(best):</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> current</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-44" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-44">Why It Matters</h4>
<p>Tabu search introduced the idea of structured memory into local search, which later inspired metaheuristics with adaptive memory (e.g., GRASP, scatter search). It strikes a balance between exploration and exploitation, enabling solutions to complex, rugged landscapes.</p>
</section>
<section id="try-it-yourself-44" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-44">Try It Yourself</h4>
<ol type="1">
<li>Apply tabu search to the 8-Queens problem. How does the tabu list length affect performance?</li>
<li>Use tabu search for a small traveling salesman problem (TSP). Does it avoid short cycles?</li>
<li>Experiment with aspiration: allow tabu moves if they improve the best solution so far. How does it change results?</li>
</ol>
</section>
</section>
<section id="ant-colony-optimization-and-swarm-intelligence" class="level3">
<h3 class="anchored" data-anchor-id="ant-colony-optimization-and-swarm-intelligence">346. Ant Colony Optimization and Swarm Intelligence</h3>
<p>Ant Colony Optimization (ACO) is a metaheuristic inspired by how real ants find shortest paths to food. Artificial “ants” construct solutions step by step, guided by pheromone trails (shared memory of good paths) and heuristic desirability (local information). Over time, trails on better solutions strengthen, while weaker ones evaporate, leading the colony to converge on high-quality solutions.</p>
<section id="picture-in-your-head-45" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-45">Picture in Your Head</h4>
<p>Imagine dozens of ants exploring a terrain. Each ant leaves a chemical trail. Shorter paths are traveled more often, so their pheromone trails grow stronger. Eventually, almost all ants follow the same efficient route, without central coordination.</p>
</section>
<section id="deep-dive-45" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-45">Deep Dive</h4>
<p>Key elements of ACO:</p>
<ul>
<li><p>Pheromone trails (<span class="math inline">\(\tau\)</span>): memory shared by ants, updated after solutions are built.</p></li>
<li><p>Heuristic information (<span class="math inline">\(\eta\)</span>): local desirability (e.g., inverse of distance in TSP).</p></li>
<li><p>Probabilistic choice: ants choose paths with probability proportional to <span class="math inline">\(\tau^\alpha \cdot \eta^\beta\)</span>.</p></li>
<li><p>Pheromone update:</p>
<ul>
<li>Evaporation: <span class="math inline">\(\tau \leftarrow (1-\rho)\tau\)</span> prevents unlimited growth.</li>
<li>Reinforcement: good solutions deposit more pheromone.</li>
</ul></li>
</ul>
<p>Applications:</p>
<ul>
<li>Traveling Salesman Problem (TSP)</li>
<li>Network routing</li>
<li>Scheduling</li>
<li>Resource allocation</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 36%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th>Mechanism</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Pheromone deposition</td>
<td>Encourages reuse of good paths</td>
</tr>
<tr class="even">
<td>Evaporation</td>
<td>Prevents stagnation, maintains exploration</td>
</tr>
<tr class="odd">
<td>Random proportional rule</td>
<td>Balances exploration and exploitation</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-45" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-45">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ant_colony_tsp(distances, n_ants<span class="op">=</span><span class="dv">10</span>, n_iter<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="dv">1</span>, beta<span class="op">=</span><span class="dv">2</span>, rho<span class="op">=</span><span class="fl">0.5</span>, Q<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(distances)</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    pheromone <span class="op">=</span> [[<span class="dv">1</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> prob(i, visited):</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>        denom <span class="op">=</span> <span class="bu">sum</span>((pheromone[i][j]alpha) <span class="op">*</span> ((<span class="dv">1</span><span class="op">/</span>distances[i][j])beta) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n) <span class="cf">if</span> j <span class="kw">not</span> <span class="kw">in</span> visited)</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>        probs <span class="op">=</span> []</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="kw">in</span> visited: probs.append(<span class="dv">0</span>)</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: probs.append((pheromone[i][j]alpha) <span class="op">*</span> ((<span class="dv">1</span><span class="op">/</span>distances[i][j])beta) <span class="op">/</span> denom)</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> probs</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    best_path, best_len <span class="op">=</span> <span class="va">None</span>, <span class="bu">float</span>(<span class="st">"inf"</span>)</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_iter):</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>        all_paths <span class="op">=</span> []</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_ants):</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="bu">len</span>(path) <span class="op">&lt;</span> n:</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>                i <span class="op">=</span> path[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>                j <span class="op">=</span> random.choices(<span class="bu">range</span>(n), weights<span class="op">=</span>prob(i, path))[<span class="dv">0</span>]</span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>                path.append(j)</span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>            length <span class="op">=</span> <span class="bu">sum</span>(distances[path[k]][path[(k<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n]] <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n))</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>            all_paths.append((path, length))</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> length <span class="op">&lt;</span> best_len:</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>                best_path, best_len <span class="op">=</span> path, length</span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update pheromones</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>                pheromone[i][j] <span class="op">*=</span> (<span class="dv">1</span><span class="op">-</span>rho)</span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> path, length <span class="kw">in</span> all_paths:</span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>                i, j <span class="op">=</span> path[k], path[(k<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n]</span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>                pheromone[i][j] <span class="op">+=</span> Q <span class="op">/</span> length</span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_path, best_len</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-45" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-45">Why It Matters</h4>
<p>ACO shows how simple local rules and distributed agents can solve hard optimization problems collaboratively. It is one of the most successful swarm intelligence methods and has inspired algorithms in robotics, networking, and logistics.</p>
</section>
<section id="try-it-yourself-45" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-45">Try It Yourself</h4>
<ol type="1">
<li>Run ACO on a small TSP with 5–10 cities. Does it converge on the shortest tour?</li>
<li>Experiment with different evaporation rates (<span class="math inline">\(\rho\)</span>). Too low vs.&nbsp;too high—what happens?</li>
<li>Extend ACO to job scheduling: how might pheromone trails represent task orderings?</li>
</ol>
</section>
</section>
<section id="comparative-advantages-and-limitations-of-metaheuristics" class="level3">
<h3 class="anchored" data-anchor-id="comparative-advantages-and-limitations-of-metaheuristics">347. Comparative Advantages and Limitations of Metaheuristics</h3>
<p>Metaheuristics—like hill climbing, simulated annealing, genetic algorithms, tabu search, and ant colony optimization—offer flexible strategies for tackling hard optimization problems. Each has strengths in certain settings and weaknesses in others. Comparing them helps practitioners choose the right tool for the problem.</p>
<section id="picture-in-your-head-46" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-46">Picture in Your Head</h4>
<p>Imagine a toolbox filled with different climbing gear. Some tools help you scale steep cliffs (hill climbing), some let you explore valleys before ascending (simulated annealing), some rely on teams cooperating (genetic algorithms, ant colonies), and others use memory to avoid going in circles (tabu search). No single tool works best everywhere.</p>
</section>
<section id="deep-dive-46" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-46">Deep Dive</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 30%">
<col style="width: 34%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Strengths</th>
<th>Weaknesses</th>
<th>Best Suited For</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hill climbing</td>
<td>Simple, fast, low memory</td>
<td>Gets stuck in local maxima, plateaus</td>
<td>Small or smooth landscapes</td>
</tr>
<tr class="even">
<td>Simulated annealing</td>
<td>Escapes local maxima, controlled randomness</td>
<td>Sensitive to cooling schedule, slower</td>
<td>Rugged landscapes with many traps</td>
</tr>
<tr class="odd">
<td>Genetic algorithms</td>
<td>Explore wide solution space, maintain diversity</td>
<td>Many parameters (population, crossover, mutation), convergence can stall</td>
<td>Complex combinatorial spaces, design problems</td>
</tr>
<tr class="even">
<td>Tabu search</td>
<td>Uses memory, avoids cycles</td>
<td>Needs careful tabu list design, risk of over-restriction</td>
<td>Scheduling, routing, iterative assignment</td>
</tr>
<tr class="odd">
<td>Ant colony optimization</td>
<td>Distributed, balances exploration/exploitation, good for graphs</td>
<td>Slower convergence, many parameters</td>
<td>Routing, TSP, network optimization</td>
</tr>
</tbody>
</table>
<p>Key considerations:</p>
<ul>
<li>Landscape structure: Is the search space smooth or rugged?</li>
<li>Problem size: Small vs.&nbsp;massive combinatorial domains.</li>
<li>Guarantees vs.&nbsp;speed: Need approximate fast solutions or optimal ones?</li>
<li>Implementation effort: Some methods require careful tuning.</li>
</ul>
</section>
<section id="tiny-code-46" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-46">Tiny Code</h4>
<p>Framework for comparing solvers:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_solver(solver, problem, repeats<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(repeats):</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>        sol, score <span class="op">=</span> solver(problem)</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>        results.append(score)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(results)<span class="op">/</span><span class="bu">len</span>(results), <span class="bu">min</span>(results), <span class="bu">max</span>(results)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>With this, one could plug in <code>hill_climb</code>, <code>simulated_annealing</code>, <code>genetic_algorithm</code>, etc., to compare performance on the same optimization task.</p>
</section>
<section id="why-it-matters-46" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-46">Why It Matters</h4>
<p>No metaheuristic is universally best—this is the essence of the <em>No Free Lunch Theorem</em>. Understanding trade-offs allows choosing (or hybridizing) methods that fit the structure of a problem. Many practical solvers today are hybrids, combining strengths of multiple metaheuristics.</p>
</section>
<section id="try-it-yourself-46" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-46">Try It Yourself</h4>
<ol type="1">
<li>Run hill climbing, simulated annealing, and genetic algorithms on the same TSP instance. Which converges fastest?</li>
<li>Test tabu search and ACO on a scheduling problem. Which finds better schedules?</li>
<li>Design a hybrid: e.g., use GA for exploration and local search for refinement. How does it perform?</li>
</ol>
</section>
</section>
<section id="parameter-tuning-and-convergence-issues" class="level3">
<h3 class="anchored" data-anchor-id="parameter-tuning-and-convergence-issues">348. Parameter Tuning and Convergence Issues</h3>
<p>Metaheuristics depend heavily on parameters—like cooling schedules in simulated annealing, mutation rates in genetic algorithms, tabu tenure in tabu search, or evaporation rates in ant colony optimization. Poor parameter choices can make algorithms fail to converge or converge too slowly. Effective tuning balances exploration (searching widely) and exploitation (refining good solutions).</p>
<section id="picture-in-your-head-47" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-47">Picture in Your Head</h4>
<p>Think of cooking rice. Too little water and it burns (under-exploration), too much and it becomes mushy (over-exploration). Parameters are like water and heat—you must tune them just right for the outcome to be good.</p>
</section>
<section id="deep-dive-47" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-47">Deep Dive</h4>
<p>Examples of critical parameters:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 42%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Key Parameters</th>
<th>Tuning Challenge</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simulated Annealing</td>
<td>Initial temperature, cooling rate</td>
<td>Too fast → premature convergence; too slow → wasted time</td>
</tr>
<tr class="even">
<td>Genetic Algorithms</td>
<td>Population size, crossover/mutation rates</td>
<td>Too much mutation → randomness; too little → stagnation</td>
</tr>
<tr class="odd">
<td>Tabu Search</td>
<td>Tabu list size</td>
<td>Too short → cycling; too long → misses promising moves</td>
</tr>
<tr class="even">
<td>ACO</td>
<td>α (pheromone weight), β (heuristic weight), ρ (evaporation)</td>
<td>Wrong balance → either randomness or stagnation</td>
</tr>
</tbody>
</table>
<p>Convergence issues:</p>
<ul>
<li>Premature convergence: population or search collapses too early to suboptimal solutions.</li>
<li>Divergence: excessive randomness prevents improvement.</li>
<li>Slow convergence: overly cautious settings waste computation.</li>
</ul>
<p>Strategies for tuning:</p>
<ul>
<li>Empirical testing with benchmark problems.</li>
<li>Adaptive parameters that adjust during the run.</li>
<li>Meta-optimization: use one algorithm to tune another’s parameters.</li>
</ul>
</section>
<section id="tiny-code-47" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-47">Tiny Code</h4>
<p>Adaptive cooling schedule for simulated annealing:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math, random</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> adaptive_sa(initial, neighbors, score, steps<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> initial</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> current</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> step <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, steps<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>        nxt <span class="op">=</span> random.choice(neighbors(current))</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>        delta <span class="op">=</span> score(nxt) <span class="op">-</span> score(current)</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> delta <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">or</span> random.random() <span class="op">&lt;</span> math.exp(delta <span class="op">/</span> T):</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> nxt</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> score(current) <span class="op">&gt;</span> score(best):</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> current</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># adaptive cooling: slower early, faster later</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>        T <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> math.log(step<span class="op">+</span><span class="dv">2</span>)</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-47" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-47">Why It Matters</h4>
<p>Parameter tuning often determines success or failure of metaheuristics. In real applications (e.g., scheduling factories, routing fleets), convergence speed and solution quality are critical. Adaptive and self-tuning methods are increasingly important in modern AI systems.</p>
</section>
<section id="try-it-yourself-47" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-47">Try It Yourself</h4>
<ol type="1">
<li>Experiment with mutation rates in a GA: 0.01, 0.1, 0.5. Which converges fastest on a TSP?</li>
<li>Run ACO with different evaporation rates (ρ=0.1, 0.5, 0.9). How does solution diversity change?</li>
<li>Implement adaptive mutation in GA: increase mutation when population diversity drops. Does it reduce premature convergence?</li>
</ol>
</section>
</section>
<section id="applications-in-optimization-design-routing" class="level3">
<h3 class="anchored" data-anchor-id="applications-in-optimization-design-routing">349. Applications in Optimization, Design, Routing</h3>
<p>Metaheuristics shine in domains where exact algorithms are too slow, but high-quality approximate solutions are acceptable. They are widely used in optimization (finding best values under constraints), design (searching through configurations), and routing (finding efficient paths).</p>
<section id="picture-in-your-head-48" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-48">Picture in Your Head</h4>
<p>Think of a delivery company routing hundreds of trucks daily. An exact solver might take days to find the provably optimal plan. A metaheuristic, like genetic algorithms or ant colony optimization, finds a near-optimal plan in minutes—good enough to save fuel and time.</p>
</section>
<section id="deep-dive-48" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-48">Deep Dive</h4>
<p>Examples across domains:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 44%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Problem</th>
<th>Metaheuristic Approach</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Optimization</td>
<td>Portfolio selection, job-shop scheduling</td>
<td>Simulated annealing, tabu search</td>
</tr>
<tr class="even">
<td>Design</td>
<td>Engineering structures, neural architecture search</td>
<td>Genetic algorithms, evolutionary strategies</td>
</tr>
<tr class="odd">
<td>Routing</td>
<td>Traveling salesman, vehicle routing, network routing</td>
<td>Ant colony optimization, hybrid GA + local search</td>
</tr>
</tbody>
</table>
<p>Key insight: metaheuristics adapt naturally to different problem structures because they only need a fitness function (objective evaluation), not specialized solvers.</p>
<p>Practical outcomes:</p>
<ul>
<li>In scheduling, tabu search and simulated annealing reduce makespan in manufacturing.</li>
<li>In design, evolutionary algorithms explore innovative architectures beyond human intuition.</li>
<li>In routing, ACO-inspired algorithms power packet routing in dynamic networks.</li>
</ul>
</section>
<section id="tiny-code-48" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-48">Tiny Code</h4>
<p>Applying simulated annealing to a vehicle routing subproblem:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math, random</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> route_length(route, distances):</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(distances[route[i]][route[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span><span class="bu">len</span>(route)]] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(route)))</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulated_annealing_route(cities, distances, T<span class="op">=</span><span class="fl">1.0</span>, cooling<span class="op">=</span><span class="fl">0.995</span>, steps<span class="op">=</span><span class="dv">10000</span>):</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> cities[:]</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    random.shuffle(current)</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> current[:]</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(steps):</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>        i, j <span class="op">=</span> <span class="bu">sorted</span>(random.sample(<span class="bu">range</span>(<span class="bu">len</span>(cities)), <span class="dv">2</span>))</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>        nxt <span class="op">=</span> current[:i] <span class="op">+</span> current[i:j][::<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> current[j:]</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>        delta <span class="op">=</span> route_length(current, distances) <span class="op">-</span> route_length(nxt, distances)</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> delta <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">or</span> random.random() <span class="op">&lt;</span> math.exp(delta <span class="op">/</span> T):</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> nxt</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> route_length(current, distances) <span class="op">&lt;</span> route_length(best, distances):</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> current[:]</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>        T <span class="op">*=</span> cooling</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best, route_length(best, distances)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-48" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-48">Why It Matters</h4>
<p>Optimization, design, and routing are core challenges in science, engineering, and industry. Metaheuristics provide flexible, scalable tools for problems where exact solutions are computationally infeasible but high-quality approximations are essential.</p>
</section>
<section id="try-it-yourself-48" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-48">Try It Yourself</h4>
<ol type="1">
<li>Use GA to design a symbolic regression model for fitting data. How does crossover affect accuracy?</li>
<li>Apply tabu search to job-shop scheduling with 5 jobs and 3 machines. How close is the result to optimal?</li>
<li>Run ACO on a network routing problem. How does pheromone evaporation affect adaptability to changing network loads?</li>
</ol>
</section>
</section>
<section id="case-study-metaheuristics-for-combinatorial-problems" class="level3">
<h3 class="anchored" data-anchor-id="case-study-metaheuristics-for-combinatorial-problems">350. Case Study: Metaheuristics for Combinatorial Problems</h3>
<p>Combinatorial optimization problems involve finding the best arrangement, ordering, or selection from a huge discrete space. Exact methods (like branch-and-bound or dynamic programming) often fail at scale. Metaheuristics—such as simulated annealing, genetic algorithms, tabu search, and ACO—offer practical alternatives that yield near-optimal solutions in reasonable time.</p>
<section id="picture-in-your-head-49" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-49">Picture in Your Head</h4>
<p>Imagine trying to seat 100 wedding guests so that friends sit together and enemies are apart. The number of possible seatings is astronomical. Instead of checking every arrangement, metaheuristics explore promising regions: some simulate heating and cooling metal, others breed arrangements, some avoid recent mistakes, and others follow swarm trails.</p>
</section>
<section id="deep-dive-49" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-49">Deep Dive</h4>
<p>Representative problems and metaheuristic approaches:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 33%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>Problem</th>
<th>Why It’s Hard</th>
<th>Metaheuristic Solution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Traveling Salesman (TSP)</td>
<td><span class="math inline">\(n!\)</span> possible tours</td>
<td>Simulated annealing, GA, ACO produce short tours</td>
</tr>
<tr class="even">
<td>Knapsack</td>
<td>Exponential subsets of items</td>
<td>GA with binary encoding for item selection</td>
</tr>
<tr class="odd">
<td>Graph Coloring</td>
<td>Exponential combinations of colors</td>
<td>Tabu search, min-conflicts local search</td>
</tr>
<tr class="even">
<td>Job-Shop Scheduling</td>
<td>Complex precedence/resource constraints</td>
<td>Hybrid tabu + SA optimize makespan</td>
</tr>
</tbody>
</table>
<p>Insights:</p>
<ul>
<li>Hybridization is common: local search + GA, tabu + SA, or ACO + heuristics.</li>
<li>Problem structure matters: e.g., geometric heuristics help in TSP; domain-specific encodings improve GA performance.</li>
<li>Benchmarking: standard datasets (TSPLIB, DIMACS graphs, job-shop benchmarks) are widely used to compare methods.</li>
</ul>
</section>
<section id="tiny-code-49" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-49">Tiny Code</h4>
<p>GA for knapsack (binary representation):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ga_knapsack(weights, values, capacity, n_gen<span class="op">=</span><span class="dv">100</span>, pop_size<span class="op">=</span><span class="dv">50</span>, p_mut<span class="op">=</span><span class="fl">0.05</span>):</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(weights)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    pop <span class="op">=</span> [[random.randint(<span class="dv">0</span>,<span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(pop_size)]</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fitness(ind):</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> <span class="bu">sum</span>(ind[i]<span class="op">*</span>weights[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n))</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> <span class="bu">sum</span>(ind[i]<span class="op">*</span>values[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n))</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v <span class="cf">if</span> w <span class="op">&lt;=</span> capacity <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_gen):</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>        pop <span class="op">=</span> <span class="bu">sorted</span>(pop, key<span class="op">=</span>fitness, reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>        new_pop <span class="op">=</span> pop[:pop_size<span class="op">//</span><span class="dv">2</span>]  <span class="co"># selection</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(new_pop) <span class="op">&lt;</span> pop_size:</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>            p1, p2 <span class="op">=</span> random.sample(pop[:<span class="dv">20</span>], <span class="dv">2</span>)</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>            point <span class="op">=</span> random.randint(<span class="dv">1</span>, n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>            child <span class="op">=</span> p1[:point] <span class="op">+</span> p2[point:]</span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> random.random() <span class="op">&lt;</span> p_mut:</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>                idx <span class="op">=</span> random.randrange(n)</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>                child[idx] <span class="op">^=</span> <span class="dv">1</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>            new_pop.append(child)</span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>        pop <span class="op">=</span> new_pop</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="bu">max</span>(pop, key<span class="op">=</span>fitness)</span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best, fitness(best)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-49" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-49">Why It Matters</h4>
<p>This case study shows how metaheuristics move from theory to practice, tackling NP-hard combinatorial problems that affect logistics, networks, finance, and engineering. They demonstrate AI’s pragmatic side: not always guaranteeing optimality, but producing high-quality results at scale.</p>
</section>
<section id="try-it-yourself-49" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-49">Try It Yourself</h4>
<ol type="1">
<li>Use simulated annealing to solve a 20-city TSP and compare tour length against a greedy heuristic.</li>
<li>Run the GA knapsack solver with different mutation rates. Which yields the best average performance?</li>
<li>Apply tabu search to graph coloring with 10 nodes. Does it use fewer colors than greedy coloring?</li>
</ol>
</section>
</section>
</section>
<section id="game-search-and-adversarial-planning" class="level2">
<h2 class="anchored" data-anchor-id="game-search-and-adversarial-planning">36. Game search and adversarial planning</h2>
<section id="two-player-zero-sum-games-as-search-problems" class="level3">
<h3 class="anchored" data-anchor-id="two-player-zero-sum-games-as-search-problems">351. Two-Player Zero-Sum Games as Search Problems</h3>
<p>Two-player zero-sum games, like chess or tic-tac-toe, can be modeled as search problems where players alternate turns. Each player tries to maximize their own utility while minimizing the opponent’s. Because the game is zero-sum, one player’s gain is exactly the other’s loss.</p>
<section id="picture-in-your-head-50" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-50">Picture in Your Head</h4>
<p>Think of chess as a tree. At the root is the current board. Each branch represents a possible move. Then it’s the opponent’s turn, branching again. Winning means navigating this tree to maximize your advantage while anticipating the opponent’s counter-moves.</p>
</section>
<section id="deep-dive-50" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-50">Deep Dive</h4>
<p>Game search involves:</p>
<ul>
<li>States: board positions.</li>
<li>Players: MAX (trying to maximize utility) and MIN (trying to minimize it).</li>
<li>Actions: legal moves from each state.</li>
<li>Utility function: outcome values (+1 for win, -1 for loss, 0 for draw).</li>
<li>Game tree: alternating MAX/MIN layers until terminal states.</li>
</ul>
<p>Properties of two-player zero-sum games:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Deterministic</td>
<td>No randomness in moves or outcomes (e.g., chess)</td>
</tr>
<tr class="even">
<td>Perfect information</td>
<td>Both players see the full game state</td>
</tr>
<tr class="odd">
<td>Zero-sum</td>
<td>Total payoff is fixed: one wins, the other loses</td>
</tr>
<tr class="even">
<td>Adversarial</td>
<td>Opponent actively works against your plan</td>
</tr>
</tbody>
</table>
<p>This makes them fundamentally different from single-agent search problems like navigation: players must anticipate adversaries, not just obstacles.</p>
</section>
<section id="tiny-code-50" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-50">Tiny Code</h4>
<p>Game tree structure for tic-tac-toe:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> actions(board, player):</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">9</span>) <span class="cf">if</span> board[i] <span class="op">==</span> <span class="st">" "</span>]</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> result(board, move, player):</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    new_board <span class="op">=</span> <span class="bu">list</span>(board)</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    new_board[move] <span class="op">=</span> player</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_board</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_terminal(board):</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># check win or draw</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>),(<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">6</span>),(<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">7</span>),(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">8</span>),(<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">8</span>),(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>)]</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a,b,c <span class="kw">in</span> lines:</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> board[a] <span class="op">!=</span> <span class="st">" "</span> <span class="kw">and</span> board[a] <span class="op">==</span> board[b] <span class="op">==</span> board[c]:</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">" "</span> <span class="kw">not</span> <span class="kw">in</span> board</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-50" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-50">Why It Matters</h4>
<p>Two-player zero-sum games are the foundation of adversarial search. Techniques like minimax, alpha-beta pruning, and Monte Carlo Tree Search grew from this framework. Beyond board games, the same ideas apply to security, negotiation, and competitive AI systems.</p>
</section>
<section id="try-it-yourself-50" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-50">Try It Yourself</h4>
<ol type="1">
<li>Model tic-tac-toe as a game tree. How many nodes are there at depth 2?</li>
<li>Write a utility function for connect four. What makes evaluation harder than tic-tac-toe?</li>
<li>Compare solving a puzzle (single-agent) vs.&nbsp;a game (two-agent). How do strategies differ?</li>
</ol>
</section>
</section>
<section id="minimax-algorithm-and-game-trees" class="level3">
<h3 class="anchored" data-anchor-id="minimax-algorithm-and-game-trees">352. Minimax Algorithm and Game Trees</h3>
<p>The minimax algorithm is the foundation of adversarial game search. It assumes both players play optimally: MAX tries to maximize utility, while MIN tries to minimize it. By exploring the game tree, minimax assigns values to states and backs them up from terminal positions to the root.</p>
<section id="picture-in-your-head-51" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-51">Picture in Your Head</h4>
<p>Imagine you’re playing chess. You consider a move, then imagine your opponent’s best counter, then your best reply, and so on. The minimax algorithm formalizes this back-and-forth reasoning: “I’ll make the move that leaves me the best worst-case outcome.”</p>
</section>
<section id="deep-dive-51" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-51">Deep Dive</h4>
<p>Steps of minimax:</p>
<ol type="1">
<li><p>Generate the game tree up to a certain depth (or until terminal states).</p></li>
<li><p>Assign utility values to terminal states.</p></li>
<li><p>Propagate values upward:</p>
<ul>
<li>At MAX nodes, choose the child with the maximum value.</li>
<li>At MIN nodes, choose the child with the minimum value.</li>
</ul></li>
</ol>
<p>Properties:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Property</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Optimality</td>
<td>Guarantees best play if tree is fully explored</td>
</tr>
<tr class="even">
<td>Completeness</td>
<td>Complete for finite games</td>
</tr>
<tr class="odd">
<td>Complexity</td>
<td>Time: <span class="math inline">\(O(b^m)\)</span>, Space: <span class="math inline">\(O(m)\)</span></td>
</tr>
<tr class="even">
<td>Parameters</td>
<td><span class="math inline">\(b\)</span> = branching factor, <span class="math inline">\(m\)</span> = depth</td>
</tr>
</tbody>
</table>
<p>Because the full tree is often too large, minimax is combined with depth limits and heuristic evaluation functions.</p>
</section>
<section id="tiny-code-51" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-51">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimax(board, depth, maximizing, eval_fn):</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> depth <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> is_terminal(board):</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> eval_fn(board)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> maximizing:</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> <span class="bu">float</span>(<span class="st">"-inf"</span>)</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> move <span class="kw">in</span> actions(board, <span class="st">"X"</span>):</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>            new_board <span class="op">=</span> result(board, move, <span class="st">"X"</span>)</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>            value <span class="op">=</span> <span class="bu">max</span>(value, minimax(new_board, depth<span class="op">-</span><span class="dv">1</span>, <span class="va">False</span>, eval_fn))</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> value</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> <span class="bu">float</span>(<span class="st">"inf"</span>)</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> move <span class="kw">in</span> actions(board, <span class="st">"O"</span>):</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>            new_board <span class="op">=</span> result(board, move, <span class="st">"O"</span>)</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>            value <span class="op">=</span> <span class="bu">min</span>(value, minimax(new_board, depth<span class="op">-</span><span class="dv">1</span>, <span class="va">True</span>, eval_fn))</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> value</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-51" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-51">Why It Matters</h4>
<p>Minimax captures the essence of adversarial reasoning: plan for the best possible outcome assuming the opponent also plays optimally. It’s the backbone of many AI game-playing agents, from tic-tac-toe to chess engines (with optimizations).</p>
</section>
<section id="try-it-yourself-51" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-51">Try It Yourself</h4>
<ol type="1">
<li>Implement minimax for tic-tac-toe and play against it. Is it unbeatable?</li>
<li>For a depth-limited minimax in connect four, design a heuristic evaluation (e.g., number of possible lines).</li>
<li>Measure how runtime grows with depth—why does branching factor matter so much?</li>
</ol>
</section>
</section>
<section id="alpha-beta-pruning-and-efficiency-gains" class="level3">
<h3 class="anchored" data-anchor-id="alpha-beta-pruning-and-efficiency-gains">353. Alpha-Beta Pruning and Efficiency Gains</h3>
<p>Alpha-Beta pruning is an optimization of minimax that reduces the number of nodes evaluated in a game tree. It prunes branches that cannot possibly influence the final decision, while still guaranteeing the same result as full minimax. This makes deep game search feasible in practice.</p>
<section id="picture-in-your-head-52" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-52">Picture in Your Head</h4>
<p>Imagine reading a choose-your-own-adventure book. At one point, you realize no matter what path a branch offers, it will lead to outcomes worse than a path you already found. You stop reading that branch entirely—saving time without changing your decision.</p>
</section>
<section id="deep-dive-52" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-52">Deep Dive</h4>
<p>Alpha-Beta works by maintaining two values:</p>
<ul>
<li>Alpha (α): the best value found so far for MAX.</li>
<li>Beta (β): the best value found so far for MIN. If at any point α ≥ β, the current branch can be pruned.</li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Correctness</td>
<td>Returns same value as minimax</td>
</tr>
<tr class="even">
<td>Best case</td>
<td>Reduces time complexity to <span class="math inline">\(O(b^{m/2})\)</span></td>
</tr>
<tr class="odd">
<td>Worst case</td>
<td>Still <span class="math inline">\(O(b^m)\)</span>, but with no wasted work</td>
</tr>
<tr class="even">
<td>Dependency</td>
<td>Order of node expansion matters greatly</td>
</tr>
</tbody>
</table>
<p>Practical impact: chess programs can search twice as deep with alpha-beta compared to raw minimax.</p>
</section>
<section id="tiny-code-52" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-52">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> alphabeta(board, depth, alpha, beta, maximizing, eval_fn):</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> depth <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> is_terminal(board):</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> eval_fn(board)</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> maximizing:</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> <span class="bu">float</span>(<span class="st">"-inf"</span>)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> move <span class="kw">in</span> actions(board, <span class="st">"X"</span>):</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>            new_board <span class="op">=</span> result(board, move, <span class="st">"X"</span>)</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>            value <span class="op">=</span> <span class="bu">max</span>(value, alphabeta(new_board, depth<span class="op">-</span><span class="dv">1</span>, alpha, beta, <span class="va">False</span>, eval_fn))</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>            alpha <span class="op">=</span> <span class="bu">max</span>(alpha, value)</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> alpha <span class="op">&gt;=</span> beta:  <span class="co"># prune</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> value</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> <span class="bu">float</span>(<span class="st">"inf"</span>)</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> move <span class="kw">in</span> actions(board, <span class="st">"O"</span>):</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>            new_board <span class="op">=</span> result(board, move, <span class="st">"O"</span>)</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>            value <span class="op">=</span> <span class="bu">min</span>(value, alphabeta(new_board, depth<span class="op">-</span><span class="dv">1</span>, alpha, beta, <span class="va">True</span>, eval_fn))</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>            beta <span class="op">=</span> <span class="bu">min</span>(beta, value)</span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> beta <span class="op">&lt;=</span> alpha:  <span class="co"># prune</span></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> value</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-52" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-52">Why It Matters</h4>
<p>Alpha-Beta pruning made adversarial search practical for complex games like chess, where branching factors are large. By avoiding useless exploration, it enables deeper search with the same resources, directly powering competitive AI systems.</p>
</section>
<section id="try-it-yourself-52" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-52">Try It Yourself</h4>
<ol type="1">
<li>Compare node counts between minimax and alpha-beta for tic-tac-toe at depth 5.</li>
<li>Experiment with move ordering: does searching best moves first lead to more pruning?</li>
<li>In connect four, measure how alpha-beta allows deeper searches within the same runtime.</li>
</ol>
</section>
</section>
<section id="heuristic-evaluation-functions-for-games" class="level3">
<h3 class="anchored" data-anchor-id="heuristic-evaluation-functions-for-games">354. Heuristic Evaluation Functions for Games</h3>
<p>In large games like chess or Go, searching the full game tree is impossible. Instead, search is cut off at a depth limit, and a heuristic evaluation function estimates how good a non-terminal state is. The quality of this function largely determines the strength of the game-playing agent.</p>
<section id="picture-in-your-head-53" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-53">Picture in Your Head</h4>
<p>Imagine stopping a chess game midway and asking, “Who’s winning?” You can’t see the final outcome, but you can guess by counting material (pieces), board control, or king safety. That “guess” is the evaluation function in action.</p>
</section>
<section id="deep-dive-53" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-53">Deep Dive</h4>
<p>Evaluation functions map board states to numerical scores:</p>
<ul>
<li>Positive = advantage for MAX.</li>
<li>Negative = advantage for MIN.</li>
<li>Zero = roughly equal.</li>
</ul>
<p>Common design elements:</p>
<ul>
<li>Material balance (chess: piece values like pawn=1, knight=3, rook=5).</li>
<li>Positional features (mobility, center control, king safety).</li>
<li>Potential threats (open lines, near-winning conditions).</li>
</ul>
<p>Trade-offs:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Simplicity</th>
<th>Fast evaluation, weaker play</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Complexity</td>
<td>Stronger play, but higher cost</td>
</tr>
</tbody>
</table>
<p>In many systems, evaluation is a weighted sum:</p>
<p><span class="math display">\[
Eval(state) = w_1 f_1(state) + w_2 f_2(state) + \dots + w_n f_n(state)
\]</span></p>
<p>Weights <span class="math inline">\(w_i\)</span> are tuned manually or learned from data.</p>
</section>
<section id="tiny-code-53" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-53">Tiny Code</h4>
<p>Chess-like evaluation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>piece_values <span class="op">=</span> {<span class="st">"P"</span>:<span class="dv">1</span>, <span class="st">"N"</span>:<span class="dv">3</span>, <span class="st">"B"</span>:<span class="dv">3</span>, <span class="st">"R"</span>:<span class="dv">5</span>, <span class="st">"Q"</span>:<span class="dv">9</span>, <span class="st">"K"</span>:<span class="dv">1000</span>,</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>                <span class="st">"p"</span>:<span class="op">-</span><span class="dv">1</span>, <span class="st">"n"</span>:<span class="op">-</span><span class="dv">3</span>, <span class="st">"b"</span>:<span class="op">-</span><span class="dv">3</span>, <span class="st">"r"</span>:<span class="op">-</span><span class="dv">5</span>, <span class="st">"q"</span>:<span class="op">-</span><span class="dv">9</span>, <span class="st">"k"</span>:<span class="op">-</span><span class="dv">1000</span>}</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> eval_board(board):</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(piece_values.get(square,<span class="dv">0</span>) <span class="cf">for</span> square <span class="kw">in</span> board)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-53" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-53">Why It Matters</h4>
<p>Without evaluation functions, minimax or alpha-beta is useless in large games. Good heuristics allow competitive play without exhaustive search. In modern systems, neural networks have replaced hand-crafted evaluations, but the principle is unchanged: approximate “goodness” guides partial search.</p>
</section>
<section id="try-it-yourself-53" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-53">Try It Yourself</h4>
<ol type="1">
<li>Write an evaluation function for tic-tac-toe that counts potential winning lines.</li>
<li>Extend connect four evaluation with features like center column bonus.</li>
<li>Experiment with weighting piece values differently in chess. How does it change play style?</li>
</ol>
</section>
</section>
<section id="iterative-deepening-and-real-time-constraints" class="level3">
<h3 class="anchored" data-anchor-id="iterative-deepening-and-real-time-constraints">355. Iterative Deepening and Real-Time Constraints</h3>
<p>Iterative deepening is a strategy that repeatedly applies depth-limited search, increasing the depth one level at a time. In adversarial games, it is combined with alpha-beta pruning and heuristic evaluation. This allows game-playing agents to always have the best move found so far, even if time runs out.</p>
<section id="picture-in-your-head-54" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-54">Picture in Your Head</h4>
<p>Imagine solving a puzzle under a strict timer. You first look just one move ahead and note the best option. Then you look two moves ahead, then three, and so on. If the clock suddenly stops, you can still act based on the deepest analysis completed.</p>
</section>
<section id="deep-dive-54" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-54">Deep Dive</h4>
<p>Key mechanics:</p>
<ul>
<li>Depth-limited search ensures the algorithm doesn’t blow up computationally.</li>
<li>Iterative deepening repeats search at depths 1, 2, 3, … until time is exhausted.</li>
<li>Move ordering benefits from previous iterations: best moves found at shallow depths are explored first at deeper levels.</li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Anytime behavior</td>
<td>Always returns the best move so far</td>
</tr>
<tr class="even">
<td>Completeness</td>
<td>Guaranteed if time is unbounded</td>
</tr>
<tr class="odd">
<td>Optimality</td>
<td>Preserved with minimax + alpha-beta</td>
</tr>
<tr class="even">
<td>Efficiency</td>
<td>Slight overhead but major pruning benefits</td>
</tr>
</tbody>
</table>
<p>This approach is standard in competitive chess engines.</p>
</section>
<section id="tiny-code-54" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-54">Tiny Code</h4>
<p>Simplified iterative deepening with alpha-beta:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iterative_deepening(board, eval_fn, max_time<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> time.time()</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    best_move <span class="op">=</span> <span class="va">None</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    depth <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> time.time() <span class="op">-</span> start <span class="op">&lt;</span> max_time:</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>        move, value <span class="op">=</span> search_depth(board, depth, eval_fn)</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>        best_move <span class="op">=</span> move</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>        depth <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_move</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> search_depth(board, depth, eval_fn):</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>    best_val, best_move <span class="op">=</span> <span class="bu">float</span>(<span class="st">"-inf"</span>), <span class="va">None</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> move <span class="kw">in</span> actions(board, <span class="st">"X"</span>):</span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>        new_board <span class="op">=</span> result(board, move, <span class="st">"X"</span>)</span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> alphabeta(new_board, depth<span class="op">-</span><span class="dv">1</span>, <span class="bu">float</span>(<span class="st">"-inf"</span>), <span class="bu">float</span>(<span class="st">"inf"</span>), <span class="va">False</span>, eval_fn)</span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> val <span class="op">&gt;</span> best_val:</span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a>            best_val, best_move <span class="op">=</span> val, move</span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_move, best_val</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-54" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-54">Why It Matters</h4>
<p>Real-time constraints are unavoidable in games and many AI systems. Iterative deepening provides robustness: agents don’t fail catastrophically if interrupted, and deeper searches benefit from earlier results. This makes it the default strategy in real-world adversarial search.</p>
</section>
<section id="try-it-yourself-54" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-54">Try It Yourself</h4>
<ol type="1">
<li>Implement iterative deepening minimax for tic-tac-toe. Stop after 2 seconds. Does it still play optimally?</li>
<li>Measure how move ordering from shallow searches improves alpha-beta pruning at deeper levels.</li>
<li>Apply iterative deepening to connect four with a 5-second limit. How deep can you search?</li>
</ol>
</section>
</section>
<section id="chance-nodes-and-stochastic-games" class="level3">
<h3 class="anchored" data-anchor-id="chance-nodes-and-stochastic-games">356. Chance Nodes and Stochastic Games</h3>
<p>Many games and decision problems involve randomness—dice rolls, shuffled cards, or uncertain outcomes. These are modeled using chance nodes in the game tree. Instead of MAX or MIN choosing the move, nature determines the outcome with given probabilities. Solving such games requires computing expected utilities rather than pure minimax.</p>
<section id="picture-in-your-head-55" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-55">Picture in Your Head</h4>
<p>Think of backgammon: you can plan moves, but dice rolls add uncertainty. The game tree isn’t just you vs.&nbsp;the opponent—it also includes dice-roll nodes where chance decides the path.</p>
</section>
<section id="deep-dive-55" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-55">Deep Dive</h4>
<p>Chance nodes extend minimax to expectiminimax:</p>
<ul>
<li><p>MAX nodes: choose the move maximizing value.</p></li>
<li><p>MIN nodes: opponent chooses the move minimizing value.</p></li>
<li><p>Chance nodes: outcome chosen probabilistically; value is the expectation:</p>
<p><span class="math display">\[
V(s) = \sum_{i} P(i) \cdot V(result(s,i))
\]</span></p></li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Node Type</th>
<th>Decision Rule</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MAX</td>
<td>Choose highest-value child</td>
</tr>
<tr class="even">
<td>MIN</td>
<td>Choose lowest-value child</td>
</tr>
<tr class="odd">
<td>Chance</td>
<td>Weighted average by probabilities</td>
</tr>
</tbody>
</table>
<p>Complexity increases because branching factors grow with possible random outcomes. Backgammon, for example, has 21 possible dice roll results at each chance node.</p>
</section>
<section id="tiny-code-55" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-55">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> expectiminimax(state, depth, player, eval_fn):</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> depth <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> is_terminal(state):</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> eval_fn(state)</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> player <span class="op">==</span> <span class="st">"MAX"</span>:</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(expectiminimax(result(state, a), depth<span class="op">-</span><span class="dv">1</span>, <span class="st">"MIN"</span>, eval_fn)</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>                   <span class="cf">for</span> a <span class="kw">in</span> actions(state, <span class="st">"MAX"</span>))</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> player <span class="op">==</span> <span class="st">"MIN"</span>:</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">min</span>(expectiminimax(result(state, a), depth<span class="op">-</span><span class="dv">1</span>, <span class="st">"MAX"</span>, eval_fn)</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>                   <span class="cf">for</span> a <span class="kw">in</span> actions(state, <span class="st">"MIN"</span>))</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:  <span class="co"># Chance node</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">sum</span>(p <span class="op">*</span> expectiminimax(result(state, outcome), depth<span class="op">-</span><span class="dv">1</span>, <span class="st">"MAX"</span>, eval_fn)</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>                   <span class="cf">for</span> outcome, p <span class="kw">in</span> chance_outcomes(state))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-55" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-55">Why It Matters</h4>
<p>Stochastic games like backgammon, card games, and real-world planning under uncertainty require reasoning about probabilities. Expectiminimax provides the theoretical framework, and modern variants power stochastic planning, gambling AI, and decision-making in noisy environments.</p>
</section>
<section id="try-it-yourself-55" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-55">Try It Yourself</h4>
<ol type="1">
<li>Extend tic-tac-toe with a random chance that moves fail 10% of the time. Model it with chance nodes.</li>
<li>Implement expectiminimax for a simple dice game. Compare outcomes with deterministic minimax.</li>
<li>Explore backgammon: how does randomness change strategy compared to chess?</li>
</ol>
</section>
</section>
<section id="multi-player-and-non-zero-sum-games" class="level3">
<h3 class="anchored" data-anchor-id="multi-player-and-non-zero-sum-games">357. Multi-Player and Non-Zero-Sum Games</h3>
<p>Not all games are two-player and zero-sum. Some involve three or more players, while others are non-zero-sum, meaning players’ gains are not perfectly opposed. In these settings, minimax is insufficient—agents must reason about coalitions, fairness, or equilibria.</p>
<section id="picture-in-your-head-56" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-56">Picture in Your Head</h4>
<p>Imagine three kids dividing candy. If one takes more, the others may ally temporarily. Unlike chess, where one player’s win is the other’s loss, multi-player games allow cooperation, negotiation, and outcomes where everyone benefits—or suffers.</p>
</section>
<section id="deep-dive-56" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-56">Deep Dive</h4>
<p>Extensions of adversarial search:</p>
<ul>
<li>Multi-player games: values are vectors of utilities, one per player. Algorithms generalize minimax (e.g., max-n algorithm).</li>
<li>Non-zero-sum games: utility sums are not fixed; strategies may allow mutual benefit. Nash equilibrium concepts often apply.</li>
<li>Coalitions: players may form temporary alliances, complicating search and evaluation.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 32%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>Game Type</th>
<th>Example</th>
<th>Solution Concept</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Two-player zero-sum</td>
<td>Chess</td>
<td>Minimax</td>
</tr>
<tr class="even">
<td>Multi-player</td>
<td>3-player tic-tac-toe</td>
<td>Max-n algorithm</td>
</tr>
<tr class="odd">
<td>Non-zero-sum</td>
<td>Prisoner’s dilemma, poker</td>
<td>Nash equilibrium, mixed strategies</td>
</tr>
</tbody>
</table>
<p>Challenges:</p>
<ul>
<li>Explosion of complexity with more players.</li>
<li>Unpredictable strategies due to shifting alliances.</li>
<li>Evaluation functions must capture multi-objective trade-offs.</li>
</ul>
</section>
<section id="tiny-code-56" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-56">Tiny Code</h4>
<p>Sketch of max-n for 3 players:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_n(state, depth, player, eval_fn, n_players):</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> depth <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> is_terminal(state):</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> eval_fn(state)  <span class="co"># returns utility vector [u1, u2, u3]</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    best_val <span class="op">=</span> <span class="va">None</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> action <span class="kw">in</span> actions(state, player):</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>        new_state <span class="op">=</span> result(state, action, player)</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> max_n(new_state, depth<span class="op">-</span><span class="dv">1</span>, (player<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n_players, eval_fn, n_players)</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> best_val <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> val[player] <span class="op">&gt;</span> best_val[player]:</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>            best_val <span class="op">=</span> val</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_val</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-56" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-56">Why It Matters</h4>
<p>Many real-world situations—auctions, negotiations, economics—are multi-player and non-zero-sum. Extending adversarial search beyond minimax allows AI to model cooperation, competition, and mixed incentives, essential for realistic multi-agent systems.</p>
</section>
<section id="try-it-yourself-56" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-56">Try It Yourself</h4>
<ol type="1">
<li>Modify tic-tac-toe for 3 players. How does strategy shift when two players can block the leader?</li>
<li>Implement the prisoner’s dilemma payoff matrix. What happens if agents use minimax vs.&nbsp;equilibrium reasoning?</li>
<li>Simulate a resource allocation game with 3 players. Can coalitions emerge naturally in your algorithm?</li>
</ol>
</section>
</section>
<section id="monte-carlo-tree-search-mcts" class="level3">
<h3 class="anchored" data-anchor-id="monte-carlo-tree-search-mcts">358. Monte Carlo Tree Search (MCTS)</h3>
<p>Monte Carlo Tree Search is a best-first search method that uses random simulations to evaluate moves. Instead of fully expanding the game tree, MCTS balances exploration (trying unvisited moves) and exploitation (focusing on promising moves). It became famous as the backbone of Go-playing programs before deep learning enhancements like AlphaGo.</p>
<section id="picture-in-your-head-57" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-57">Picture in Your Head</h4>
<p>Imagine deciding which restaurant to try in a new city. You randomly sample a few, then go back to the better ones more often, gradually refining your preferences. Over time, you build confidence in which choices are best without trying every option.</p>
</section>
<section id="deep-dive-57" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-57">Deep Dive</h4>
<p>MCTS has four main steps:</p>
<ol type="1">
<li>Selection: traverse the tree from root to leaf using a policy like UCB1 (upper confidence bound).</li>
<li>Expansion: add a new node (unexplored move).</li>
<li>Simulation: play random moves until the game ends.</li>
<li>Backpropagation: update win statistics along the path.</li>
</ol>
<p>Mathematical rule for selection (UCT):</p>
<p><span class="math display">\[
UCB = \frac{w_i}{n_i} + C \sqrt{\frac{\ln N}{n_i}}
\]</span></p>
<ul>
<li><span class="math inline">\(w_i\)</span>: wins from node <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(n_i\)</span>: visits to node <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(N\)</span>: visits to parent node</li>
<li><span class="math inline">\(C\)</span>: exploration parameter</li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 47%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th>Strength</th>
<th>Limitation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Works well without heuristics</td>
<td>Slow if simulations are poor</td>
</tr>
<tr class="even">
<td>Anytime algorithm</td>
<td>Needs many rollouts for strong play</td>
</tr>
<tr class="odd">
<td>Scales to large branching factors</td>
<td>Pure randomness limits depth insight</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-57" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-57">Tiny Code</h4>
<p>Skeleton of MCTS:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math, random</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node:</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, state, parent<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state <span class="op">=</span> state</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> parent</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.visits <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.wins <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ucb(node, C<span class="op">=</span><span class="fl">1.4</span>):</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> node.visits <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="bu">float</span>(<span class="st">"inf"</span>)</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (node.wins <span class="op">/</span> node.visits) <span class="op">+</span> C <span class="op">*</span> math.sqrt(math.log(node.parent.visits) <span class="op">/</span> node.visits)</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mcts(root, iterations, eval_fn):</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(iterations):</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> root</span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Selection</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node.children:</span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="bu">max</span>(node.children, key<span class="op">=</span>ucb)</span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Expansion</span></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> is_terminal(node.state):</span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> move <span class="kw">in</span> actions(node.state):</span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>                node.children.append(Node(result(node.state, move), node))</span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> random.choice(node.children)</span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simulation</span></span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>        outcome <span class="op">=</span> rollout(node.state, eval_fn)</span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Backpropagation</span></span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node:</span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a>            node.visits <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a>            node.wins <span class="op">+=</span> outcome</span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.parent</span>
<span id="cb59-33"><a href="#cb59-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(root.children, key<span class="op">=</span><span class="kw">lambda</span> c: c.visits)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-57" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-57">Why It Matters</h4>
<p>MCTS revolutionized AI for complex games like Go, where heuristic evaluation was difficult. It demonstrates how sampling and probability can replace exhaustive search, paving the way for hybrid methods combining MCTS with neural networks in modern game AI.</p>
</section>
<section id="try-it-yourself-57" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-57">Try It Yourself</h4>
<ol type="1">
<li>Implement MCTS for tic-tac-toe. How strong is it compared to minimax?</li>
<li>Increase simulation count per move. How does strength improve?</li>
<li>Apply MCTS to connect four with limited rollouts. Does it outperform alpha-beta at shallow depths?</li>
</ol>
</section>
</section>
<section id="applications-chess-go-and-real-time-strategy-games" class="level3">
<h3 class="anchored" data-anchor-id="applications-chess-go-and-real-time-strategy-games">359. Applications: Chess, Go, and Real-Time Strategy Games</h3>
<p>Game search methods—from minimax and alpha-beta pruning to Monte Carlo Tree Search (MCTS)—have powered some of the most famous AI milestones. Different games pose different challenges: chess emphasizes depth and tactical calculation, Go requires handling enormous branching factors with subtle evaluation, and real-time strategy (RTS) games demand fast decisions under uncertainty.</p>
<section id="picture-in-your-head-58" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-58">Picture in Your Head</h4>
<p>Think of three arenas: in chess, the AI carefully plans deep combinations; in Go, it spreads its attention broadly across a vast board; in RTS games like StarCraft, it juggles thousands of units in real time while the clock ticks relentlessly. Each requires adapting core search principles.</p>
</section>
<section id="deep-dive-58" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-58">Deep Dive</h4>
<ul>
<li><p>Chess:</p>
<ul>
<li>Branching factor ~35.</li>
<li>Deep search with alpha-beta pruning and strong heuristics (material, position).</li>
<li>Iterative deepening ensures robust real-time play.</li>
</ul></li>
<li><p>Go:</p>
<ul>
<li>Branching factor ~250.</li>
<li>Heuristic evaluation extremely hard (patterns subtle).</li>
<li>MCTS became dominant, later combined with deep neural networks (AlphaGo).</li>
</ul></li>
<li><p>RTS Games:</p>
<ul>
<li>Huge state spaces (thousands of units, continuous time).</li>
<li>Imperfect information (fog of war).</li>
<li>Use abstractions, hierarchical planning, and time-bounded anytime algorithms.</li>
</ul></li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 44%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Game</th>
<th>Main Challenge</th>
<th>Successful Approach</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chess</td>
<td>Deep tactical combinations</td>
<td>Alpha-beta + heuristics</td>
</tr>
<tr class="even">
<td>Go</td>
<td>Massive branching, weak heuristics</td>
<td>MCTS + neural guidance</td>
</tr>
<tr class="odd">
<td>RTS (StarCraft)</td>
<td>Real-time, partial info, huge state</td>
<td>Abstractions + anytime search</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-58" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-58">Tiny Code</h4>
<p>Skeleton for applying MCTS to a generic game:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> play_with_mcts(state, iterations, eval_fn):</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> Node(state)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    best_child <span class="op">=</span> mcts(root, iterations, eval_fn)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_child.state</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You would plug in domain-specific <code>actions</code>, <code>result</code>, and <code>rollout</code> functions for chess, Go, or RTS.</p>
</section>
<section id="why-it-matters-58" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-58">Why It Matters</h4>
<p>Applications of game search illustrate the adaptability of AI methods. From Deep Blue’s chess victory to AlphaGo’s breakthrough in Go and modern RTS bots, search combined with heuristics or learning has been central to AI progress. These cases also serve as testbeds for broader AI research.</p>
</section>
<section id="try-it-yourself-58" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-58">Try It Yourself</h4>
<ol type="1">
<li>Implement alpha-beta chess AI limited to depth 3. How strong is it against a random mover?</li>
<li>Use MCTS for a 9x9 Go board. Does performance improve with more simulations?</li>
<li>Try a simplified RTS scenario (e.g., resource gathering). Can you design an anytime planner that keeps units active while searching?</li>
</ol>
</section>
</section>
<section id="case-study-modern-game-ai-systems" class="level3">
<h3 class="anchored" data-anchor-id="case-study-modern-game-ai-systems">360. Case Study: Modern Game AI Systems</h3>
<p>Modern game AI blends classical search with machine learning to achieve superhuman performance. Systems like Deep Blue, AlphaGo, and AlphaZero illustrate an evolution: from handcrafted evaluation and alpha-beta pruning, to Monte Carlo rollouts, to deep neural networks guiding search.</p>
<section id="picture-in-your-head-59" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-59">Picture in Your Head</h4>
<p>Picture three AI engines sitting at a table: Deep Blue calculating millions of chess positions per second, AlphaGo sampling countless Go rollouts, and AlphaZero quietly learning strategy by playing itself millions of times. Each uses search, but in very different ways.</p>
</section>
<section id="deep-dive-59" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-59">Deep Dive</h4>
<ul>
<li><p>Deep Blue (1997):</p>
<ul>
<li>Relied on brute-force alpha-beta search with pruning.</li>
<li>Handcrafted evaluation: material balance, king safety, positional features.</li>
<li>Hardware acceleration for massive search depth (~200 million positions/second).</li>
</ul></li>
<li><p>AlphaGo (2016):</p>
<ul>
<li>Combined MCTS with policy/value neural networks.</li>
<li>Policy net guided move selection; value net evaluated positions.</li>
<li>Defeated top human Go players.</li>
</ul></li>
<li><p>AlphaZero (2017):</p>
<ul>
<li>Generalized version trained via self-play reinforcement learning.</li>
<li>Unified framework for chess, Go, shogi.</li>
<li>Demonstrated that raw search guided by learned evaluation outperforms handcrafted heuristics.</li>
</ul></li>
</ul>
<p>Comparison of paradigms:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 13%">
<col style="width: 40%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th>System</th>
<th>Search Core</th>
<th>Knowledge Source</th>
<th>Strength</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Deep Blue</td>
<td>Alpha-beta</td>
<td>Human-designed heuristics</td>
<td>Brute-force depth</td>
</tr>
<tr class="even">
<td>AlphaGo</td>
<td>MCTS</td>
<td>Learned policy &amp; value nets</td>
<td>Balance of search + learning</td>
</tr>
<tr class="odd">
<td>AlphaZero</td>
<td>MCTS</td>
<td>Self-play reinforcement learning</td>
<td>Generality &amp; adaptability</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-59" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-59">Tiny Code</h4>
<p>Hybrid MCTS + evaluation (AlphaZero-style):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> guided_mcts(root, iterations, policy_net, value_net):</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(iterations):</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> root</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Selection</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node.children:</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="bu">max</span>(node.children, key<span class="op">=</span><span class="kw">lambda</span> c: ucb_score(c))</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Expansion</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> is_terminal(node.state):</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> move <span class="kw">in</span> actions(node.state):</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>                prob <span class="op">=</span> policy_net(node.state, move)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>                node.children.append(Node(result(node.state, move), node, prior<span class="op">=</span>prob))</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> random.choice(node.children)</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simulation replaced by value net</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>        outcome <span class="op">=</span> value_net(node.state)</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Backpropagation</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node:</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>            node.visits <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>            node.value_sum <span class="op">+=</span> outcome</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.parent</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(root.children, key<span class="op">=</span><span class="kw">lambda</span> c: c.visits)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-59" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-59">Why It Matters</h4>
<p>This case study shows how search has evolved: from brute force + human heuristics, to sampling-based approaches, to learning-driven systems that generalize across domains. Modern game AI has become a proving ground for techniques that later influence robotics, planning, and real-world decision-making.</p>
</section>
<section id="try-it-yourself-59" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-59">Try It Yourself</h4>
<ol type="1">
<li>Implement alpha-beta with a simple heuristic and compare it to random play in chess.</li>
<li>Replace rollouts in your MCTS tic-tac-toe agent with a simple evaluation function. Does it improve strength?</li>
<li>Design a toy AlphaZero: train a small neural net to guide MCTS in connect four. Does performance improve after self-play?</li>
</ol>
</section>
</section>
</section>
<section id="chapter-37.-planning-in-determistic-domains" class="level2">
<h2 class="anchored" data-anchor-id="chapter-37.-planning-in-determistic-domains">Chapter 37. Planning in Determistic Domains</h2>
<section id="classical-planning-problem-definition" class="level3">
<h3 class="anchored" data-anchor-id="classical-planning-problem-definition">361. Classical Planning Problem Definition</h3>
<p>Classical planning is the study of finding a sequence of actions that transforms an initial state into a goal state under idealized assumptions. These assumptions simplify the world: actions are deterministic, the environment is fully observable, time is discrete, and goals are clearly defined.</p>
<section id="picture-in-your-head-60" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-60">Picture in Your Head</h4>
<p>Imagine a robot in a warehouse. At the start, boxes are scattered across shelves. The goal is to stack them neatly in one corner. Every action—pick up, move, place—is deterministic and always works. The planner’s job is to string these actions together into a valid plan.</p>
</section>
<section id="deep-dive-60" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-60">Deep Dive</h4>
<p>Key characteristics of classical planning problems:</p>
<ul>
<li>States: descriptions of the world at a point in time, often represented as sets of facts.</li>
<li>Actions: operators with preconditions (what must hold) and effects (what changes).</li>
<li>Initial state: the starting configuration.</li>
<li>Goal condition: a set of facts that must be satisfied.</li>
<li>Plan: a sequence of actions from initial state to goal state.</li>
</ul>
<p>Assumptions in classical planning:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 31%">
<col style="width: 68%">
</colgroup>
<thead>
<tr class="header">
<th>Assumption</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Deterministic actions</td>
<td>No randomness—effects always happen as defined</td>
</tr>
<tr class="even">
<td>Fully observable</td>
<td>Planner knows the complete current state</td>
</tr>
<tr class="odd">
<td>Static world</td>
<td>No external events modify the environment</td>
</tr>
<tr class="even">
<td>Discrete steps</td>
<td>Actions occur in atomic, ordered time steps</td>
</tr>
</tbody>
</table>
<p>This makes planning a search problem: find a path in the state space from the initial state to a goal state.</p>
</section>
<section id="tiny-code-60" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-60">Tiny Code</h4>
<p>Encoding a toy planning problem (block stacking):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Action:</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, precond, effect):</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> name</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.precond <span class="op">=</span> precond</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.effect <span class="op">=</span> effect</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> applicable(state, action):</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> action.precond.issubset(state)</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="bu">apply</span>(state, action):</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (state <span class="op">-</span> <span class="bu">set</span>(a <span class="cf">for</span> a <span class="kw">in</span> action.precond <span class="cf">if</span> a <span class="kw">not</span> <span class="kw">in</span> action.effect)) <span class="op">|</span> action.effect</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>state0 <span class="op">=</span> {<span class="st">"on(A,table)"</span>, <span class="st">"on(B,table)"</span>, <span class="st">"clear(A)"</span>, <span class="st">"clear(B)"</span>}</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>goal <span class="op">=</span> {<span class="st">"on(A,B)"</span>}</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>move_A_on_B <span class="op">=</span> Action(<span class="st">"move(A,B)"</span>, {<span class="st">"clear(A)"</span>, <span class="st">"clear(B)"</span>, <span class="st">"on(A,table)"</span>},</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>                                   {<span class="st">"on(A,B)"</span>, <span class="st">"clear(table)"</span>})</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-60" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-60">Why It Matters</h4>
<p>Classical planning provides the clean theoretical foundation for AI planning. Even though its assumptions rarely hold in real-world robotics, its principles underpin more advanced models (probabilistic, temporal, hierarchical). It remains the core teaching model for understanding automated planning.</p>
</section>
<section id="try-it-yourself-60" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-60">Try It Yourself</h4>
<ol type="1">
<li>Define a planning problem where a robot must move from room A to room C via B. Write down states, actions, and goals.</li>
<li>Encode a simple block-world problem with 3 blocks. Can you find a valid plan by hand?</li>
<li>Compare planning to search: how is a planning problem just another state-space search problem, but with structured actions?</li>
</ol>
</section>
</section>
<section id="strips-representation-and-operators" class="level3">
<h3 class="anchored" data-anchor-id="strips-representation-and-operators">362. STRIPS Representation and Operators</h3>
<p>STRIPS (Stanford Research Institute Problem Solver) is one of the most influential formalisms for representing planning problems. It specifies actions in terms of preconditions (what must be true before the action), add lists (facts made true by the action), and delete lists (facts made false). STRIPS transforms planning into a symbolic manipulation task.</p>
<section id="picture-in-your-head-61" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-61">Picture in Your Head</h4>
<p>Imagine a recipe card for cooking. Each recipe lists ingredients you must have (preconditions), the things you’ll end up with (add list), and the things you’ll use up or change (delete list). Planning with STRIPS is like sequencing these recipe cards to reach a final meal.</p>
</section>
<section id="deep-dive-61" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-61">Deep Dive</h4>
<p>Structure of a STRIPS operator:</p>
<ul>
<li>Action name: label for the operator.</li>
<li>Preconditions: facts that must hold before the action can be applied.</li>
<li>Add list: facts that become true after the action.</li>
<li>Delete list: facts that are removed from the state after the action.</li>
</ul>
<p>Formally:</p>
<p><span class="math display">\[
Action = (Name, Preconditions, Add, Delete)
\]</span></p>
<p>Example: moving a robot between rooms.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Component</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Name</td>
<td>Move(x, y)</td>
</tr>
<tr class="even">
<td>Preconditions</td>
<td>At(x), Connected(x, y)</td>
</tr>
<tr class="odd">
<td>Add list</td>
<td>At(y)</td>
</tr>
<tr class="even">
<td>Delete list</td>
<td>At(x)</td>
</tr>
</tbody>
</table>
<p>STRIPS assumptions:</p>
<ul>
<li>World described by a set of propositional facts.</li>
<li>Actions are deterministic.</li>
<li>Frame problem simplified: only Add and Delete lists change, all other facts remain unchanged.</li>
</ul>
</section>
<section id="tiny-code-61" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-61">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> STRIPSAction:</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, precond, add, delete):</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> name</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.precond <span class="op">=</span> <span class="bu">set</span>(precond)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.add <span class="op">=</span> <span class="bu">set</span>(add)</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.delete <span class="op">=</span> <span class="bu">set</span>(delete)</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> applicable(<span class="va">self</span>, state):</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.precond.issubset(state)</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">apply</span>(<span class="va">self</span>, state):</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (state <span class="op">-</span> <span class="va">self</span>.delete) <span class="op">|</span> <span class="va">self</span>.add</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>move <span class="op">=</span> STRIPSAction(</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Move(A,B)"</span>,</span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>    precond<span class="op">=</span>[<span class="st">"At(A)"</span>, <span class="st">"Connected(A,B)"</span>],</span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>    add<span class="op">=</span>[<span class="st">"At(B)"</span>],</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>    delete<span class="op">=</span>[<span class="st">"At(A)"</span>]</span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-61" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-61">Why It Matters</h4>
<p>STRIPS provided the first widely adopted symbolic representation for planning. Its clean structure influenced planning languages like PDDL and continues to shape how planners represent operators. It also introduced the idea of state transitions as symbolic reasoning, bridging logic and search.</p>
</section>
<section id="try-it-yourself-61" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-61">Try It Yourself</h4>
<ol type="1">
<li>Write a STRIPS operator for picking up a block (precondition: clear(block), ontable(block), handempty).</li>
<li>Define the “stack” operator in STRIPS for the block-world.</li>
<li>Compare STRIPS to plain search transitions—how does it simplify reasoning about actions?</li>
</ol>
</section>
</section>
<section id="forward-and-backward-state-space-planning" class="level3">
<h3 class="anchored" data-anchor-id="forward-and-backward-state-space-planning">363. Forward and Backward State-Space Planning</h3>
<p>Classical planners can search in two directions:</p>
<ul>
<li>Forward planning (progression): start from the initial state and apply actions until the goal is reached.</li>
<li>Backward planning (regression): start from the goal condition and work backward, finding actions that could achieve it until reaching the initial state.</li>
</ul>
<p>Both treat planning as search, but the choice of direction impacts efficiency.</p>
<section id="picture-in-your-head-62" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-62">Picture in Your Head</h4>
<p>Imagine solving a maze. You can walk forward from the entrance, exploring paths until you reach the exit (forward planning). Or you can start at the exit and trace backwards to see which paths could lead there (backward planning).</p>
</section>
<section id="deep-dive-62" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-62">Deep Dive</h4>
<ul>
<li><p>Forward (progression) search:</p>
<ul>
<li>Expands states reachable by applying valid actions.</li>
<li>Search space: all possible world states.</li>
<li>Easy to check action applicability.</li>
<li>May generate many irrelevant states.</li>
</ul></li>
<li><p>Backward (regression) search:</p>
<ul>
<li>Works with goal states, replacing unsatisfied conditions with the preconditions of actions.</li>
<li>Search space: subgoals (logical formulas).</li>
<li>Focused on achieving only what’s necessary.</li>
<li>Can be complex if many actions satisfy a goal condition.</li>
</ul></li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 25%">
<col style="width: 59%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Forward Planning</th>
<th>Backward Planning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Start point</td>
<td>Initial state</td>
<td>Goal condition</td>
</tr>
<tr class="even">
<td>Node type</td>
<td>Complete states</td>
<td>Subgoals (partial states)</td>
</tr>
<tr class="odd">
<td>Pros</td>
<td>Easy applicability</td>
<td>Goal-directed</td>
</tr>
<tr class="even">
<td>Cons</td>
<td>Can be unfocused</td>
<td>Regression may be tricky with many actions</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-62" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-62">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward_plan(initial, goal, actions, limit<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    frontier <span class="op">=</span> [(initial, [])]</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> frontier:</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>        state, plan <span class="op">=</span> frontier.pop()</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> goal.issubset(state):</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> plan</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">tuple</span>(state) <span class="kw">in</span> visited <span class="kw">or</span> <span class="bu">len</span>(plan) <span class="op">&gt;=</span> limit:</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>        visited.add(<span class="bu">tuple</span>(state))</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> actions:</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a.applicable(state):</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>                new_state <span class="op">=</span> a.<span class="bu">apply</span>(state)</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>                frontier.append((new_state, plan<span class="op">+</span>[a.name]))</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-62" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-62">Why It Matters</h4>
<p>Forward and backward planning provide two complementary perspectives. Forward search is intuitive and aligns with simulation, while backward search can be more efficient in goal-directed reasoning. Many modern planners integrate both strategies.</p>
</section>
<section id="try-it-yourself-62" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-62">Try It Yourself</h4>
<ol type="1">
<li>Implement forward planning in the block world. How many states are explored before reaching the goal?</li>
<li>Implement regression planning for the same problem. Is the search space smaller?</li>
<li>Compare efficiency when the goal is highly specific (e.g., block A on block B) vs.&nbsp;vague (any block on another).</li>
</ol>
</section>
</section>
<section id="plan-space-planning-partial-order-planning" class="level3">
<h3 class="anchored" data-anchor-id="plan-space-planning-partial-order-planning">364. Plan-Space Planning (Partial-Order Planning)</h3>
<p>Plan-space planning searches directly in the space of plans, rather than states. Instead of committing to a total sequence of actions, it builds a partial-order plan: a set of actions with ordering constraints, causal links, and open preconditions. This flexibility avoids premature decisions and allows concurrent actions.</p>
<section id="picture-in-your-head-63" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-63">Picture in Your Head</h4>
<p>Imagine writing a to-do list: “buy groceries,” “cook dinner,” “set the table.” Some tasks must happen in order (cook before serve), but others can be done independently (set table anytime before serving). A partial-order plan captures these flexible constraints without locking into a rigid timeline.</p>
</section>
<section id="deep-dive-63" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-63">Deep Dive</h4>
<p>Elements of partial-order planning (POP):</p>
<ul>
<li>Actions: operators with preconditions and effects.</li>
<li>Ordering constraints: specify which actions must precede others.</li>
<li>Causal links: record that an action achieves a condition required by another action.</li>
<li>Open preconditions: unsatisfied requirements that must be resolved.</li>
</ul>
<p>Algorithm sketch:</p>
<ol type="1">
<li>Start with an empty plan (Start and Finish actions only).</li>
<li>Select an open precondition.</li>
<li>Add a causal link by choosing or inserting an action that establishes it.</li>
<li>Add ordering constraints to prevent conflicts (threats).</li>
<li>Repeat until no open preconditions remain.</li>
</ol>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 28%">
<col style="width: 54%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>State-Space Planning</th>
<th>Plan-Space Planning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Search space</td>
<td>World states</td>
<td>Partial plans</td>
</tr>
<tr class="even">
<td>Commitment</td>
<td>Early (linear order)</td>
<td>Late (partial order)</td>
</tr>
<tr class="odd">
<td>Strength</td>
<td>Simpler search</td>
<td>Supports concurrency, less backtracking</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-63" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-63">Tiny Code</h4>
<p>Sketch of a causal link structure:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CausalLink:</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, producer, condition, consumer):</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.producer <span class="op">=</span> producer</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.condition <span class="op">=</span> condition</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.consumer <span class="op">=</span> consumer</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PartialPlan:</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.actions <span class="op">=</span> []</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.links <span class="op">=</span> []</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ordering <span class="op">=</span> []</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.open_preconds <span class="op">=</span> []</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-63" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-63">Why It Matters</h4>
<p>Plan-space planning was a landmark in AI because it made explicit the idea that plans don’t need to be strictly sequential. By allowing partially ordered plans, planners reduce search overhead and support real-world parallelism, which is critical in robotics and workflow systems.</p>
</section>
<section id="try-it-yourself-63" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-63">Try It Yourself</h4>
<ol type="1">
<li>Create a partial-order plan for making tea: boil water, steep leaves, pour into cup. Which actions can be concurrent?</li>
<li>Add causal links to a block-world plan. How do they prevent threats like “unstacking” before stacking is complete?</li>
<li>Compare the number of decisions needed for linear vs.&nbsp;partial-order planning on the same task.</li>
</ol>
</section>
</section>
<section id="graphplan-algorithm-and-planning-graphs" class="level3">
<h3 class="anchored" data-anchor-id="graphplan-algorithm-and-planning-graphs">365. Graphplan Algorithm and Planning Graphs</h3>
<p>The Graphplan algorithm introduced a new way of solving planning problems by building a planning graph: a layered structure alternating between possible actions and possible states. Instead of brute-force search, Graphplan compactly represents reachability and constraints, then extracts a valid plan by backward search through the graph.</p>
<section id="picture-in-your-head-64" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-64">Picture in Your Head</h4>
<p>Think of a subway map where stations are facts (states) and routes are actions. Each layer of the map shows where you could be after one more action. Planning becomes like tracing paths backward from the goal stations to the start, checking for consistency.</p>
</section>
<section id="deep-dive-64" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-64">Deep Dive</h4>
<ul>
<li><p>Planning graph structure:</p>
<ul>
<li>Proposition levels: sets of facts that could hold at that step.</li>
<li>Action levels: actions that could be applied given available facts.</li>
<li>Mutex constraints: pairs of facts or actions that cannot coexist (e.g., mutually exclusive preconditions).</li>
</ul></li>
<li><p>Algorithm flow:</p>
<ol type="1">
<li>Build planning graph level by level until goals appear without mutexes.</li>
<li>Backtrack to extract a consistent set of actions achieving the goals.</li>
<li>Repeat expansion if no plan is found yet.</li>
</ol></li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 38%">
<col style="width: 61%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Benefit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Polynomial graph expansion</td>
<td>Much faster than brute-force state search</td>
</tr>
<tr class="even">
<td>Compact representation</td>
<td>Avoids redundancy in search</td>
</tr>
<tr class="odd">
<td>Mutex detection</td>
<td>Prevents infeasible goal combinations</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-64" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-64">Tiny Code</h4>
<p>Sketch of a planning graph builder:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PlanningGraph:</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, initial_state, actions):</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.levels <span class="op">=</span> [<span class="bu">set</span>(initial_state)]</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.actions <span class="op">=</span> actions</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> expand(<span class="va">self</span>):</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>        current_props <span class="op">=</span> <span class="va">self</span>.levels[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>        next_actions <span class="op">=</span> [a <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.actions <span class="cf">if</span> a.precond.issubset(current_props)]</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>        next_props <span class="op">=</span> <span class="bu">set</span>().union(<span class="op">*</span>(a.add <span class="cf">for</span> a <span class="kw">in</span> next_actions))</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.levels.append(next_props)</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> next_actions, next_props</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-64" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-64">Why It Matters</h4>
<p>Graphplan was a breakthrough in the 1990s, forming the basis of many modern planners. It combined ideas from constraint propagation and search, offering both efficiency and structure. Its mutex reasoning remains influential in planning and SAT-based approaches.</p>
</section>
<section id="try-it-yourself-64" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-64">Try It Yourself</h4>
<ol type="1">
<li>Build a planning graph for the block-world problem with 2 blocks. Which actions appear at each level?</li>
<li>Add mutex constraints between actions that require conflicting conditions. How does this prune infeasible paths?</li>
<li>Compare the number of states explored by forward search vs.&nbsp;Graphplan on the same problem.</li>
</ol>
</section>
</section>
<section id="heuristic-search-planners-e.g.-ff-planner" class="level3">
<h3 class="anchored" data-anchor-id="heuristic-search-planners-e.g.-ff-planner">366. Heuristic Search Planners (e.g., FF Planner)</h3>
<p>Heuristic search planners use informed search techniques, such as A*, guided by heuristics derived from simplified versions of the planning problem. One of the most influential is the Fast-Forward (FF) planner, which introduced effective heuristics based on ignoring delete effects, making heuristic estimates both cheap and useful.</p>
<section id="picture-in-your-head-65" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-65">Picture in Your Head</h4>
<p>Imagine planning a trip across a city. Instead of calculating the exact traffic at every intersection, you pretend no roads ever close. This optimistic simplification makes it easy to estimate the distance to your goal, even if the actual trip requires detours.</p>
</section>
<section id="deep-dive-65" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-65">Deep Dive</h4>
<p>Heuristic derivation in FF:</p>
<ul>
<li>Build a relaxed planning graph where delete effects are ignored (facts, once true, stay true).</li>
<li>Extract a relaxed plan from this graph.</li>
<li>Use the length of the relaxed plan as the heuristic estimate.</li>
</ul>
<p>Properties:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>Impact</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ignoring delete effects</td>
<td>Simplifies reasoning, optimistic heuristic</td>
</tr>
<tr class="even">
<td>Relaxed plan heuristic</td>
<td>Usually admissible but not always exact</td>
</tr>
<tr class="odd">
<td>Efficient computation</td>
<td>Builds compact structures quickly</td>
</tr>
<tr class="even">
<td>High accuracy</td>
<td>Provides strong guidance in large domains</td>
</tr>
</tbody>
</table>
<p>Other modern planners extend this approach with:</p>
<ul>
<li>Landmark heuristics (identifying subgoals that must be achieved).</li>
<li>Pattern databases.</li>
<li>Hybrid SAT-based reasoning.</li>
</ul>
</section>
<section id="tiny-code-65" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-65">Tiny Code</h4>
<p>Sketch of a delete-relaxation heuristic:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> relaxed_plan_length(initial, goal, actions):</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    state <span class="op">=</span> <span class="bu">set</span>(initial)</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    steps <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="kw">not</span> goal.issubset(state):</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>        applicable <span class="op">=</span> [a <span class="cf">for</span> a <span class="kw">in</span> actions <span class="cf">if</span> a.precond.issubset(state)]</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> applicable:</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">float</span>(<span class="st">"inf"</span>)</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> <span class="bu">min</span>(applicable, key<span class="op">=</span><span class="kw">lambda</span> a: <span class="bu">len</span>(goal <span class="op">-</span> (state <span class="op">|</span> a.add)))</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>        state <span class="op">|=</span> best.add  <span class="co"># ignore deletes</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>        steps <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> steps</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-65" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-65">Why It Matters</h4>
<p>The FF planner and its heuristic revolutionized planning, enabling planners to solve problems with hundreds of actions and states efficiently. The idea of relaxation-based heuristics now underlies much of modern planning, bridging search and constraint reasoning.</p>
</section>
<section id="try-it-yourself-65" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-65">Try It Yourself</h4>
<ol type="1">
<li>Implement a relaxed-plan heuristic for a 3-block stacking problem. How close is the estimate to the true plan length?</li>
<li>Compare A* with uniform cost search on the same planning domain. Which explores fewer nodes?</li>
<li>Add delete effects back into the heuristic. How does it change performance?</li>
</ol>
</section>
</section>
<section id="planning-domain-definition-language-pddl" class="level3">
<h3 class="anchored" data-anchor-id="planning-domain-definition-language-pddl">367. Planning Domain Definition Language (PDDL)</h3>
<p>The Planning Domain Definition Language (PDDL) is the standard language for specifying planning problems. It separates domain definitions (actions, predicates, objects) from problem definitions (initial state, goals). PDDL provides a structured, machine-readable way for planners to interpret tasks, much like SQL does for databases.</p>
<section id="picture-in-your-head-66" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-66">Picture in Your Head</h4>
<p>Think of PDDL as the “contract” between a problem designer and a planner. It’s like writing a recipe book (the domain: what actions exist, their ingredients and effects) and then writing a shopping list (the problem: what you have and what you want).</p>
</section>
<section id="deep-dive-66" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-66">Deep Dive</h4>
<p>PDDL structure:</p>
<ul>
<li><p>Domain file</p>
<ul>
<li>Predicates: relations describing the world.</li>
<li>Actions: with parameters, preconditions, and effects (STRIPS-style).</li>
</ul></li>
<li><p>Problem file</p>
<ul>
<li>Objects: instances in the specific problem.</li>
<li>Initial state: facts true at the start.</li>
<li>Goal state: conditions to be achieved.</li>
</ul></li>
</ul>
<p>Example (Block World):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb68"><pre class="sourceCode lisp code-with-copy"><code class="sourceCode commonlisp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>(define (domain blocks)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>  (:predicates (on ?x ?y) (ontable ?x) (clear ?x) (handempty) (holding ?x))</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>  (:action pickup</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    :parameters (?x)</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    :precondition (<span class="kw">and</span> (clear ?x) (ontable ?x) (handempty))</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>    :effect (<span class="kw">and</span> (holding ?x) (<span class="kw">not</span> (ontable ?x)) (<span class="kw">not</span> (clear ?x)) (<span class="kw">not</span> (handempty))))</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>  (:action putdown</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    :parameters (?x)</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>    :precondition (holding ?x)</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>    :effect (<span class="kw">and</span> (ontable ?x) (clear ?x) (handempty) (<span class="kw">not</span> (holding ?x)))))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Problem file:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb69"><pre class="sourceCode lisp code-with-copy"><code class="sourceCode commonlisp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>(define (problem blocks-1)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>  (:domain blocks)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  (:objects A B C)</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  (:init (ontable A) (ontable B) (ontable C) (clear A) (clear B) (clear C) (handempty))</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  (:goal (<span class="kw">and</span> (on A B) (on B C))))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Properties:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>Benefit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Standardized</td>
<td>Widely supported across planners</td>
</tr>
<tr class="even">
<td>Extensible</td>
<td>Supports types, numeric fluents, temporal constraints</td>
</tr>
<tr class="odd">
<td>Flexible</td>
<td>Decouples general domain from specific problems</td>
</tr>
</tbody>
</table>
</section>
<section id="why-it-matters-66" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-66">Why It Matters</h4>
<p>PDDL unified research in automated planning, enabling shared benchmarks, competitions, and reproducibility. It expanded beyond STRIPS to support advanced features: numeric planning, temporal planning, and preferences. Today, nearly all general-purpose planners parse PDDL.</p>
</section>
<section id="try-it-yourself-66" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-66">Try It Yourself</h4>
<ol type="1">
<li>Write a PDDL domain for a simple robot navigation task (move between rooms).</li>
<li>Define a PDDL problem where the robot starts in Room A and must reach Room C via Room B.</li>
<li>Run your PDDL files in an open-source planner (like Fast Downward). How many steps are in the solution plan?</li>
</ol>
</section>
</section>
<section id="temporal-and-resource-augmented-planning" class="level3">
<h3 class="anchored" data-anchor-id="temporal-and-resource-augmented-planning">368. Temporal and Resource-Augmented Planning</h3>
<p>Classical planning assumes instantaneous, resource-free actions. Real-world tasks, however, involve time durations and resource constraints. Temporal and resource-augmented planning extends classical models to account for scheduling, concurrency, and limited resources like energy, money, or manpower.</p>
<section id="picture-in-your-head-67" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-67">Picture in Your Head</h4>
<p>Imagine planning a space mission. The rover must drive (takes 2 hours), recharge (needs solar energy), and collect samples (requires instruments and time). Some actions can overlap (recharging while transmitting data), but others compete for limited resources.</p>
</section>
<section id="deep-dive-67" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-67">Deep Dive</h4>
<p>Key extensions:</p>
<ul>
<li><p>Temporal planning</p>
<ul>
<li>Actions have durations.</li>
<li>Goals may include deadlines.</li>
<li>Overlapping actions allowed if constraints satisfied.</li>
</ul></li>
<li><p>Resource-augmented planning</p>
<ul>
<li>Resources modeled as numeric fluents (e.g., fuel, workers).</li>
<li>Actions consume and produce resources.</li>
<li>Constraints prevent exceeding resource limits.</li>
</ul></li>
</ul>
<p>Example (temporal PDDL snippet):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb70"><pre class="sourceCode lisp code-with-copy"><code class="sourceCode commonlisp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>(:durative-action drive</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>  :parameters (?r ?from ?to)</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>  :duration (<span class="op">=</span> ?duration <span class="dv">2</span>)</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>  :condition (<span class="kw">and</span> (at start (at ?r ?from)) (at start (connected ?from ?to)))</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>  :effect (<span class="kw">and</span> (at end (at ?r ?to)) (at start (<span class="kw">not</span> (at ?r ?from)))))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Properties:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 42%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Temporal Planning</th>
<th>Resource Planning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Action model</td>
<td>Durations and intervals</td>
<td>Numeric consumption/production</td>
</tr>
<tr class="even">
<td>Constraints</td>
<td>Ordering, deadlines</td>
<td>Capacity, balance</td>
</tr>
<tr class="odd">
<td>Applications</td>
<td>Scheduling, robotics, workflows</td>
<td>Logistics, project management</td>
</tr>
</tbody>
</table>
<p>Challenges:</p>
<ul>
<li>Search space expands drastically.</li>
<li>Need hybrid methods: combine planning with scheduling and constraint satisfaction.</li>
</ul>
</section>
<section id="why-it-matters-67" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-67">Why It Matters</h4>
<p>Temporal and resource-augmented planning bridges the gap between symbolic AI planning and real-world operations. It’s used in space exploration (NASA planners), manufacturing, logistics, and workflow systems, where time and resources matter as much as logical correctness.</p>
</section>
<section id="try-it-yourself-67" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-67">Try It Yourself</h4>
<ol type="1">
<li>Write a temporal plan for making dinner: “cook pasta (10 min), make sauce (15 min), set table (5 min).” Which actions overlap?</li>
<li>Add a resource constraint: only 2 burners available. How does it change the plan?</li>
<li>Implement a simple resource tracker: each action decreases a fuel counter. What happens if a plan runs out of fuel halfway?</li>
</ol>
</section>
</section>
<section id="applications-in-robotics-and-logistics" class="level3">
<h3 class="anchored" data-anchor-id="applications-in-robotics-and-logistics">369. Applications in Robotics and Logistics</h3>
<p>Planning with deterministic models, heuristics, and temporal/resource extensions has found wide application in robotics and logistics. Robots need to sequence actions under physical and temporal constraints, while logistics systems must coordinate resources across large networks. These fields showcase planning moving from theory into practice.</p>
<section id="picture-in-your-head-68" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-68">Picture in Your Head</h4>
<p>Picture a warehouse: robots fetch packages, avoid collisions, recharge when needed, and deliver items on time. Or imagine a global supply chain where planes, trucks, and ships must be scheduled so goods arrive at the right place, at the right time, without exceeding budgets.</p>
</section>
<section id="deep-dive-68" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-68">Deep Dive</h4>
<ul>
<li><p>Robotics applications:</p>
<ul>
<li>Task planning: sequencing actions like grasp, move, place.</li>
<li>Motion planning integration: ensuring physical feasibility of robot trajectories.</li>
<li>Human-robot interaction: planning tasks that align with human actions.</li>
<li>Temporal constraints: account for action durations (e.g., walking vs.&nbsp;running speed).</li>
</ul></li>
<li><p>Logistics applications:</p>
<ul>
<li>Transportation planning: scheduling vehicles, routes, and deliveries.</li>
<li>Resource allocation: assigning limited trucks, fuel, or workers to tasks.</li>
<li>Multi-agent coordination: ensuring fleets of vehicles or robots work together efficiently.</li>
<li>Global optimization: minimizing cost, maximizing throughput, ensuring deadlines.</li>
</ul></li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 10%">
<col style="width: 36%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Challenges</th>
<th>Planning Extensions Used</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Robotics</td>
<td>Dynamics, sensing, concurrency</td>
<td>Temporal planning, integrated motion planning</td>
</tr>
<tr class="even">
<td>Logistics</td>
<td>Scale, multi-agent, uncertainty</td>
<td>Resource-augmented planning, heuristic search</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-66" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-66">Tiny Code</h4>
<p>A sketch of resource-aware plan execution:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> execute_plan(plan, resources):</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> action <span class="kw">in</span> plan:</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(resources[r] <span class="op">&gt;=</span> cost <span class="cf">for</span> r, cost <span class="kw">in</span> action[<span class="st">"requires"</span>].items()):</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> r, cost <span class="kw">in</span> action[<span class="st">"requires"</span>].items():</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>                resources[r] <span class="op">-=</span> cost</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> r, gain <span class="kw">in</span> action.get(<span class="st">"produces"</span>, {}).items():</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>                resources[r] <span class="op">+=</span> gain</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Executed </span><span class="sc">{</span>action[<span class="st">'name'</span>]<span class="sc">}</span><span class="ss">, resources: </span><span class="sc">{</span>resources<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Failed: insufficient resources for </span><span class="sc">{</span>action[<span class="st">'name'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-68" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-68">Why It Matters</h4>
<p>Robotics and logistics are testbeds where AI planning meets physical and organizational complexity. NASA uses planners for rover missions, Amazon for warehouse robots, and shipping companies for fleet management. These cases prove that planning can deliver real-world impact beyond puzzles and benchmarks.</p>
</section>
<section id="try-it-yourself-68" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-68">Try It Yourself</h4>
<ol type="1">
<li>Define a logistics domain with 2 trucks, 3 packages, and 3 cities. Can you create a plan to deliver all packages?</li>
<li>Add resource limits: each truck has limited fuel. How does planning adapt?</li>
<li>In robotics, model a robot with two arms. Can partial-order planning allow both arms to work in parallel?</li>
</ol>
</section>
</section>
<section id="case-study-deterministic-planning-systems" class="level3">
<h3 class="anchored" data-anchor-id="case-study-deterministic-planning-systems">370. Case Study: Deterministic Planning Systems</h3>
<p>Deterministic planning systems apply classical planning techniques to structured, fully observable environments. They assume actions always succeed, states are completely known, and the world does not change unexpectedly. Such systems serve as the foundation for advanced planners and provide benchmarks for AI research.</p>
<section id="picture-in-your-head-69" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-69">Picture in Your Head</h4>
<p>Imagine an automated factory where every machine works perfectly: a robot arm moves items, a conveyor belt delivers them, and sensors always provide exact readings. The planner only needs to compute the correct sequence once, with no surprises during execution.</p>
</section>
<section id="deep-dive-69" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-69">Deep Dive</h4>
<p>Key characteristics of deterministic planning systems:</p>
<ul>
<li>State representation: propositional facts or structured predicates.</li>
<li>Action model: STRIPS-style operators with deterministic effects.</li>
<li>Search strategy: forward, backward, or heuristic-guided exploration.</li>
<li>Output: a linear sequence of actions guaranteed to reach the goal.</li>
</ul>
<p>Examples of systems:</p>
<ul>
<li>STRIPS (1970s): pioneering planner using preconditions, add, and delete lists.</li>
<li>Graphplan (1990s): introduced planning graphs and mutex constraints.</li>
<li>FF planner (2000s): heuristic search with relaxed plans.</li>
</ul>
<p>Comparison of representative planners:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 26%">
<col style="width: 36%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>System</th>
<th>Innovation</th>
<th>Strength</th>
<th>Limitation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>STRIPS</td>
<td>Action representation</td>
<td>First structured symbolic planner</td>
<td>Limited scalability</td>
</tr>
<tr class="even">
<td>Graphplan</td>
<td>Planning graphs, mutex reasoning</td>
<td>Compact representation, polynomial expansion</td>
<td>Extraction phase still expensive</td>
</tr>
<tr class="odd">
<td>FF</td>
<td>Relaxed-plan heuristics</td>
<td>Fast, effective on benchmarks</td>
<td>Ignores delete effects in heuristic</td>
</tr>
</tbody>
</table>
<p>Applications:</p>
<ul>
<li>Puzzle solving (blocks world, logistics).</li>
<li>Benchmarking in International Planning Competitions (IPC).</li>
<li>Testing ideas before extending to probabilistic, temporal, or multi-agent planning.</li>
</ul>
</section>
<section id="tiny-code-67" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-67">Tiny Code</h4>
<p>Simple forward deterministic planner:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward_deterministic(initial, goal, actions, max_depth<span class="op">=</span><span class="dv">20</span>):</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    frontier <span class="op">=</span> [(initial, [])]</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> frontier:</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>        state, plan <span class="op">=</span> frontier.pop()</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> goal.issubset(state):</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> plan</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">tuple</span>(state) <span class="kw">in</span> visited <span class="kw">or</span> <span class="bu">len</span>(plan) <span class="op">&gt;=</span> max_depth:</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>        visited.add(<span class="bu">tuple</span>(state))</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> actions:</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a.applicable(state):</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>                new_state <span class="op">=</span> a.<span class="bu">apply</span>(state)</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>                frontier.append((new_state, plan<span class="op">+</span>[a.name]))</span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-69" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-69">Why It Matters</h4>
<p>Deterministic planners are the intellectual backbone of automated planning. Even though real-world domains are uncertain and noisy, the abstractions developed here—state spaces, operators, heuristics—remain central to AI systems. They also provide the cleanest environment for testing new algorithms.</p>
</section>
<section id="try-it-yourself-69" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-69">Try It Yourself</h4>
<ol type="1">
<li>Implement a deterministic planner for the block world with 3 blocks. Does it find the same plans as Graphplan?</li>
<li>Compare STRIPS vs.&nbsp;FF planner on the same logistics problem. Which is faster?</li>
<li>Extend a deterministic planner by adding durations to actions. How does the model need to change?</li>
</ol>
</section>
</section>
</section>
<section id="chapter-38.-probabilistic-planning-and-pomdps" class="level2">
<h2 class="anchored" data-anchor-id="chapter-38.-probabilistic-planning-and-pomdps">Chapter 38. Probabilistic Planning and POMDPs</h2>
<section id="planning-under-uncertainty-motivation-and-models" class="level3">
<h3 class="anchored" data-anchor-id="planning-under-uncertainty-motivation-and-models">371. Planning Under Uncertainty: Motivation and Models</h3>
<p>Real-world environments rarely fit the neat assumptions of classical planning. Actions can fail, sensors may be noisy, and the world can change unpredictably. Planning under uncertainty generalizes deterministic planning by incorporating probabilities, incomplete information, and stochastic outcomes into the planning model.</p>
<section id="picture-in-your-head-70" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-70">Picture in Your Head</h4>
<p>Imagine a delivery drone. Wind gusts may blow it off course, GPS readings may be noisy, and a package might not be at the expected location. The drone cannot rely on a fixed plan—it must reason about uncertainty and adapt as it acts.</p>
</section>
<section id="deep-dive-70" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-70">Deep Dive</h4>
<p>Dimensions of uncertainty:</p>
<ul>
<li>Outcome uncertainty: actions may have multiple possible effects (e.g., “move forward” might succeed or fail).</li>
<li>State uncertainty: the agent may not fully know its current situation.</li>
<li>Exogenous events: the environment may change independently of the agent’s actions.</li>
</ul>
<p>Models for planning under uncertainty:</p>
<ul>
<li>Markov Decision Processes (MDPs): probabilistic outcomes, fully observable states.</li>
<li>Partially Observable MDPs (POMDPs): uncertainty in both outcomes and state observability.</li>
<li>Contingent planning: plans that branch depending on observations.</li>
<li>Replanning: dynamically adjust plans as new information arrives.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 16%">
<col style="width: 24%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>Model</th>
<th>Observability</th>
<th>Outcomes</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Classical</td>
<td>Full</td>
<td>Deterministic</td>
<td>Blocks world</td>
</tr>
<tr class="even">
<td>MDP</td>
<td>Full</td>
<td>Probabilistic</td>
<td>Gridworld with slippery tiles</td>
</tr>
<tr class="odd">
<td>POMDP</td>
<td>Partial</td>
<td>Probabilistic</td>
<td>Robot navigation with noisy sensors</td>
</tr>
<tr class="even">
<td>Contingent</td>
<td>Partial</td>
<td>Deterministic/Prob.</td>
<td>Conditional “if-then” plans</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-68" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-68">Tiny Code</h4>
<p>Simple stochastic action:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stochastic_move(state, action):</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> action <span class="op">==</span> <span class="st">"forward"</span>:</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> state <span class="op">+</span> <span class="dv">1</span> <span class="cf">if</span> random.random() <span class="op">&lt;</span> <span class="fl">0.8</span> <span class="cf">else</span> state  <span class="co"># 20% failure</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> action <span class="op">==</span> <span class="st">"backward"</span>:</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> state <span class="op">-</span> <span class="dv">1</span> <span class="cf">if</span> random.random() <span class="op">&lt;</span> <span class="fl">0.9</span> <span class="cf">else</span> state</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-70" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-70">Why It Matters</h4>
<p>Most real-world AI systems—from self-driving cars to medical decision-making—operate under uncertainty. Planning methods that explicitly handle probabilistic outcomes and partial knowledge are essential for reliability and robustness in practice.</p>
</section>
<section id="try-it-yourself-70" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-70">Try It Yourself</h4>
<ol type="1">
<li>Modify a grid navigation planner so that “move north” succeeds 80% of the time and fails 20%. How does this change the best policy?</li>
<li>Add partial observability: the agent can only sense its position with 90% accuracy. How does planning adapt?</li>
<li>Compare a fixed plan vs.&nbsp;a contingent plan for a robot with a faulty gripper. Which works better?</li>
</ol>
</section>
</section>
<section id="markov-decision-processes-mdps-revisited" class="level3">
<h3 class="anchored" data-anchor-id="markov-decision-processes-mdps-revisited">372. Markov Decision Processes (MDPs) Revisited</h3>
<p>A Markov Decision Process (MDP) provides the mathematical framework for planning under uncertainty when states are fully observable. It extends classical planning by modeling actions as probabilistic transitions between states, with rewards guiding the agent toward desirable outcomes.</p>
<section id="picture-in-your-head-71" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-71">Picture in Your Head</h4>
<p>Imagine navigating an icy grid. Stepping north usually works, but sometimes you slip sideways. Each move changes your location probabilistically. By assigning rewards (e.g., +10 for reaching the goal, -1 per step), you can evaluate which policy—set of actions in each state—leads to the best expected outcome.</p>
</section>
<section id="deep-dive-71" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-71">Deep Dive</h4>
<p>An MDP is defined as a 4-tuple <span class="math inline">\((S, A, P, R)\)</span>:</p>
<ul>
<li>States (S): all possible configurations of the world.</li>
<li>Actions (A): choices available to the agent.</li>
<li>Transition model (P): <span class="math inline">\(P(s' \mid s, a)\)</span>, probability of reaching state <span class="math inline">\(s'\)</span> after action <span class="math inline">\(a\)</span> in state <span class="math inline">\(s\)</span>.</li>
<li>Reward function (R): scalar feedback for being in a state or taking an action.</li>
</ul>
<p>Objective: Find a policy <span class="math inline">\(\pi(s)\)</span> mapping states to actions that maximizes expected cumulative reward:</p>
<p><span class="math display">\[
V^\pi(s) = \mathbb{E}\left[ \sum_{t=0}^\infty \gamma^t R(s_t, \pi(s_t)) \right]
\]</span></p>
<p>with discount factor <span class="math inline">\(\gamma \in [0,1)\)</span>.</p>
<p>Core algorithms:</p>
<ul>
<li>Value Iteration: iteratively update value estimates until convergence.</li>
<li>Policy Iteration: alternate between policy evaluation and improvement.</li>
</ul>
</section>
<section id="tiny-code-69" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-69">Tiny Code</h4>
<p>Value iteration for a simple grid MDP:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> value_iteration(states, actions, P, R, gamma<span class="op">=</span><span class="fl">0.9</span>, epsilon<span class="op">=</span><span class="fl">1e-6</span>):</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> {s: <span class="dv">0</span> <span class="cf">for</span> s <span class="kw">in</span> states}</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>        delta <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s <span class="kw">in</span> states:</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> V[s]</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>            V[s] <span class="op">=</span> <span class="bu">max</span>(<span class="bu">sum</span>(p <span class="op">*</span> (R(s,a,s2) <span class="op">+</span> gamma <span class="op">*</span> V[s2]) </span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>                           <span class="cf">for</span> s2, p <span class="kw">in</span> P(s,a).items())</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>                       <span class="cf">for</span> a <span class="kw">in</span> actions(s))</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>            delta <span class="op">=</span> <span class="bu">max</span>(delta, <span class="bu">abs</span>(v <span class="op">-</span> V[s]))</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> delta <span class="op">&lt;</span> epsilon:</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> V</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-71" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-71">Why It Matters</h4>
<p>MDPs unify planning and learning under uncertainty. They form the foundation of reinforcement learning, robotics control, and decision-making systems where randomness cannot be ignored. Understanding MDPs is essential before tackling more complex frameworks like POMDPs.</p>
</section>
<section id="try-it-yourself-71" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-71">Try It Yourself</h4>
<ol type="1">
<li>Define a 3x3 grid with slip probability 0.2. Use value iteration to compute optimal values.</li>
<li>Add a reward of -10 for stepping into a trap state. How does the optimal policy change?</li>
<li>Compare policy iteration vs.&nbsp;value iteration. Which converges faster on your grid?</li>
</ol>
</section>
</section>
<section id="value-iteration-and-policy-iteration-for-planning" class="level3">
<h3 class="anchored" data-anchor-id="value-iteration-and-policy-iteration-for-planning">373. Value Iteration and Policy Iteration for Planning</h3>
<p>In Markov Decision Processes (MDPs), the central problem is to compute an optimal policy—a mapping from states to actions. Two fundamental dynamic programming methods solve this: value iteration and policy iteration. Both rely on the Bellman equations, but they differ in how they update values and policies.</p>
<section id="picture-in-your-head-72" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-72">Picture in Your Head</h4>
<p>Imagine learning to navigate a slippery grid. You keep track of how good each square is (value function). With value iteration, you repeatedly refine these numbers directly. With policy iteration, you alternate: first follow your current best policy to see how well it does, then improve it slightly, and repeat until optimal.</p>
</section>
<section id="deep-dive-72" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-72">Deep Dive</h4>
<ul>
<li><p>Value Iteration</p>
<ul>
<li><p>Uses the Bellman optimality equation:</p>
<p><span class="math display">\[
V_{k+1}(s) = \max_a \sum_{s'} P(s'|s,a) \big[ R(s,a,s') + \gamma V_k(s') \big]
\]</span></p></li>
<li><p>Updates values in each iteration until convergence.</p></li>
<li><p>Policy derived at the end: <span class="math inline">\(\pi(s) = \arg\max_a \sum_{s'} P(s'|s,a) [R + \gamma V(s')]\)</span>.</p></li>
</ul></li>
<li><p>Policy Iteration</p>
<ol type="1">
<li>Policy Evaluation: compute value of current policy <span class="math inline">\(\pi\)</span>.</li>
<li>Policy Improvement: update <span class="math inline">\(\pi\)</span> greedily with respect to current values.</li>
<li>Repeat until policy stabilizes.</li>
</ol></li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 42%">
<col style="width: 42%">
</colgroup>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Strengths</th>
<th>Weaknesses</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Value Iteration</td>
<td>Simple, directly improves values</td>
<td>May require many iterations for convergence</td>
</tr>
<tr class="even">
<td>Policy Iteration</td>
<td>Often fewer iterations, interpretable steps</td>
<td>Each evaluation step may be expensive</td>
</tr>
</tbody>
</table>
<p>Both converge to the same optimal policy.</p>
</section>
<section id="tiny-code-70" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-70">Tiny Code</h4>
<p>Policy iteration skeleton:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> policy_iteration(states, actions, P, R, gamma<span class="op">=</span><span class="fl">0.9</span>, epsilon<span class="op">=</span><span class="fl">1e-6</span>):</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize arbitrary policy</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    policy <span class="op">=</span> {s: actions(s)[<span class="dv">0</span>] <span class="cf">for</span> s <span class="kw">in</span> states}</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> {s: <span class="dv">0</span> <span class="cf">for</span> s <span class="kw">in</span> states}</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Policy evaluation</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>            delta <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> s <span class="kw">in</span> states:</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>                v <span class="op">=</span> V[s]</span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>                a <span class="op">=</span> policy[s]</span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>                V[s] <span class="op">=</span> <span class="bu">sum</span>(p <span class="op">*</span> (R(s,a,s2) <span class="op">+</span> gamma <span class="op">*</span> V[s2]) <span class="cf">for</span> s2, p <span class="kw">in</span> P(s,a).items())</span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>                delta <span class="op">=</span> <span class="bu">max</span>(delta, <span class="bu">abs</span>(v <span class="op">-</span> V[s]))</span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> delta <span class="op">&lt;</span> epsilon: <span class="cf">break</span></span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Policy improvement</span></span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a>        stable <span class="op">=</span> <span class="va">True</span></span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s <span class="kw">in</span> states:</span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>            old_a <span class="op">=</span> policy[s]</span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a>            policy[s] <span class="op">=</span> <span class="bu">max</span>(actions(s),</span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a>                            key<span class="op">=</span><span class="kw">lambda</span> a: <span class="bu">sum</span>(p <span class="op">*</span> (R(s,a,s2) <span class="op">+</span> gamma <span class="op">*</span> V[s2]) <span class="cf">for</span> s2, p <span class="kw">in</span> P(s,a).items()))</span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> old_a <span class="op">!=</span> policy[s]:</span>
<span id="cb75-24"><a href="#cb75-24" aria-hidden="true" tabindex="-1"></a>                stable <span class="op">=</span> <span class="va">False</span></span>
<span id="cb75-25"><a href="#cb75-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> stable: <span class="cf">break</span></span>
<span id="cb75-26"><a href="#cb75-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> policy, V</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-72" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-72">Why It Matters</h4>
<p>Value iteration and policy iteration are the workhorses of planning under uncertainty. They guarantee convergence to optimal solutions in finite MDPs, making them the baseline against which approximate and scalable methods are measured.</p>
</section>
<section id="try-it-yourself-72" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-72">Try It Yourself</h4>
<ol type="1">
<li>Apply value iteration to a 4x4 grid world. How many iterations until convergence?</li>
<li>Compare runtime of value iteration vs.&nbsp;policy iteration on the same grid. Which is faster?</li>
<li>Implement a stochastic action model (slip probability). How do optimal policies differ from deterministic ones?</li>
</ol>
</section>
</section>
<section id="partially-observable-mdps-pomdps" class="level3">
<h3 class="anchored" data-anchor-id="partially-observable-mdps-pomdps">374. Partially Observable MDPs (POMDPs)</h3>
<p>In many real-world scenarios, an agent cannot fully observe the state of the environment. Partially Observable Markov Decision Processes (POMDPs) extend MDPs by incorporating uncertainty about the current state. The agent must reason over belief states—probability distributions over possible states—while planning actions.</p>
<section id="picture-in-your-head-73" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-73">Picture in Your Head</h4>
<p>Imagine a robot searching for a person in a building. It hears noises but can’t see through walls. Instead of knowing exactly where the person is, the robot maintains probabilities: “70% chance they’re in room A, 20% in room B, 10% in the hallway.” Its decisions—where to move or whether to call out—depend on this belief.</p>
</section>
<section id="deep-dive-73" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-73">Deep Dive</h4>
<p>Formal definition: a POMDP is a 6-tuple <span class="math inline">\((S, A, P, R, O, Z)\)</span>:</p>
<ul>
<li>States (S): hidden world configurations.</li>
<li>Actions (A): choices available to the agent.</li>
<li>Transition model (P): <span class="math inline">\(P(s'|s,a)\)</span>.</li>
<li>Rewards (R): payoff for actions in states.</li>
<li>Observations (O): possible sensory inputs.</li>
<li>Observation model (Z): <span class="math inline">\(P(o|s',a)\)</span>, probability of observing <span class="math inline">\(o\)</span> after action <span class="math inline">\(a\)</span>.</li>
</ul>
<p>Key concepts:</p>
<ul>
<li><p>Belief state <span class="math inline">\(b(s)\)</span>: probability distribution over states.</p></li>
<li><p>Belief update:</p>
<p><span class="math display">\[
b'(s') = \eta \cdot Z(o|s',a) \sum_s P(s'|s,a) b(s)
\]</span></p>
<p>where <span class="math inline">\(\eta\)</span> is a normalizing constant.</p></li>
<li><p>Planning happens in belief space, which is continuous and high-dimensional.</p></li>
</ul>
<p>Comparison with MDPs:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>MDP</th>
<th>POMDP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Observability</td>
<td>Full state known</td>
<td>Partial, via observations</td>
</tr>
<tr class="even">
<td>Policy input</td>
<td>Current state</td>
<td>Belief state</td>
</tr>
<tr class="odd">
<td>Complexity</td>
<td>Polynomial in states</td>
<td>PSPACE-hard</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-71" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-71">Tiny Code</h4>
<p>Belief update function:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_belief(belief, action, observation, P, Z):</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    new_belief <span class="op">=</span> {}</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s_next <span class="kw">in</span> P.keys():</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>        prob <span class="op">=</span> <span class="bu">sum</span>(P[s][action].get(s_next, <span class="dv">0</span>) <span class="op">*</span> belief.get(s, <span class="dv">0</span>) <span class="cf">for</span> s <span class="kw">in</span> belief)</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>        new_belief[s_next] <span class="op">=</span> Z[s_next][action].get(observation, <span class="dv">0</span>) <span class="op">*</span> prob</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># normalize</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="bu">sum</span>(new_belief.values())</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> total <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s <span class="kw">in</span> new_belief:</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>            new_belief[s] <span class="op">/=</span> total</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_belief</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-73" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-73">Why It Matters</h4>
<p>POMDPs capture the essence of real-world decision-making under uncertainty: noisy sensors, hidden states, and probabilistic dynamics. They are crucial for robotics, dialogue systems, and medical decision support, though exact solutions are often intractable. Approximate solvers—point-based methods, particle filters—make them practical.</p>
</section>
<section id="try-it-yourself-73" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-73">Try It Yourself</h4>
<ol type="1">
<li>Model a simple POMDP: a robot in two rooms, with a noisy sensor that reports the wrong room 20% of the time. Update its belief after one observation.</li>
<li>Compare planning with an MDP vs.&nbsp;a POMDP in this domain. How does uncertainty affect the optimal policy?</li>
<li>Implement a particle filter for belief tracking in a grid world. How well does it approximate exact belief updates?</li>
</ol>
</section>
</section>
<section id="belief-states-and-their-representation" class="level3">
<h3 class="anchored" data-anchor-id="belief-states-and-their-representation">375. Belief States and Their Representation</h3>
<p>In POMDPs, the agent does not know the exact state—it maintains a belief state, a probability distribution over all possible states. Planning then occurs in belief space, where each point represents a different probability distribution. Belief states summarize all past actions and observations, making them sufficient statistics for decision-making.</p>
<section id="picture-in-your-head-74" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-74">Picture in Your Head</h4>
<p>Think of a detective tracking a suspect. After each clue, the detective updates a map with probabilities: 40% chance the suspect is downtown, 30% at the airport, 20% at home, 10% elsewhere. Even without certainty, this probability map (belief state) guides the next search action.</p>
</section>
<section id="deep-dive-74" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-74">Deep Dive</h4>
<ul>
<li><p>Belief state <span class="math inline">\(b(s)\)</span>: probability that the system is in state <span class="math inline">\(s\)</span>.</p></li>
<li><p>Belief update (Bayesian filter):</p>
<p><span class="math display">\[
b'(s') = \eta \cdot Z(o|s',a) \sum_{s} P(s'|s,a) \, b(s)
\]</span></p>
<p>where <span class="math inline">\(Z(o|s',a)\)</span> is observation likelihood and <span class="math inline">\(\eta\)</span> normalizes probabilities.</p></li>
<li><p>Belief space: continuous and high-dimensional (simple domains already yield infinitely many possible beliefs).</p></li>
</ul>
<p>Representations of belief states:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 33%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Representation</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Exact distribution (vector)</td>
<td>Precise</td>
<td>Infeasible for large state spaces</td>
</tr>
<tr class="even">
<td>Factored (e.g., DBNs)</td>
<td>Compact for structured domains</td>
<td>Requires independence assumptions</td>
</tr>
<tr class="odd">
<td>Sampling (particle filters)</td>
<td>Scales to large spaces</td>
<td>Approximate, may lose detail</td>
</tr>
</tbody>
</table>
<p>Belief states convert a POMDP into a continuous-state MDP, allowing dynamic programming or approximate methods to be applied.</p>
</section>
<section id="tiny-code-72" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-72">Tiny Code</h4>
<p>Belief update step with normalization:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> belief_update(belief, action, observation, P, Z):</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    new_belief <span class="op">=</span> {}</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s_next <span class="kw">in</span> P:</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>        prob <span class="op">=</span> <span class="bu">sum</span>(belief[s] <span class="op">*</span> P[s][action].get(s_next, <span class="dv">0</span>) <span class="cf">for</span> s <span class="kw">in</span> belief)</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>        new_belief[s_next] <span class="op">=</span> Z[s_next][action].get(observation, <span class="dv">0</span>) <span class="op">*</span> prob</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># normalize</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="bu">sum</span>(new_belief.values())</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {s: (new_belief[s]<span class="op">/</span>total <span class="cf">if</span> total <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span>) <span class="cf">for</span> s <span class="kw">in</span> new_belief}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-74" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-74">Why It Matters</h4>
<p>Belief states are the foundation of POMDP reasoning. They capture uncertainty explicitly, letting agents act optimally even without perfect information. This idea underlies particle filters in robotics, probabilistic tracking in vision, and adaptive strategies in dialogue systems.</p>
</section>
<section id="try-it-yourself-74" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-74">Try It Yourself</h4>
<ol type="1">
<li>Define a 3-state world (A, B, C). Start with uniform belief. After observing evidence favoring state B, update the belief.</li>
<li>Implement particle filtering with 100 samples for a robot localization problem. How well does it approximate exact belief?</li>
<li>Compare strategies with and without belief states in a navigation task with noisy sensors. Which is more robust?</li>
</ol>
</section>
</section>
<section id="approximate-methods-for-large-pomdps" class="level3">
<h3 class="anchored" data-anchor-id="approximate-methods-for-large-pomdps">376. Approximate Methods for Large POMDPs</h3>
<p>Exact solutions for POMDPs are computationally intractable in all but the smallest domains because belief space is continuous and high-dimensional. Approximate methods trade exactness for tractability, enabling planning in realistic environments. These methods approximate either the belief representation, the value function, or both.</p>
<section id="picture-in-your-head-75" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-75">Picture in Your Head</h4>
<p>Think of trying to navigate a foggy forest. Instead of mapping every possible position with perfect probabilities, you drop a handful of breadcrumbs (samples) to represent where you’re most likely to be. It’s not exact, but it’s good enough to guide your way forward.</p>
</section>
<section id="deep-dive-75" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-75">Deep Dive</h4>
<p>Types of approximations:</p>
<ol type="1">
<li><p>Belief state approximation</p>
<ul>
<li>Sampling (particle filters): maintain a finite set of samples instead of full probability vectors.</li>
<li>Factored representations: exploit independence among variables (e.g., dynamic Bayesian networks).</li>
</ul></li>
<li><p>Value function approximation</p>
<ul>
<li>Point-based methods: approximate the value function only at selected belief points (e.g., PBVI, SARSOP).</li>
<li>Linear function approximation: represent value as a weighted combination of features.</li>
<li>Neural networks: approximate policies or value functions directly.</li>
</ul></li>
<li><p>Policy approximation</p>
<ul>
<li>Use parameterized or reactive policies instead of optimal ones.</li>
<li>Learn policies via reinforcement learning in partially observable domains.</li>
</ul></li>
</ol>
<p>Comparison of approaches:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 25%">
<col style="width: 26%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>Approach</th>
<th>Idea</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Particle filtering</td>
<td>Sample beliefs</td>
<td>Scales well, simple</td>
<td>May lose rare states</td>
</tr>
<tr class="even">
<td>Point-based value iteration</td>
<td>Sample belief points</td>
<td>Efficient, good approximations</td>
<td>Requires careful sampling</td>
</tr>
<tr class="odd">
<td>Policy approximation</td>
<td>Directly approximate policies</td>
<td>Simple execution</td>
<td>May miss optimal strategies</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-73" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-73">Tiny Code</h4>
<p>Particle filter update (simplified):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> particle_filter_update(particles, action, observation, transition_model, obs_model, n_samples<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    new_particles <span class="op">=</span> []</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_samples):</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> random.choice(particles)</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># transition</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>        s_next_candidates <span class="op">=</span> transition_model[s][action]</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>        s_next <span class="op">=</span> random.choices(<span class="bu">list</span>(s_next_candidates.keys()), </span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>                                weights<span class="op">=</span>s_next_candidates.values())[<span class="dv">0</span>]</span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># weight by observation likelihood</span></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>        weight <span class="op">=</span> obs_model[s_next][action].get(observation, <span class="fl">0.01</span>)</span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>        new_particles.extend([s_next] <span class="op">*</span> <span class="bu">int</span>(weight <span class="op">*</span> <span class="dv">10</span>))  <span class="co"># crude resampling</span></span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> random.sample(new_particles, <span class="bu">min</span>(<span class="bu">len</span>(new_particles), n_samples))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-75" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-75">Why It Matters</h4>
<p>Approximate POMDP solvers make it possible to apply probabilistic planning to robotics, dialogue systems, and healthcare. Without approximation, belief space explosion makes POMDPs impractical. These methods balance optimality and scalability, enabling AI agents to act under realistic uncertainty.</p>
</section>
<section id="try-it-yourself-75" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-75">Try It Yourself</h4>
<ol type="1">
<li>Implement PBVI on a toy POMDP with 2 states and 2 observations. Compare its policy to the exact solution.</li>
<li>Run a particle filter with 10, 100, and 1000 particles for robot localization. How does accuracy change?</li>
<li>Train a neural policy in a POMDP grid world with noisy sensors. Does it approximate belief tracking implicitly?</li>
</ol>
</section>
</section>
<section id="monte-carlo-and-point-based-value-iteration" class="level3">
<h3 class="anchored" data-anchor-id="monte-carlo-and-point-based-value-iteration">377. Monte Carlo and Point-Based Value Iteration</h3>
<p>Since exact dynamic programming in POMDPs is infeasible for large problems, Monte Carlo methods and point-based value iteration (PBVI) offer practical approximations. They estimate or approximate the value function only at sampled belief states, reducing computation while retaining useful guidance for action selection.</p>
<section id="picture-in-your-head-76" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-76">Picture in Your Head</h4>
<p>Imagine trying to chart a vast ocean. Instead of mapping every square inch, you only map key islands (sampled beliefs). From those islands, you can still navigate effectively without needing a complete map.</p>
</section>
<section id="deep-dive-76" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-76">Deep Dive</h4>
<ul>
<li><p>Monte Carlo simulation</p>
<ul>
<li>Uses random rollouts to estimate value of a belief or policy.</li>
<li>Particularly useful for policy evaluation in large POMDPs.</li>
<li>Forms the basis of online methods like Monte Carlo Tree Search (MCTS) for POMDPs.</li>
</ul></li>
<li><p>Point-Based Value Iteration (PBVI)</p>
<ul>
<li>Instead of approximating value everywhere in belief space, select a set of representative belief points.</li>
<li>Backup value updates only at those points.</li>
<li>Iteratively refine the approximation as more points are added.</li>
</ul></li>
<li><p>SARSOP (Successive Approximations of the Reachable Space under Optimal Policies)</p>
<ul>
<li>Improves PBVI by focusing sampling on the subset of belief space reachable under optimal policies.</li>
<li>Yields high-quality solutions with fewer samples.</li>
</ul></li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 22%">
<col style="width: 26%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Idea</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Monte Carlo</td>
<td>Random rollouts</td>
<td>Simple, online</td>
<td>High variance, needs many samples</td>
</tr>
<tr class="even">
<td>PBVI</td>
<td>Sampled belief backups</td>
<td>Efficient, scalable</td>
<td>Approximate, depends on point selection</td>
</tr>
<tr class="odd">
<td>SARSOP</td>
<td>Focused PBVI</td>
<td>High-quality approximation</td>
<td>More complex implementation</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-74" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-74">Tiny Code</h4>
<p>Monte Carlo value estimation for a policy:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> monte_carlo_value(env, policy, n_episodes<span class="op">=</span><span class="dv">100</span>, gamma<span class="op">=</span><span class="fl">0.95</span>):</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_episodes):</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> env.reset()</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>        belief <span class="op">=</span> env.init_belief()</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>        G, discount <span class="op">=</span> <span class="dv">0</span>, <span class="dv">1</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(env.horizon):</span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>            action <span class="op">=</span> policy(belief)</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>            state, obs, reward <span class="op">=</span> env.step(state, action)</span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>            belief <span class="op">=</span> env.update_belief(belief, action, obs)</span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>            G <span class="op">+=</span> discount <span class="op">*</span> reward</span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>            discount <span class="op">*=</span> gamma</span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> G</span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total <span class="op">/</span> n_episodes</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-76" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-76">Why It Matters</h4>
<p>Monte Carlo and PBVI-style methods unlocked practical POMDP solving. They allow systems like dialogue managers, assistive robots, and autonomous vehicles to plan under uncertainty without being paralyzed by intractable computation. SARSOP in particular set benchmarks in scalable POMDP solving.</p>
</section>
<section id="try-it-yourself-76" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-76">Try It Yourself</h4>
<ol type="1">
<li>Implement PBVI on a toy POMDP with 2 states and 2 observations. Compare results with exact value iteration.</li>
<li>Use Monte Carlo rollouts to estimate the value of two competing policies in a noisy navigation task. Which policy performs better?</li>
<li>Explore SARSOP with an open-source POMDP solver. How much faster does it converge compared to plain PBVI?</li>
</ol>
</section>
</section>
<section id="hierarchical-and-factored-probabilistic-planning" class="level3">
<h3 class="anchored" data-anchor-id="hierarchical-and-factored-probabilistic-planning">378. Hierarchical and Factored Probabilistic Planning</h3>
<p>Large probabilistic planning problems quickly become intractable if treated as flat POMDPs or MDPs. Hierarchical planning breaks problems into smaller subproblems, while factored planning exploits structure by representing states with variables instead of atomic states. These approaches make probabilistic planning more scalable.</p>
<section id="picture-in-your-head-77" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-77">Picture in Your Head</h4>
<p>Imagine planning a cross-country road trip. Instead of thinking of every single turn across thousands of miles, you plan hierarchically: “drive to Chicago → then Denver → then San Francisco.” Within each leg, you only focus on local roads. Similarly, factored planning avoids listing every possible road configuration by describing the journey in terms of variables like <em>location, fuel, time</em>.</p>
</section>
<section id="deep-dive-77" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-77">Deep Dive</h4>
<ul>
<li><p>Hierarchical probabilistic planning</p>
<ul>
<li>Uses abstraction: high-level actions (options, macro-actions) decompose into low-level ones.</li>
<li>Reduces horizon length by focusing on major steps.</li>
<li>Example: “deliver package” might expand into “pick up package → travel to destination → drop off.”</li>
</ul></li>
<li><p>Factored probabilistic planning</p>
<ul>
<li>States are described with structured variables (e.g., location=room1, battery=low).</li>
<li>Transition models captured using Dynamic Bayesian Networks (DBNs).</li>
<li>Reduces state explosion: instead of enumerating all states, exploit variable independence.</li>
</ul></li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 55%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th>Approach</th>
<th>Benefit</th>
<th>Limitation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hierarchical</td>
<td>Simplifies long horizons, human-like abstraction</td>
<td>Needs careful action design</td>
</tr>
<tr class="even">
<td>Factored</td>
<td>Handles large state spaces compactly</td>
<td>Complex inference in DBNs</td>
</tr>
<tr class="odd">
<td>Combined</td>
<td>Scales best with both abstraction and structure</td>
<td>Implementation complexity</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-75" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-75">Tiny Code</h4>
<p>Example of a factored transition model with DBN-like structure:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co"># State variables: location, battery</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transition(state, action):</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    new_state <span class="op">=</span> state.copy()</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> action <span class="op">==</span> <span class="st">"move"</span>:</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state[<span class="st">"battery"</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>            new_state[<span class="st">"location"</span>] <span class="op">=</span> <span class="st">"room2"</span> <span class="cf">if</span> state[<span class="st">"location"</span>] <span class="op">==</span> <span class="st">"room1"</span> <span class="cf">else</span> <span class="st">"room1"</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>            new_state[<span class="st">"battery"</span>] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> action <span class="op">==</span> <span class="st">"recharge"</span>:</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>        new_state[<span class="st">"battery"</span>] <span class="op">=</span> <span class="bu">min</span>(<span class="dv">5</span>, state[<span class="st">"battery"</span>] <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_state</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-77" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-77">Why It Matters</h4>
<p>Hierarchical and factored approaches allow planners to scale beyond toy domains. They reflect how humans plan—using abstraction and structure—while remaining mathematically grounded. These methods are crucial for robotics, supply chain planning, and complex multi-agent systems.</p>
</section>
<section id="try-it-yourself-77" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-77">Try It Yourself</h4>
<ol type="1">
<li>Define a hierarchical plan for “making dinner” with high-level actions (cook, set table, serve). Expand into probabilistic low-level steps.</li>
<li>Model a robot navigation domain factored by variables (location, battery). Compare the number of explicit states vs.&nbsp;factored representation.</li>
<li>Combine hierarchy and factoring: model package delivery with high-level “deliver” decomposed into factored sub-actions. How does this reduce complexity?</li>
</ol>
</section>
</section>
<section id="applications-dialogue-systems-and-robot-navigation" class="level3">
<h3 class="anchored" data-anchor-id="applications-dialogue-systems-and-robot-navigation">379. Applications: Dialogue Systems and Robot Navigation</h3>
<p>POMDP-based planning under uncertainty has been widely applied in dialogue systems and robot navigation. Both domains face noisy observations, uncertain outcomes, and the need for adaptive decision-making. By maintaining belief states and planning probabilistically, agents can act robustly despite ambiguity.</p>
<section id="picture-in-your-head-78" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-78">Picture in Your Head</h4>
<p>Imagine a voice assistant: it hears “book a flight,” but background noise makes it only 70% confident. It asks a clarifying question before proceeding. Or picture a robot in a smoky room: sensors are unreliable, but by reasoning over belief states, it still finds the exit.</p>
</section>
<section id="deep-dive-78" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-78">Deep Dive</h4>
<ul>
<li><p>Dialogue systems</p>
<ul>
<li>States: user’s hidden intent.</li>
<li>Actions: system responses (ask question, confirm, execute).</li>
<li>Observations: noisy speech recognition results.</li>
<li>Belief tracking: maintain probabilities over possible intents.</li>
<li>Policy: balance between asking clarifying questions and acting confidently.</li>
<li>Example: POMDP-based dialogue managers outperform rule-based ones in noisy environments.</li>
</ul></li>
<li><p>Robot navigation</p>
<ul>
<li>States: robot’s location in an environment.</li>
<li>Actions: movements (forward, turn).</li>
<li>Observations: sensor readings (e.g., lidar, GPS), often noisy.</li>
<li>Belief tracking: particle filters approximate position.</li>
<li>Policy: plan paths robust to uncertainty (e.g., probabilistic roadmaps).</li>
</ul></li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 21%">
<col style="width: 27%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Hidden State</th>
<th>Observations</th>
<th>Key Challenge</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Dialogue</td>
<td>User intent</td>
<td>Speech/ASR results</td>
<td>Noisy language</td>
</tr>
<tr class="even">
<td>Navigation</td>
<td>Robot position</td>
<td>Sensor readings</td>
<td>Localization under noise</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-76" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-76">Tiny Code</h4>
<p>Belief update for a simple dialogue manager:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_dialogue_belief(belief, observation, obs_model):</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    new_belief <span class="op">=</span> {}</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> intent <span class="kw">in</span> belief:</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>        new_belief[intent] <span class="op">=</span> obs_model[intent].get(observation, <span class="dv">0</span>) <span class="op">*</span> belief[intent]</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># normalize</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="bu">sum</span>(new_belief.values())</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {i: (new_belief[i]<span class="op">/</span>total <span class="cf">if</span> total <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span>) <span class="cf">for</span> i <span class="kw">in</span> new_belief}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-78" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-78">Why It Matters</h4>
<p>Dialogue and navigation are real-world domains where uncertainty is unavoidable. POMDP-based approaches improved commercial dialogue assistants, human–robot collaboration, and autonomous exploration. They illustrate how abstract models of belief and probabilistic planning translate into practical AI systems.</p>
</section>
<section id="try-it-yourself-78" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-78">Try It Yourself</h4>
<ol type="1">
<li>Build a toy dialogue manager with 2 intents: “book flight” and “book hotel.” Simulate noisy observations and test how belief updates guide decisions.</li>
<li>Implement a robot in a 5x5 grid world with noisy movement (slips sideways 10% of the time). Track belief using a particle filter.</li>
<li>Compare a deterministic planner vs.&nbsp;a POMDP planner in both domains. Which adapts better under noise?</li>
</ol>
</section>
</section>
<section id="case-study-pomdp-based-decision-making" class="level3">
<h3 class="anchored" data-anchor-id="case-study-pomdp-based-decision-making">380. Case Study: POMDP-Based Decision Making</h3>
<p>POMDPs provide a unified framework for reasoning under uncertainty, balancing exploration and exploitation in partially observable, probabilistic environments. This case study highlights how POMDP-based decision making has been applied in real-world systems, from healthcare to assistive robotics, demonstrating both the power and practical challenges of the model.</p>
<section id="picture-in-your-head-79" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-79">Picture in Your Head</h4>
<p>Imagine a medical diagnosis assistant. A patient reports vague symptoms. The system can ask clarifying questions, order diagnostic tests, or propose a treatment. Each action carries costs and benefits, and test results are noisy. By maintaining beliefs over possible illnesses, the assistant recommends actions that maximize expected long-term health outcomes.</p>
</section>
<section id="deep-dive-79" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-79">Deep Dive</h4>
<p>Key domains:</p>
<ul>
<li><p>Healthcare decision support</p>
<ul>
<li>States: possible patient conditions.</li>
<li>Actions: diagnostic tests, treatments.</li>
<li>Observations: noisy test results.</li>
<li>Policy: balance between information gathering and treatment.</li>
<li>Example: optimizing tuberculosis diagnosis in developing regions with limited tests.</li>
</ul></li>
<li><p>Assistive robotics</p>
<ul>
<li>States: user goals (e.g., “drink water,” “read book”).</li>
<li>Actions: robot queries, movements, assistance actions.</li>
<li>Observations: gestures, speech, environment sensors.</li>
<li>Policy: infer goals while minimizing user burden.</li>
<li>Example: POMDP robots asking clarifying questions before delivering help.</li>
</ul></li>
<li><p>Autonomous exploration</p>
<ul>
<li>States: environment layout (partially known).</li>
<li>Actions: moves, scans.</li>
<li>Observations: noisy sensor readings.</li>
<li>Policy: explore efficiently while reducing uncertainty.</li>
</ul></li>
</ul>
<p>Benefits vs.&nbsp;challenges:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 44%">
<col style="width: 55%">
</colgroup>
<thead>
<tr class="header">
<th>Strength</th>
<th>Challenge</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Optimal under uncertainty</td>
<td>Computationally expensive</td>
</tr>
<tr class="even">
<td>Explicitly models observations</td>
<td>Belief updates costly in large spaces</td>
</tr>
<tr class="odd">
<td>General and domain-independent</td>
<td>Requires approximation for scalability</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-77" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-77">Tiny Code</h4>
<p>A high-level POMDP decision loop:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pomdp_decision_loop(belief, horizon, actions, update_fn, reward_fn, policy_fn):</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(horizon):</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>        action <span class="op">=</span> policy_fn(belief, actions)</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>        observation, reward <span class="op">=</span> environment_step(action)</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>        belief <span class="op">=</span> update_fn(belief, action, observation)</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Step </span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">: action=</span><span class="sc">{</span>action<span class="sc">}</span><span class="ss">, observation=</span><span class="sc">{</span>observation<span class="sc">}</span><span class="ss">, reward=</span><span class="sc">{</span>reward<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-79" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-79">Why It Matters</h4>
<p>POMDP-based systems show how probabilistic reasoning enables robust, adaptive decision making in uncertain, real-world environments. Even though exact solutions are often impractical, approximate solvers and domain-specific adaptations have made POMDPs central to applied AI in healthcare, robotics, and human–AI interaction.</p>
</section>
<section id="try-it-yourself-79" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-79">Try It Yourself</h4>
<ol type="1">
<li>Build a toy healthcare POMDP with two conditions (flu vs.&nbsp;cold) and noisy tests. How does the agent decide when to test vs.&nbsp;treat?</li>
<li>Simulate a robot assistant with two possible user goals. Can the robot infer the goal using POMDP belief updates?</li>
<li>Compare greedy strategies (act immediately) vs.&nbsp;POMDP policies (balance exploration and exploitation). Which achieves higher long-term reward?</li>
</ol>
</section>
</section>
</section>
<section id="chapter-39.-scheduling-and-resource-allocation" class="level2">
<h2 class="anchored" data-anchor-id="chapter-39.-scheduling-and-resource-allocation">Chapter 39. Scheduling and Resource Allocation</h2>
<section id="scheduling-as-a-search-and-optimization-problem" class="level3">
<h3 class="anchored" data-anchor-id="scheduling-as-a-search-and-optimization-problem">381. Scheduling as a Search and Optimization Problem</h3>
<p>Scheduling is the process of assigning tasks to resources over time while respecting constraints and optimizing objectives. In AI, scheduling is formulated as a search problem in a combinatorial space of possible schedules, or as an optimization problem seeking the best allocation under cost, time, or resource limits.</p>
<section id="picture-in-your-head-80" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-80">Picture in Your Head</h4>
<p>Think of a hospital with a set of surgeries, doctors, and operating rooms. Each surgery must be assigned to a doctor and a room, within certain time windows, while minimizing patient waiting time. The planner must juggle tasks, resources, and deadlines like pieces in a multidimensional puzzle.</p>
</section>
<section id="deep-dive-80" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-80">Deep Dive</h4>
<p>Key components of scheduling problems:</p>
<ul>
<li>Tasks/Jobs: activities that must be performed, often with durations.</li>
<li>Resources: machines, workers, rooms, or vehicles with limited availability.</li>
<li>Constraints: precedence (task A before B), capacity (only one job per machine), deadlines.</li>
<li>Objectives: minimize makespan (total completion time), maximize throughput, minimize cost, or balance multiple objectives.</li>
</ul>
<p>Formulations:</p>
<ul>
<li>As a search problem: nodes are partial schedules, actions assign tasks to resources.</li>
<li>As an optimization problem: encode constraints and objectives, solved via algorithms (e.g., ILP, heuristics, metaheuristics).</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 41%">
<col style="width: 47%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>Search Formulation</th>
<th>Optimization Formulation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Representation</td>
<td>Explicit states (partial/full schedules)</td>
<td>Variables, constraints, objective function</td>
</tr>
<tr class="even">
<td>Solvers</td>
<td>Backtracking, branch-and-bound, heuristic search</td>
<td>ILP solvers, constraint programming, local search</td>
</tr>
<tr class="odd">
<td>Strengths</td>
<td>Intuitive, can integrate AI search methods</td>
<td>Handles large-scale, multi-constraint problems</td>
</tr>
<tr class="even">
<td>Limitations</td>
<td>Combinatorial explosion</td>
<td>Requires careful modeling, may be slower on small tasks</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-78" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-78">Tiny Code</h4>
<p>Backtracking scheduler (toy version):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> schedule(tasks, resources, constraints, partial<span class="op">=</span>[]):</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> tasks:</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> partial</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> resources:</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>        task <span class="op">=</span> tasks[<span class="dv">0</span>]</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(c(task, r, partial) <span class="cf">for</span> c <span class="kw">in</span> constraints):</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>            new_partial <span class="op">=</span> partial <span class="op">+</span> [(task, r)]</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> schedule(tasks[<span class="dv">1</span>:], resources, constraints, new_partial)</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> result:</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> result</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-80" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-80">Why It Matters</h4>
<p>Scheduling underpins critical domains: manufacturing, healthcare, transportation, cloud computing, and project management. Treating scheduling as a search/optimization problem allows AI to systematically explore feasible allocations and optimize them under complex, real-world constraints.</p>
</section>
<section id="try-it-yourself-80" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-80">Try It Yourself</h4>
<ol type="1">
<li>Model a simple job-shop scheduling problem with 3 tasks and 2 machines. Try backtracking search to assign tasks.</li>
<li>Define constraints (e.g., task A before B, one machine at a time). How do they prune the search space?</li>
<li>Compare makespan results from naive assignment vs.&nbsp;optimized scheduling. How much improvement is possible?</li>
</ol>
</section>
</section>
<section id="types-of-scheduling-problems-job-shop-flow-shop-task-scheduling" class="level3">
<h3 class="anchored" data-anchor-id="types-of-scheduling-problems-job-shop-flow-shop-task-scheduling">382. Types of Scheduling Problems (Job-Shop, Flow-Shop, Task Scheduling)</h3>
<p>Scheduling comes in many flavors, depending on how tasks, resources, and constraints are structured. Three fundamental categories are job-shop scheduling, flow-shop scheduling, and task scheduling. Each captures different industrial and computational challenges.</p>
<section id="picture-in-your-head-81" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-81">Picture in Your Head</h4>
<p>Imagine three factories:</p>
<ul>
<li>In the first, custom jobs must visit machines in unique orders (job-shop).</li>
<li>In the second, all products move down the same ordered assembly line (flow-shop).</li>
<li>In the third, independent tasks are assigned to processors in a data center (task scheduling).</li>
</ul>
<p>Each setting looks like scheduling, but with different constraints shaping the problem.</p>
</section>
<section id="deep-dive-81" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-81">Deep Dive</h4>
<ul>
<li><p>Job-Shop Scheduling (JSSP)</p>
<ul>
<li>Jobs consist of sequences of operations, each requiring a specific machine.</li>
<li>Operation order varies per job.</li>
<li>Goal: minimize makespan or tardiness.</li>
<li>Extremely hard (NP-hard) due to combinatorial explosion.</li>
</ul></li>
<li><p>Flow-Shop Scheduling (FSSP)</p>
<ul>
<li>All jobs follow the same machine order (like assembly lines).</li>
<li>Simpler than job-shop, but still NP-hard for multiple machines.</li>
<li>Special case: permutation flow-shop (jobs visit machines in the same order).</li>
</ul></li>
<li><p>Task Scheduling (Processor Scheduling)</p>
<ul>
<li>Tasks are independent or have simple precedence constraints.</li>
<li>Common in computing (CPU scheduling, cloud workloads).</li>
<li>Objectives may include minimizing waiting time, maximizing throughput, or balancing load.</li>
</ul></li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 37%">
<col style="width: 17%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Structure</th>
<th>Example</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Job-Shop</td>
<td>Custom job routes</td>
<td>Car repair shop</td>
<td>Hardest</td>
</tr>
<tr class="even">
<td>Flow-Shop</td>
<td>Same route for all jobs</td>
<td>Assembly line</td>
<td>Easier than JSSP</td>
</tr>
<tr class="odd">
<td>Task Scheduling</td>
<td>Independent tasks or simple DAGs</td>
<td>Cloud servers</td>
<td>Varies with constraints</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-79" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-79">Tiny Code</h4>
<p>Greedy task scheduler (shortest processing time first):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> greedy_schedule(tasks):</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># tasks = [(id, duration)]</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>    tasks_sorted <span class="op">=</span> <span class="bu">sorted</span>(tasks, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>])</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    time, schedule <span class="op">=</span> <span class="dv">0</span>, []</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t, d <span class="kw">in</span> tasks_sorted:</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>        schedule.append((t, time, time<span class="op">+</span>d))</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>        time <span class="op">+=</span> d</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> schedule</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-81" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-81">Why It Matters</h4>
<p>These three scheduling types cover a spectrum from highly general (job-shop) to specialized (flow-shop, task scheduling). Understanding them provides the foundation for designing algorithms in factories, logistics, and computing systems. Each introduces unique trade-offs in search space size, constraints, and optimization goals.</p>
</section>
<section id="try-it-yourself-81" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-81">Try It Yourself</h4>
<ol type="1">
<li>Model a job-shop problem with 2 jobs and 2 machines. Draw the operation order. Can you find the optimal makespan by hand?</li>
<li>Implement the greedy task scheduler for 5 tasks with random durations. How close is it to optimal?</li>
<li>Compare flow-shop vs.&nbsp;job-shop complexity: how many possible schedules exist for 3 jobs, 3 machines in each case?</li>
</ol>
</section>
</section>
<section id="exact-algorithms-branch-and-bound-ilp" class="level3">
<h3 class="anchored" data-anchor-id="exact-algorithms-branch-and-bound-ilp">383. Exact Algorithms: Branch-and-Bound, ILP</h3>
<p>Exact scheduling algorithms aim to guarantee optimal solutions by exhaustively exploring possibilities, but with intelligent pruning or mathematical formulations to manage complexity. Two widely used approaches are branch-and-bound search and integer linear programming (ILP).</p>
<section id="picture-in-your-head-82" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-82">Picture in Your Head</h4>
<p>Think of solving a jigsaw puzzle. A brute-force approach tries every piece in every slot. Branch-and-bound prunes impossible partial assemblies early, while ILP turns the puzzle into equations—solve the math, and the whole picture falls into place.</p>
</section>
<section id="deep-dive-82" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-82">Deep Dive</h4>
<ul>
<li><p>Branch-and-Bound (B&amp;B)</p>
<ul>
<li>Explores the search tree of possible schedules.</li>
<li>Maintains best-known solution (upper bound).</li>
<li>Uses heuristic lower bounds to prune subtrees that cannot beat the best solution.</li>
<li>Works well on small-to-medium problems, but can still blow up exponentially.</li>
</ul></li>
<li><p>Integer Linear Programming (ILP)</p>
<ul>
<li>Formulate scheduling as a set of binary/integer variables with linear constraints.</li>
<li>Objective function encodes cost, makespan, or tardiness.</li>
<li>Solved using commercial or open-source solvers (CPLEX, Gurobi, CBC).</li>
<li>Handles large, complex constraints systematically.</li>
</ul></li>
</ul>
<p>Example ILP for task scheduling:</p>
<p><span class="math display">\[
\text{Minimize } \max_j (C_j)
\]</span></p>
<p>Subject to:</p>
<ul>
<li><span class="math inline">\(C_j \geq S_j + d_j\)</span> (completion times)</li>
<li>No two tasks overlap on the same machine.</li>
<li>Binary decision variables assign tasks to machines and order them.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 38%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Branch-and-Bound</td>
<td>Intuitive, adaptable</td>
<td>Exponential in worst case</td>
</tr>
<tr class="even">
<td>ILP</td>
<td>General, powerful solvers available</td>
<td>Modeling effort, may not scale perfectly</td>
</tr>
</tbody>
</table>
<p>Tiny Code Recipe (Python with pulp)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pulp</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ilp_scheduler(tasks, machines):</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># tasks = [(id, duration)]</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    prob <span class="op">=</span> pulp.LpProblem(<span class="st">"Scheduling"</span>, pulp.LpMinimize)</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> {t: pulp.LpVariable(<span class="ss">f"start_</span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">"</span>, lowBound<span class="op">=</span><span class="dv">0</span>) <span class="cf">for</span> t, _ <span class="kw">in</span> tasks}</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>    makespan <span class="op">=</span> pulp.LpVariable(<span class="st">"makespan"</span>, lowBound<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t, d <span class="kw">in</span> tasks:</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>        prob <span class="op">+=</span> start[t] <span class="op">+</span> d <span class="op">&lt;=</span> makespan</span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>    prob <span class="op">+=</span> makespan</span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>    prob.solve()</span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {t: pulp.value(start[t]) <span class="cf">for</span> t, _ <span class="kw">in</span> tasks}, pulp.value(makespan)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-82" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-82">Why It Matters</h4>
<p>Exact methods provide ground truth benchmarks for scheduling. Even though they may not scale to massive industrial problems, they are essential for small instances, validation, and as baselines against which heuristics and metaheuristics are measured.</p>
</section>
<section id="try-it-yourself-82" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-82">Try It Yourself</h4>
<ol type="1">
<li>Solve a 3-task, 2-machine scheduling problem with branch-and-bound. How many branches get pruned?</li>
<li>Write an ILP for 5 tasks with durations and deadlines. Use a solver to find the optimal schedule.</li>
<li>Compare results of ILP vs.&nbsp;greedy scheduling. How much better is the optimal solution?</li>
</ol>
</section>
</section>
<section id="heuristic-and-rule-based-scheduling-methods" class="level3">
<h3 class="anchored" data-anchor-id="heuristic-and-rule-based-scheduling-methods">384. Heuristic and Rule-Based Scheduling Methods</h3>
<p>When exact scheduling becomes too expensive, heuristics and rule-based methods offer practical alternatives. They do not guarantee optimality but often produce good schedules quickly. These approaches rely on intuitive or empirically tested rules, such as scheduling shortest tasks first or prioritizing urgent jobs.</p>
<section id="picture-in-your-head-83" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-83">Picture in Your Head</h4>
<p>Imagine a busy kitchen. The chef doesn’t calculate the mathematically optimal order of cooking. Instead, they follow simple rules: start long-boiling dishes first, fry items last, and prioritize orders due soon. These heuristics keep the kitchen running smoothly, even if not perfectly.</p>
</section>
<section id="deep-dive-83" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-83">Deep Dive</h4>
<p>Common heuristic rules:</p>
<ul>
<li>Shortest Processing Time (SPT): schedule tasks with smallest duration first → minimizes average completion time.</li>
<li>Longest Processing Time (LPT): schedule longest tasks first → useful for balancing parallel machines.</li>
<li>Earliest Due Date (EDD): prioritize tasks with closest deadlines → reduces lateness.</li>
<li>Critical Ratio (CR): ratio of time remaining to processing time; prioritize lowest ratio.</li>
<li>Slack Time: prioritize tasks with little slack between due date and duration.</li>
</ul>
<p>Rule-based scheduling is often used in dynamic, real-time systems where decisions must be fast.</p>
<p>Comparison of rules:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 32%">
<col style="width: 23%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th>Rule</th>
<th>Goal</th>
<th>Strength</th>
<th>Weakness</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SPT</td>
<td>Minimize avg. flow time</td>
<td>Simple, effective</td>
<td>May delay long tasks</td>
</tr>
<tr class="even">
<td>LPT</td>
<td>Balance load</td>
<td>Prevents overload</td>
<td>May increase waiting</td>
</tr>
<tr class="odd">
<td>EDD</td>
<td>Meet deadlines</td>
<td>Reduces lateness</td>
<td>Ignores processing time</td>
</tr>
<tr class="even">
<td>CR</td>
<td>Balance urgency &amp; size</td>
<td>Adaptive</td>
<td>Requires accurate due dates</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-80" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-80">Tiny Code</h4>
<p>SPT vs.&nbsp;EDD example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spt_schedule(tasks):</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># tasks = [(id, duration, due)]</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(tasks, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>])  <span class="co"># by duration</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> edd_schedule(tasks):</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(tasks, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">2</span>])  <span class="co"># by due date</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-83" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-83">Why It Matters</h4>
<p>Heuristic and rule-based scheduling is widely used in factories, hospitals, and computing clusters where speed and simplicity matter more than strict optimality. They often strike the right balance between efficiency and practicality.</p>
</section>
<section id="try-it-yourself-83" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-83">Try It Yourself</h4>
<ol type="1">
<li>Generate 5 random tasks with durations and due dates. Compare schedules produced by SPT vs.&nbsp;EDD. Which minimizes lateness?</li>
<li>Implement Critical Ratio scheduling. How does it perform when tasks have widely varying due dates?</li>
<li>In a parallel-machine setting, test LPT vs.&nbsp;random assignment. How much better is load balance?</li>
</ol>
</section>
</section>
<section id="constraint-based-scheduling-systems" class="level3">
<h3 class="anchored" data-anchor-id="constraint-based-scheduling-systems">385. Constraint-Based Scheduling Systems</h3>
<p>Constraint-based scheduling treats scheduling as a constraint satisfaction problem (CSP). Tasks, resources, and time slots are represented as variables with domains, and constraints enforce ordering, resource capacities, and deadlines. A solution is any assignment that satisfies all constraints; optimization can then be added to improve quality.</p>
<section id="picture-in-your-head-84" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-84">Picture in Your Head</h4>
<p>Imagine filling out a giant calendar. Each task must be assigned to a time slot and resource, but no two tasks can overlap on the same resource, and some must happen before others. Constraint solvers act like an intelligent assistant, rejecting invalid placements until a feasible schedule emerges.</p>
</section>
<section id="deep-dive-84" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-84">Deep Dive</h4>
<p>Key components:</p>
<ul>
<li><p>Variables: start times, resource assignments, task durations.</p></li>
<li><p>Domains: allowable values (time intervals, machines).</p></li>
<li><p>Constraints:</p>
<ul>
<li>Precedence (Task A before Task B).</li>
<li>Resource capacity (only one job per machine).</li>
<li>Temporal windows (Task C must finish before deadline).</li>
</ul></li>
<li><p>Objective: minimize makespan, lateness, or cost.</p></li>
</ul>
<p>Techniques used:</p>
<ul>
<li>Constraint Propagation: prune infeasible values early (e.g., AC-3).</li>
<li>Global Constraints: specialized constraints like <em>cumulative</em> (resource usage ≤ capacity).</li>
<li>Search with Propagation: backtracking guided by constraint consistency.</li>
<li>Hybrid CSP + Optimization: combine with branch-and-bound or linear programming.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 51%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Constraint-Based</th>
<th>Heuristic/Rule-Based</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Generality</td>
<td>Handles arbitrary constraints</td>
<td>Simple, domain-specific</td>
</tr>
<tr class="even">
<td>Optimality</td>
<td>Can be exact if search is exhaustive</td>
<td>Not guaranteed</td>
</tr>
<tr class="odd">
<td>Performance</td>
<td>Slower in large cases</td>
<td>Very fast</td>
</tr>
</tbody>
</table>
<p>Tiny Code Recipe (Python with OR-Tools)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ortools.sat.python <span class="im">import</span> cp_model</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> constraint_schedule(tasks, horizon):</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> cp_model.CpModel()</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    start_vars, intervals <span class="op">=</span> {}, []</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t, d <span class="kw">in</span> tasks.items():</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>        start_vars[t] <span class="op">=</span> model.NewIntVar(<span class="dv">0</span>, horizon, <span class="ss">f"start_</span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>        intervals.append(model.NewIntervalVar(start_vars[t], d, start_vars[t] <span class="op">+</span> d, <span class="ss">f"interval_</span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">"</span>))</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>    model.AddNoOverlap(intervals)</span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>    makespan <span class="op">=</span> model.NewIntVar(<span class="dv">0</span>, horizon, <span class="st">"makespan"</span>)</span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t, d <span class="kw">in</span> tasks.items():</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>        model.Add(makespan <span class="op">&gt;=</span> start_vars[t] <span class="op">+</span> d)</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>    model.Minimize(makespan)</span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    solver <span class="op">=</span> cp_model.CpSolver()</span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>    solver.Solve(model)</span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {t: solver.Value(start_vars[t]) <span class="cf">for</span> t <span class="kw">in</span> tasks}, solver.Value(makespan)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-84" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-84">Why It Matters</h4>
<p>Constraint-based scheduling powers modern industrial tools. It is flexible enough to encode diverse requirements in manufacturing, cloud computing, or transport. Unlike simple heuristics, it guarantees feasibility and can often deliver near-optimal or optimal solutions.</p>
</section>
<section id="try-it-yourself-84" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-84">Try It Yourself</h4>
<ol type="1">
<li>Encode 3 tasks with durations 3, 4, and 2, and one machine. Use a CSP solver to minimize makespan.</li>
<li>Add a precedence constraint: Task 1 must finish before Task 2. How does the schedule change?</li>
<li>Extend the model with 2 machines and test how the solver distributes tasks across them.</li>
</ol>
</section>
</section>
<section id="resource-allocation-with-limited-capacity" class="level3">
<h3 class="anchored" data-anchor-id="resource-allocation-with-limited-capacity">386. Resource Allocation with Limited Capacity</h3>
<p>Resource allocation is at the heart of scheduling: deciding how to distribute limited resources among competing tasks. Unlike simple task ordering, this requires balancing demand against capacity, often under dynamic or uncertain conditions. The challenge lies in ensuring that no resource is over-committed while still meeting deadlines and optimization goals.</p>
<section id="picture-in-your-head-85" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-85">Picture in Your Head</h4>
<p>Imagine a data center with 10 servers and dozens of jobs arriving. Each job consumes CPU, memory, and bandwidth. The scheduler must assign resources so that no server exceeds its limits, while keeping jobs running smoothly.</p>
</section>
<section id="deep-dive-85" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-85">Deep Dive</h4>
<p>Key features of resource-constrained scheduling:</p>
<ul>
<li>Capacity limits: each resource (machine, worker, vehicle, CPU core) has finite availability.</li>
<li>Multi-resource tasks: tasks may need multiple resources simultaneously (e.g., machine + operator).</li>
<li>Conflicts: tasks compete for the same resources, requiring prioritization.</li>
<li>Dynamic demand: in real systems, tasks may arrive unpredictably.</li>
</ul>
<p>Common approaches:</p>
<ul>
<li>Constraint-based models: enforce cumulative resource constraints.</li>
<li>Greedy heuristics: assign resources to the most urgent or smallest tasks first.</li>
<li>Linear/Integer Programming: represent capacity as inequalities.</li>
<li>Fair-share allocation: ensure balanced access across users or jobs.</li>
</ul>
<p>Example inequality constraint for resource usage:</p>
<p><span class="math display">\[
\sum_{i \in T} x_{i,r} \cdot demand_{i,r} \leq capacity_r \quad \forall r
\]</span></p>
<p>Comparison of methods:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 28%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th>Approach</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Greedy</td>
<td>Fast, simple</td>
<td>May lead to starvation or suboptimal schedules</td>
</tr>
<tr class="even">
<td>Constraint-based</td>
<td>Guarantees feasibility</td>
<td>May be slow for large systems</td>
</tr>
<tr class="odd">
<td>ILP</td>
<td>Optimal for small-medium</td>
<td>Scalability issues</td>
</tr>
<tr class="even">
<td>Dynamic policies</td>
<td>Handle arrivals, fairness</td>
<td>Harder to analyze optimally</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-81" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-81">Tiny Code</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> allocate_resources(tasks, capacity):</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    allocation <span class="op">=</span> {}</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t, demand <span class="kw">in</span> tasks.items():</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>        feasible <span class="op">=</span> <span class="bu">all</span>(demand[r] <span class="op">&lt;=</span> capacity[r] <span class="cf">for</span> r <span class="kw">in</span> demand)</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> feasible:</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>            allocation[t] <span class="op">=</span> demand</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> r <span class="kw">in</span> demand:</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>                capacity[r] <span class="op">-=</span> demand[r]</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>            allocation[t] <span class="op">=</span> <span class="st">"Not allocated"</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> allocation, capacity</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-85" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-85">Why It Matters</h4>
<p>Resource allocation problems appear everywhere: project management (assigning staff to tasks), cloud computing (scheduling jobs on servers), transport logistics (vehicles to routes), and healthcare (doctors to patients). Handling limited capacity intelligently is what makes scheduling useful in practice.</p>
</section>
<section id="try-it-yourself-85" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-85">Try It Yourself</h4>
<ol type="1">
<li>Model 3 tasks requiring different CPU and memory demands on a 2-core, 8GB machine. Can all fit?</li>
<li>Implement a greedy allocator that always serves the job with highest priority first. What happens to low-priority jobs?</li>
<li>Extend the model so that tasks consume resources for a duration. How does it change allocation dynamics?</li>
</ol>
</section>
</section>
<section id="multi-objective-scheduling-and-trade-offs" class="level3">
<h3 class="anchored" data-anchor-id="multi-objective-scheduling-and-trade-offs">387. Multi-Objective Scheduling and Trade-Offs</h3>
<p>In many domains, scheduling must optimize more than one objective at the same time. Multi-objective scheduling involves balancing competing goals, such as minimizing completion time, reducing costs, maximizing resource utilization, and ensuring fairness. No single solution optimizes all objectives perfectly, so planners seek Pareto-optimal trade-offs.</p>
<section id="picture-in-your-head-86" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-86">Picture in Your Head</h4>
<p>Imagine running a hospital. You want to minimize patient waiting times, maximize the number of surgeries completed, and reduce staff overtime. Optimizing one goal (e.g., throughput) might worsen another (e.g., staff fatigue). The “best” schedule depends on how you balance these conflicting objectives.</p>
</section>
<section id="deep-dive-86" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-86">Deep Dive</h4>
<p>Common objectives:</p>
<ul>
<li>Makespan minimization: reduce total completion time.</li>
<li>Flow time minimization: reduce average job turnaround.</li>
<li>Resource utilization: maximize how efficiently machines or workers are used.</li>
<li>Cost minimization: reduce overtime, energy, or transportation costs.</li>
<li>Fairness: balance workload across users or machines.</li>
</ul>
<p>Approaches:</p>
<ul>
<li>Weighted sum method: combine objectives into a single score with weights.</li>
<li>Goal programming: prioritize objectives hierarchically.</li>
<li>Pareto optimization: search for a frontier of non-dominated solutions.</li>
<li>Evolutionary algorithms: explore trade-offs via populations of candidate schedules.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 32%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Weighted sum</td>
<td>Simple, intuitive</td>
<td>Sensitive to weight choice</td>
</tr>
<tr class="even">
<td>Goal programming</td>
<td>Prioritizes objectives</td>
<td>Lower-priority goals may be ignored</td>
</tr>
<tr class="odd">
<td>Pareto frontier</td>
<td>Captures trade-offs</td>
<td>Large solution sets, harder to choose</td>
</tr>
<tr class="even">
<td>Evolutionary algos</td>
<td>Explore complex trade-offs</td>
<td>May need tuning, approximate</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-82" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-82">Tiny Code</h4>
<p>Weighted-sum scoring of schedules:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> score_schedule(schedule, weights):</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># schedule contains {"makespan": X, "cost": Y, "utilization": Z}</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (weights[<span class="st">"makespan"</span>] <span class="op">*</span> schedule[<span class="st">"makespan"</span>] <span class="op">+</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>            weights[<span class="st">"cost"</span>] <span class="op">*</span> schedule[<span class="st">"cost"</span>] <span class="op">-</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>            weights[<span class="st">"utilization"</span>] <span class="op">*</span> schedule[<span class="st">"utilization"</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-86" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-86">Why It Matters</h4>
<p>Real-world scheduling rarely has a single goal. Airlines, hospitals, factories, and cloud systems all juggle competing demands. Multi-objective optimization gives decision-makers flexibility: instead of one “best” plan, they gain a set of alternatives that balance trade-offs differently.</p>
</section>
<section id="try-it-yourself-86" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-86">Try It Yourself</h4>
<ol type="1">
<li>Define three schedules with different makespan, cost, and utilization. Compute weighted scores under two different weight settings. Which schedule is preferred in each case?</li>
<li>Plot a Pareto frontier for 5 candidate schedules in two dimensions (makespan vs.&nbsp;cost). Which are non-dominated?</li>
<li>Modify a genetic algorithm to handle multiple objectives. How does the diversity of solutions compare to single-objective optimization?</li>
</ol>
</section>
</section>
<section id="approximation-algorithms-for-scheduling" class="level3">
<h3 class="anchored" data-anchor-id="approximation-algorithms-for-scheduling">388. Approximation Algorithms for Scheduling</h3>
<p>Many scheduling problems are NP-hard, meaning exact solutions are impractical for large instances. Approximation algorithms provide provably near-optimal solutions within guaranteed bounds on performance. They balance efficiency with quality, ensuring solutions are “good enough” in reasonable time.</p>
<section id="picture-in-your-head-87" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-87">Picture in Your Head</h4>
<p>Imagine a delivery company scheduling trucks. Computing the absolute best routes and assignments might take days, but an approximation algorithm guarantees that the plan is within, say, 10% of the optimal. The company can deliver packages on time without wasting computational resources.</p>
</section>
<section id="deep-dive-87" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-87">Deep Dive</h4>
<p>Examples of approximation algorithms:</p>
<ul>
<li><p>List scheduling (Graham’s algorithm)</p>
<ul>
<li>For parallel machine scheduling (minimizing makespan).</li>
<li>Greedy: assign each job to the next available machine.</li>
<li>Guarantee: ≤ 2 × optimal makespan.</li>
</ul></li>
<li><p>Longest Processing Time First (LPT)</p>
<ul>
<li>Improves list scheduling by ordering jobs in descending duration.</li>
<li>Bound: ≤ <span class="math inline">\(\frac{4}{3}\)</span> × optimal for ≥ 2 machines.</li>
</ul></li>
<li><p>Approximation schemes</p>
<ul>
<li>PTAS (Polynomial-Time Approximation Scheme): runs in polytime for fixed ε, produces solution within (1+ε) × OPT.</li>
<li>FPTAS (Fully Polynomial-Time Approximation Scheme): polynomial in both input size and 1/ε.</li>
</ul></li>
</ul>
<p>Comparison of strategies:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 26%">
<col style="width: 20%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Problem</th>
<th>Approx. Ratio</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>List scheduling</td>
<td>Parallel machines</td>
<td>2</td>
<td>O(n log m)</td>
</tr>
<tr class="even">
<td>LPT</td>
<td>Parallel machines</td>
<td>4/3</td>
<td>O(n log n)</td>
</tr>
<tr class="odd">
<td>PTAS</td>
<td>Restricted cases</td>
<td>(1+ε)</td>
<td>Polynomial (slower)</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-83" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-83">Tiny Code</h4>
<p>Greedy list scheduling for parallel machines:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> list_schedule(jobs, m):</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># jobs = [durations], m = number of machines</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    machines <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> m</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    schedule <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> job <span class="kw">in</span> jobs:</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> machines.index(<span class="bu">min</span>(machines))  <span class="co"># earliest available machine</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>        schedule[i].append(job)</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>        machines[i] <span class="op">+=</span> job</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> schedule, <span class="bu">max</span>(machines)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-87" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-87">Why It Matters</h4>
<p>Approximation algorithms make scheduling feasible in large-scale, high-stakes domains such as cloud computing, manufacturing, and transport. Even though optimality is sacrificed, guarantees provide confidence that solutions won’t be arbitrarily bad.</p>
</section>
<section id="try-it-yourself-87" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-87">Try It Yourself</h4>
<ol type="1">
<li>Implement list scheduling for 10 jobs on 3 machines. Compare makespan to the best possible arrangement by brute force.</li>
<li>Run LPT vs.&nbsp;simple list scheduling on the same jobs. Does ordering improve results?</li>
<li>Explore how approximation ratio changes when increasing the number of machines.</li>
</ol>
</section>
</section>
<section id="applications-manufacturing-cloud-computing-healthcare" class="level3">
<h3 class="anchored" data-anchor-id="applications-manufacturing-cloud-computing-healthcare">389. Applications: Manufacturing, Cloud Computing, Healthcare</h3>
<p>Scheduling is not just a theoretical exercise—it directly impacts efficiency and outcomes in real-world systems. Three domains where scheduling plays a central role are manufacturing, cloud computing, and healthcare. Each requires balancing constraints, optimizing performance, and adapting to dynamic conditions.</p>
<section id="picture-in-your-head-88" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-88">Picture in Your Head</h4>
<p>Think of three settings:</p>
<ul>
<li>A factory floor where machines and workers must be coordinated to minimize downtime.</li>
<li>A cloud data center where thousands of jobs compete for CPU and memory.</li>
<li>A hospital where patients, doctors, and operating rooms must be scheduled carefully to save lives.</li>
</ul>
<p>Each is a scheduling problem with different priorities and stakes.</p>
</section>
<section id="deep-dive-88" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-88">Deep Dive</h4>
<ul>
<li><p>Manufacturing</p>
<ul>
<li>Problems: job-shop scheduling, resource allocation, minimizing makespan.</li>
<li>Constraints: machine availability, setup times, supply chain delays.</li>
<li>Goals: throughput, reduced idle time, cost efficiency.</li>
<li>Techniques: constraint-based models, metaheuristics, approximation algorithms.</li>
</ul></li>
<li><p>Cloud Computing</p>
<ul>
<li>Problems: assigning jobs to servers, VM placement, energy-efficient scheduling.</li>
<li>Constraints: CPU/memory limits, network bandwidth, SLAs (service-level agreements).</li>
<li>Goals: maximize throughput, minimize response time, reduce energy costs.</li>
<li>Techniques: dynamic scheduling, heuristic and rule-based policies, reinforcement learning.</li>
</ul></li>
<li><p>Healthcare</p>
<ul>
<li>Problems: operating room scheduling, patient appointments, staff rosters.</li>
<li>Constraints: resource conflicts, emergencies, strict deadlines.</li>
<li>Goals: reduce patient wait times, balance staff workload, maximize utilization.</li>
<li>Techniques: constraint programming, multi-objective optimization, simulation.</li>
</ul></li>
</ul>
<p>Comparison of domains:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 33%">
<col style="width: 24%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Key Constraint</th>
<th>Primary Goal</th>
<th>Typical Method</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Manufacturing</td>
<td>Machine capacity</td>
<td>Makespan minimization</td>
<td>Job-shop, metaheuristics</td>
</tr>
<tr class="even">
<td>Cloud</td>
<td>Resource limits</td>
<td>Throughput, SLAs</td>
<td>Dynamic, heuristic</td>
</tr>
<tr class="odd">
<td>Healthcare</td>
<td>Human &amp; facility availability</td>
<td>Wait time, fairness</td>
<td>CSP, multi-objective</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-84" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-84">Tiny Code</h4>
<p>Simple round-robin scheduler for cloud tasks:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> round_robin(tasks, machines):</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>    schedule <span class="op">=</span> {m: [] <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(machines)}</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, t <span class="kw">in</span> <span class="bu">enumerate</span>(tasks):</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> i <span class="op">%</span> machines</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>        schedule[m].append(t)</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> schedule</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-88" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-88">Why It Matters</h4>
<p>Scheduling in these domains has huge economic and social impact: factories save costs, cloud providers meet customer demands, and hospitals save lives. The theory of scheduling translates directly into tools that keep industries and services functioning efficiently.</p>
</section>
<section id="try-it-yourself-88" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-88">Try It Yourself</h4>
<ol type="1">
<li>Model a factory with 3 machines and 5 jobs of varying lengths. Test greedy vs.&nbsp;constraint-based scheduling.</li>
<li>Write a cloud scheduler that balances load across servers while respecting CPU limits. How does it differ from factory scheduling?</li>
<li>Simulate hospital scheduling for 2 surgeons, 3 rooms, and 5 patients. How do emergency cases disrupt the plan?</li>
</ol>
</section>
</section>
<section id="case-study-large-scale-scheduling-systems" class="level3">
<h3 class="anchored" data-anchor-id="case-study-large-scale-scheduling-systems">390. Case Study: Large-Scale Scheduling Systems</h3>
<p>Large-scale scheduling systems coordinate thousands to millions of tasks across distributed resources. Unlike toy scheduling problems, they must handle scale, heterogeneity, and dynamism while balancing efficiency, fairness, and reliability. Examples include airline crew scheduling, cloud cluster management, and global logistics.</p>
<section id="picture-in-your-head-89" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-89">Picture in Your Head</h4>
<p>Think of an airline: hundreds of planes, thousands of crew members, and tens of thousands of flights each day. Each assignment must respect legal limits, crew rest requirements, and passenger connections. Behind the scenes, scheduling software continuously solves massive optimization problems.</p>
</section>
<section id="deep-dive-89" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-89">Deep Dive</h4>
<p>Challenges in large-scale scheduling:</p>
<ul>
<li>Scale: millions of variables and constraints.</li>
<li>Heterogeneity: tasks differ in size, priority, and resource demands.</li>
<li>Dynamics: tasks arrive online, resources fail, constraints change in real time.</li>
<li>Multi-objective trade-offs: throughput vs.&nbsp;cost vs.&nbsp;fairness vs.&nbsp;energy efficiency.</li>
</ul>
<p>Key techniques:</p>
<ul>
<li>Decomposition methods: break the problem into subproblems (e.g., master/worker scheduling).</li>
<li>Hybrid algorithms: combine heuristics with exact optimization for subproblems.</li>
<li>Online scheduling: adapt dynamically as jobs arrive and conditions change.</li>
<li>Simulation &amp; what-if analysis: test schedules under uncertainty before committing.</li>
</ul>
<p>Examples:</p>
<ul>
<li>Google Borg / Kubernetes: schedule containerized workloads in cloud clusters, balancing efficiency and reliability.</li>
<li>Airline crew scheduling: formulated as huge ILPs, solved with decomposition + heuristics.</li>
<li>Amazon logistics: real-time resource allocation for trucks, routes, and packages.</li>
</ul>
<p>Comparison of strategies:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 44%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>Approach</th>
<th>Best For</th>
<th>Limitation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Decomposition</td>
<td>Very large structured problems</td>
<td>Subproblem coordination</td>
</tr>
<tr class="even">
<td>Hybrid</td>
<td>Balance between speed &amp; accuracy</td>
<td>More complex implementation</td>
</tr>
<tr class="odd">
<td>Online</td>
<td>Dynamic, streaming jobs</td>
<td>No guarantee of optimality</td>
</tr>
<tr class="even">
<td>Simulation</td>
<td>Risk-aware scheduling</td>
<td>Computational overhead</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-85" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-85">Tiny Code</h4>
<p>Toy online scheduler (greedy assignment as jobs arrive):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> online_scheduler(jobs, machines):</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    load <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> machines</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    schedule <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(machines)]</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> job <span class="kw">in</span> jobs:</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> <span class="bu">min</span>(<span class="bu">range</span>(machines), key<span class="op">=</span><span class="kw">lambda</span> m: load[m])</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>        schedule[i].append(job)</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>        load[i] <span class="op">+=</span> job</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> schedule, load</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-89" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-89">Why It Matters</h4>
<p>Large-scale scheduling systems are the backbone of modern industries—powering airlines, cloud services, logistics, and healthcare. Even small improvements in scheduling efficiency can save millions of dollars or significantly improve service quality. These systems demonstrate how theoretical AI scheduling models scale into mission-critical infrastructure.</p>
</section>
<section id="try-it-yourself-89" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-89">Try It Yourself</h4>
<ol type="1">
<li>Implement an online greedy scheduler for 100 jobs and 10 machines. How balanced is the final load?</li>
<li>Compare offline (batch) scheduling vs.&nbsp;online scheduling. Which performs better when jobs arrive unpredictably?</li>
<li>Explore decomposition: split a scheduling problem into two clusters of machines. Does solving subproblems separately improve runtime?</li>
</ol>
</section>
</section>
</section>
<section id="chapter-40.-meta-reasoning-and-anytime-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="chapter-40.-meta-reasoning-and-anytime-algorithms">Chapter 40. Meta Reasoning and Anytime Algorithms</h2>
<section id="meta-reasoning-reasoning-about-reasoning" class="level3">
<h3 class="anchored" data-anchor-id="meta-reasoning-reasoning-about-reasoning">391. Meta-Reasoning: Reasoning About Reasoning</h3>
<p>Meta-reasoning is the study of how an AI system allocates its own computational effort. Instead of only solving external problems, the agent must decide <em>which computations to perform, in what order, and for how long</em> to maximize utility under limited resources. In scheduling, meta-reasoning governs when to expand the search tree, when to refine heuristics, and when to stop.</p>
<section id="picture-in-your-head-90" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-90">Picture in Your Head</h4>
<p>Imagine a chess player under time pressure. They cannot calculate every line to checkmate, so they decide: “I’ll analyze this candidate move for 30 seconds, then switch if it looks weak.” That self-allocation of reasoning effort is meta-reasoning.</p>
</section>
<section id="deep-dive-90" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-90">Deep Dive</h4>
<p>Core principles:</p>
<ul>
<li>Computational actions: reasoning steps are themselves treated as actions with costs and benefits.</li>
<li>Value of computation (VoC): how much expected improvement in decision quality results from an additional unit of computation.</li>
<li>Metalevel control: deciding dynamically which computation to run, stop, or continue.</li>
</ul>
<p>Approaches:</p>
<ul>
<li>Bounded rationality models: approximate rational decision-making under resource constraints.</li>
<li>Metalevel MDPs: model reasoning as a decision process over computational states.</li>
<li>Heuristic control: use meta-rules like “stop search when heuristic gain &lt; threshold.”</li>
</ul>
<p>Comparison with standard reasoning:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 10%">
<col style="width: 34%">
<col style="width: 55%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Standard Reasoning</th>
<th>Meta-Reasoning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Focus</td>
<td>External problem only</td>
<td>Both external and computational problem</td>
</tr>
<tr class="even">
<td>Cost</td>
<td>Ignores computation time</td>
<td>Accounts for time/effort trade-offs</td>
</tr>
<tr class="odd">
<td>Output</td>
<td>Solution</td>
<td>Solution <em>and</em> reasoning policy</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-86" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-86">Tiny Code</h4>
<p>Toy meta-reasoner using VoC threshold:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> meta_reasoning(possible_computations, threshold<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="va">None</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> comp <span class="kw">in</span> possible_computations:</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> comp[<span class="st">"expected_gain"</span>] <span class="op">/</span> comp[<span class="st">"cost"</span>] <span class="op">&gt;</span> threshold:</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> comp</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-90" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-90">Why It Matters</h4>
<p>Meta-reasoning is crucial for AI systems operating in real time with limited computation: robots, games, and autonomous vehicles. It transforms “search until done” into “search smartly under constraints,” improving responsiveness and robustness.</p>
</section>
<section id="try-it-yourself-90" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-90">Try It Yourself</h4>
<ol type="1">
<li>Simulate an agent solving puzzles with limited time. How does meta-reasoning decide which subproblems to explore first?</li>
<li>Implement a threshold-based stop rule: stop search when additional expansion yields &lt;5% improvement.</li>
<li>Compare fixed-depth search vs.&nbsp;meta-reasoning-driven search. Which gives better results under strict time limits?</li>
</ol>
</section>
</section>
<section id="trade-offs-between-time-accuracy-and-computation" class="level3">
<h3 class="anchored" data-anchor-id="trade-offs-between-time-accuracy-and-computation">392. Trade-Offs Between Time, Accuracy, and Computation</h3>
<p>AI systems rarely have unlimited resources. They must trade off time spent reasoning, accuracy of the solution, and computational cost. Meta-reasoning formalizes this trade-off: deciding when a “good enough” solution is preferable to an exact one, especially in time-critical or resource-constrained environments.</p>
<section id="picture-in-your-head-91" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-91">Picture in Your Head</h4>
<p>Think of emergency responders using a navigation app during a flood. A perfectly optimal route calculation might take too long, while a quick approximation could save lives. Here, trading accuracy for speed is not just acceptable—it is necessary.</p>
</section>
<section id="deep-dive-91" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-91">Deep Dive</h4>
<p>Three key dimensions:</p>
<ul>
<li>Time (latency): how quickly the system must act.</li>
<li>Accuracy (solution quality): closeness to the optimal outcome.</li>
<li>Computation (resources): CPU cycles, memory, or energy consumed.</li>
</ul>
<p>Trade-off strategies:</p>
<ul>
<li>Anytime algorithms: produce progressively better solutions if given more time.</li>
<li>Bounded rationality models: optimize utility under resource limits (Herbert Simon’s principle).</li>
<li>Performance profiles: characterize how solution quality improves with computation.</li>
</ul>
<p>Example scenarios:</p>
<ul>
<li>Navigation: fast but approximate path vs.&nbsp;slower optimal route.</li>
<li>Scheduling: heuristic solution in seconds vs.&nbsp;optimal ILP after hours.</li>
<li>Robotics: partial plan for immediate safety vs.&nbsp;full plan for long-term efficiency.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Priority</th>
<th>Outcome</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Time-critical</td>
<td>Faster, approximate solutions</td>
</tr>
<tr class="even">
<td>Accuracy-critical</td>
<td>Optimal or near-optimal, regardless of delay</td>
</tr>
<tr class="odd">
<td>Resource-limited</td>
<td>Lightweight heuristics, reduced state space</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-87" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-87">Tiny Code</h4>
<p>Simple trade-off controller:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tradeoff_decision(time_limit, options):</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># options = [{"method": "fast", "time": 1, "quality": 0.7},</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">#            {"method": "optimal", "time": 5, "quality": 1.0}]</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    feasible <span class="op">=</span> [o <span class="cf">for</span> o <span class="kw">in</span> options <span class="cf">if</span> o[<span class="st">"time"</span>] <span class="op">&lt;=</span> time_limit]</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(feasible, key<span class="op">=</span><span class="kw">lambda</span> o: o[<span class="st">"quality"</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-91" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-91">Why It Matters</h4>
<p>Balancing time, accuracy, and computation is essential for real-world AI: autonomous cars cannot wait for perfect reasoning, trading systems must act within milliseconds, and embedded devices must conserve power. Explicitly reasoning about these trade-offs improves robustness and practicality.</p>
</section>
<section id="try-it-yourself-91" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-91">Try It Yourself</h4>
<ol type="1">
<li>Design a scheduler with two options: heuristic (quick, 80% quality) vs.&nbsp;ILP (slow, 100% quality). How does the decision change with a 1-second vs.&nbsp;10-second time limit?</li>
<li>Plot a performance profile for an anytime search algorithm. At what point do gains diminish?</li>
<li>In a robotics domain, simulate a trade-off between path length and planning time. Which matters more under strict deadlines?</li>
</ol>
</section>
</section>
<section id="bounded-rationality-and-resource-limitations" class="level3">
<h3 class="anchored" data-anchor-id="bounded-rationality-and-resource-limitations">393. Bounded Rationality and Resource Limitations</h3>
<p>Bounded rationality recognizes that agents cannot compute or consider all possible options. Instead, they make decisions under constraints of time, knowledge, and computational resources. In scheduling and planning, this means adopting satisficing strategies—solutions that are “good enough” rather than perfectly optimal.</p>
<section id="picture-in-your-head-92" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-92">Picture in Your Head</h4>
<p>Imagine a student preparing for multiple exams. They cannot study every topic in infinite detail, so they allocate time strategically: focus on high-value topics, skim less important ones, and stop once the expected benefit of further study is low.</p>
</section>
<section id="deep-dive-92" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-92">Deep Dive</h4>
<p>Key principles of bounded rationality:</p>
<ul>
<li>Satisficing (Simon, 1956): agents settle for solutions that meet acceptable thresholds rather than exhaustively searching for optimal ones.</li>
<li>Resource-bounded search: algorithms must stop early when computational budgets (time, memory, energy) are exceeded.</li>
<li>Rational metareasoning: decide when to switch between exploring more options vs.&nbsp;executing a good enough plan.</li>
</ul>
<p>Practical methods:</p>
<ul>
<li>Heuristic-guided search: reduce exploration by focusing on promising paths.</li>
<li>Approximate reasoning: accept partial or probabilistic answers.</li>
<li>Anytime algorithms: trade accuracy for speed as resources permit.</li>
<li>Meta-level control: dynamically allocate computational effort.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 30%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>Approach</th>
<th>Assumption</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Full rationality</td>
<td>Infinite time &amp; resources</td>
<td>Exhaustive A* with perfect heuristic</td>
</tr>
<tr class="even">
<td>Bounded rationality</td>
<td>Limited time/resources</td>
<td>Heuristic search with cutoff</td>
</tr>
<tr class="odd">
<td>Satisficing</td>
<td>“Good enough” threshold</td>
<td>Accept plan within 10% of optimal</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-88" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-88">Tiny Code</h4>
<p>Satisficing search with cutoff depth:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bounded_dfs(state, goal, expand_fn, depth_limit<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [state]</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> depth_limit <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> next_state <span class="kw">in</span> expand_fn(state):</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>        plan <span class="op">=</span> bounded_dfs(next_state, goal, expand_fn, depth_limit<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> plan:</span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> [state] <span class="op">+</span> plan</span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-92" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-92">Why It Matters</h4>
<p>Bounded rationality reflects how real-world agents—humans, robots, or AI systems—actually operate. By acknowledging resource constraints, AI systems can act effectively without being paralyzed by intractable search spaces. This principle underlies much of modern heuristic search, approximation algorithms, and real-time planning.</p>
</section>
<section id="try-it-yourself-92" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-92">Try It Yourself</h4>
<ol type="1">
<li>Implement a heuristic planner with a cutoff depth. How often does it find satisficing solutions vs.&nbsp;fail?</li>
<li>Set a satisficing threshold (e.g., within 20% of optimal makespan). Compare runtime vs.&nbsp;quality trade-offs.</li>
<li>Simulate a robot with a 1-second planning budget. How does bounded rationality change its strategy compared to unlimited time?</li>
</ol>
</section>
</section>
<section id="anytime-algorithms-concept-and-design-principles" class="level3">
<h3 class="anchored" data-anchor-id="anytime-algorithms-concept-and-design-principles">394. Anytime Algorithms: Concept and Design Principles</h3>
<p>An anytime algorithm is one that can return a valid (possibly suboptimal) solution if interrupted, and improves its solution quality the longer it runs. This makes it ideal for real-time AI systems, where computation time is uncertain or limited, and acting with a partial solution is better than doing nothing.</p>
<section id="picture-in-your-head-93" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-93">Picture in Your Head</h4>
<p>Think of cooking a stew. If you serve it after 10 minutes, it’s edible but bland. After 30 minutes, it’s flavorful. After 1 hour, it’s rich and perfect. Anytime algorithms are like this stew—they start with something usable early, and improve the result with more time.</p>
</section>
<section id="deep-dive-93" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-93">Deep Dive</h4>
<p>Key properties:</p>
<ul>
<li><p>Interruptibility: algorithm can be stopped at any time and still return a valid solution.</p></li>
<li><p>Monotonic improvement: solution quality improves with computation time.</p></li>
<li><p>Performance profile: a function describing quality vs.&nbsp;time.</p></li>
<li><p>Contract vs.&nbsp;interruptible models:</p>
<ul>
<li>Contract algorithms: require a fixed time budget up front.</li>
<li>Interruptible algorithms: can stop anytime and return best-so-far solution.</li>
</ul></li>
</ul>
<p>Examples in AI:</p>
<ul>
<li>Anytime search algorithms: A* variants (e.g., Anytime Repairing A*).</li>
<li>Anytime planning: produce initial feasible plan, refine iteratively.</li>
<li>Anytime scheduling: generate an initial schedule, adjust to improve cost or balance.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Property</th>
<th>Contract Algorithm</th>
<th>Interruptible Algorithm</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Requires time budget</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr class="even">
<td>Quality guarantee</td>
<td>Stronger</td>
<td>Depends on interruption</td>
</tr>
<tr class="odd">
<td>Flexibility</td>
<td>Lower</td>
<td>Higher</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-89" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-89">Tiny Code</h4>
<p>Toy anytime planner:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> anytime_search(start, expand_fn, goal, max_steps<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    best_solution <span class="op">=</span> <span class="va">None</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    frontier <span class="op">=</span> [(<span class="dv">0</span>, [start])]</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> step <span class="kw">in</span> <span class="bu">range</span>(max_steps):</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> frontier: <span class="cf">break</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>        cost, path <span class="op">=</span> frontier.pop(<span class="dv">0</span>)</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> path[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> best_solution <span class="kw">or</span> <span class="bu">len</span>(path) <span class="op">&lt;</span> <span class="bu">len</span>(best_solution):</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>                best_solution <span class="op">=</span> path</span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> expand_fn(state):</span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a>            frontier.append((cost<span class="op">+</span><span class="dv">1</span>, path<span class="op">+</span>[nxt]))</span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># yield best-so-far solution</span></span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> best_solution</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-93" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-93">Why It Matters</h4>
<p>Anytime algorithms are crucial in domains where time is unpredictable: robotics, game AI, real-time decision making, and resource-constrained systems. They allow graceful degradation—better to act with a decent plan than freeze waiting for perfection.</p>
</section>
<section id="try-it-yourself-93" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-93">Try It Yourself</h4>
<ol type="1">
<li>Run an anytime search on a maze. Record solution quality after 10, 50, 100 iterations. How does it improve?</li>
<li>Compare contract (fixed budget) vs.&nbsp;interruptible anytime search in the same domain. Which is more practical?</li>
<li>Plot a performance profile for your anytime algorithm. Where do diminishing returns set in?</li>
</ol>
</section>
</section>
<section id="examples-of-anytime-search-and-planning" class="level3">
<h3 class="anchored" data-anchor-id="examples-of-anytime-search-and-planning">395. Examples of Anytime Search and Planning</h3>
<p>Anytime algorithms appear in many branches of AI, especially search and planning. They provide usable answers quickly and refine them as more time becomes available. Classic examples include variants of A* search, stochastic local search, and planning systems that generate progressively better schedules or action sequences.</p>
<section id="picture-in-your-head-94" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-94">Picture in Your Head</h4>
<p>Think of a GPS navigation app. The moment you enter your destination, it gives you a quick route. As you start driving, it recomputes in the background, improving the route or adapting to traffic changes. That’s an anytime planner at work.</p>
</section>
<section id="deep-dive-94" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-94">Deep Dive</h4>
<p>Examples of anytime search and planning:</p>
<ul>
<li><p>Anytime A*</p>
<ul>
<li>Starts with a suboptimal path quickly by inflating heuristics (ε-greedy).</li>
<li>Reduces ε over time, converging toward optimal A*.</li>
</ul></li>
<li><p>Anytime Repairing A* (ARA*)**</p>
<ul>
<li>Maintains a best-so-far solution and refines it incrementally.</li>
<li>Widely used in robotics for motion planning.</li>
</ul></li>
<li><p>Real-Time Dynamic Programming (RTDP):</p>
<ul>
<li>Updates values along simulated trajectories, improving over time.</li>
</ul></li>
<li><p>Stochastic Local Search:</p>
<ul>
<li>Generates initial feasible schedules or plans.</li>
<li>Improves through iterative refinement (e.g., hill climbing, simulated annealing).</li>
</ul></li>
<li><p>Anytime Planning in Scheduling:</p>
<ul>
<li>Generate feasible schedule quickly (greedy).</li>
<li>Apply iterative improvement (swapping, rescheduling) as time allows.</li>
</ul></li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 25%">
<col style="width: 18%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Domain</th>
<th>Quick Start</th>
<th>Converges to Optimal?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Anytime A*</td>
<td>Pathfinding</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>ARA*</td>
<td>Motion planning</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>RTDP</td>
<td>MDP solving</td>
<td>Yes</td>
<td>Yes (with enough time)</td>
</tr>
<tr class="even">
<td>Local search</td>
<td>Scheduling</td>
<td>Yes</td>
<td>Not guaranteed</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-90" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-90">Tiny Code</h4>
<p>Anytime A* sketch with inflated heuristic:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> anytime_astar(start, goal, expand_fn, h, epsilon<span class="op">=</span><span class="fl">2.0</span>, decay<span class="op">=</span><span class="fl">0.9</span>):</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    open_list <span class="op">=</span> [(h(start)<span class="op">*</span>epsilon, <span class="dv">0</span>, [start])]</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="va">None</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> open_list:</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>        f, g, path <span class="op">=</span> heapq.heappop(open_list)</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> path[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> goal:</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> best <span class="kw">or</span> g <span class="op">&lt;</span> <span class="bu">len</span>(best):</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> path</span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a>            epsilon <span class="op">*=</span> decay</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> best</span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> expand_fn(state):</span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a>            new_g <span class="op">=</span> g <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(open_list, (new_g <span class="op">+</span> h(nxt)<span class="op">*</span>epsilon, new_g, path<span class="op">+</span>[nxt]))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-94" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-94">Why It Matters</h4>
<p>These algorithms enable AI systems to act effectively in time-critical domains: robotics navigation, logistics planning, and interactive systems. They deliver not just solutions, but a stream of improving solutions, letting decision-makers adapt dynamically.</p>
</section>
<section id="try-it-yourself-94" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-94">Try It Yourself</h4>
<ol type="1">
<li>Implement Anytime A* on a grid world. Track how the path length improves as ε decreases.</li>
<li>Run a local search scheduler with iterative swaps. How much better does the schedule get after 10, 50, 100 iterations?</li>
<li>Compare standard A* vs.&nbsp;Anytime A* in time-limited settings. Which is more practical for real-time applications?</li>
</ol>
</section>
</section>
<section id="performance-profiles-and-monitoring" class="level3">
<h3 class="anchored" data-anchor-id="performance-profiles-and-monitoring">396. Performance Profiles and Monitoring</h3>
<p>A performance profile describes how the quality of a solution produced by an anytime algorithm improves as more computation time is allowed. Monitoring these profiles helps systems decide when to stop, when to continue refining, and how to allocate computation across competing tasks.</p>
<section id="picture-in-your-head-95" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-95">Picture in Your Head</h4>
<p>Imagine plotting a curve: on the x-axis is time, on the y-axis is solution quality. The curve rises quickly at first (big improvements), then levels off (diminishing returns). This shape tells you when extra computation is no longer worth it.</p>
</section>
<section id="deep-dive-95" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-95">Deep Dive</h4>
<ul>
<li><p>Performance profile:</p>
<ul>
<li>Function <span class="math inline">\(Q(t)\)</span>: quality of best-so-far solution at time <span class="math inline">\(t\)</span>.</li>
<li>Typically non-decreasing, with diminishing marginal improvements.</li>
</ul></li>
<li><p>Monitoring system: observes improvement and decides whether to stop or continue.</p></li>
<li><p>Utility-guided stopping: stop when expected gain in solution quality × value &lt; computation cost.</p></li>
</ul>
<p>Characteristics of profiles:</p>
<ul>
<li>Steep initial gains: heuristics or greedy steps quickly improve quality.</li>
<li>Plateau phase: further computation yields little improvement.</li>
<li>Long tails: convergence to optimal may take very long.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>Profile Shape</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rapid rise + plateau</td>
<td>Good for real-time, most value early</td>
</tr>
<tr class="even">
<td>Linear growth</td>
<td>Steady improvements, predictable</td>
</tr>
<tr class="odd">
<td>Erratic jumps</td>
<td>Sudden breakthroughs (e.g., stochastic methods)</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-91" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-91">Tiny Code</h4>
<p>Simulating performance monitoring:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> monitor_profile(algo, time_limit, threshold<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    quality, prev <span class="op">=</span> [], <span class="dv">0</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, time_limit<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> algo(t)  <span class="co"># algo returns quality at time t</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>        improvement <span class="op">=</span> q <span class="op">-</span> prev</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>        quality.append((t, q))</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> improvement <span class="op">&lt;</span> threshold:</span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>        prev <span class="op">=</span> q</span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> quality</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-95" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-95">Why It Matters</h4>
<p>Performance profiles let AI systems reason about the value of computation: when to stop, when to reallocate effort, and when to act. They underpin meta-reasoning, bounded rationality, and anytime planning in domains from robotics to large-scale scheduling.</p>
</section>
<section id="try-it-yourself-95" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-95">Try It Yourself</h4>
<ol type="1">
<li>Run a local search algorithm and record solution quality over time. Plot its performance profile.</li>
<li>Compare greedy, local search, and ILP solvers on the same problem. How do their profiles differ?</li>
<li>Implement a monitoring policy: stop when marginal improvement &lt;1%. Does it save time without hurting quality much?</li>
</ol>
</section>
</section>
<section id="interruptibility-and-graceful-degradation" class="level3">
<h3 class="anchored" data-anchor-id="interruptibility-and-graceful-degradation">397. Interruptibility and Graceful Degradation</h3>
<p>Interruptibility means that an algorithm can be stopped at any moment and still return its best-so-far solution. Graceful degradation ensures that when resources are cut short—time, computation, or energy—the system degrades smoothly in performance rather than failing catastrophically. These properties are central to anytime algorithms in real-world AI.</p>
<section id="picture-in-your-head-96" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-96">Picture in Your Head</h4>
<p>Imagine a robot vacuum cleaner. If you stop it after 2 minutes, it hasn’t cleaned the whole room but has at least covered part of it. If you let it run longer, the coverage improves. Stopping it doesn’t break the system; it simply reduces quality gradually.</p>
</section>
<section id="deep-dive-96" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-96">Deep Dive</h4>
<p>Key features:</p>
<ul>
<li><p>Interruptibility:</p>
<ul>
<li>Algorithm can pause or stop without corrupting the solution.</li>
<li>Must maintain a valid, coherent solution at all times.</li>
</ul></li>
<li><p>Graceful degradation:</p>
<ul>
<li>Performance decreases gradually under limited resources.</li>
<li>Opposite of brittle failure, where insufficient resources yield no solution.</li>
</ul></li>
</ul>
<p>Design strategies:</p>
<ul>
<li>Maintain a valid partial solution at each step (e.g., feasible plan, partial schedule).</li>
<li>Use iterative refinement (incremental updates).</li>
<li>Store best-so-far solution explicitly.</li>
</ul>
<p>Examples:</p>
<ul>
<li>Anytime path planning: shortest path improves as search continues, but partial path is always valid.</li>
<li>Incremental schedulers: greedy allocation first, refined by swaps or rescheduling.</li>
<li>Robotics control: fallback to simpler safe behaviors when computation is limited.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 31%">
<col style="width: 31%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Interruptible Algorithm</th>
<th>Non-Interruptible Algorithm</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Valid solution at stop?</td>
<td>Yes</td>
<td>Not guaranteed</td>
</tr>
<tr class="even">
<td>Degradation</td>
<td>Gradual</td>
<td>Abrupt failure</td>
</tr>
<tr class="odd">
<td>Robustness</td>
<td>High</td>
<td>Low</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-92" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-92">Tiny Code</h4>
<p>Interruptible incremental solver:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interruptible_solver(problem, max_steps<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="va">None</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> step <span class="kw">in</span> <span class="bu">range</span>(max_steps):</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>        candidate <span class="op">=</span> problem.improve(best)</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> problem.is_valid(candidate):</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> candidate</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> best  <span class="co"># return best-so-far at each step</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-96" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-96">Why It Matters</h4>
<p>Real-world AI agents rarely run with unlimited time or compute. Interruptibility and graceful degradation make systems robust, ensuring they deliver some value even under interruptions, deadlines, or failures. This is crucial for robotics, real-time planning, and critical systems like healthcare or aviation.</p>
</section>
<section id="try-it-yourself-96" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-96">Try It Yourself</h4>
<ol type="1">
<li>Implement an interruptible search where each iteration expands one node and maintains best-so-far. Stop it early—do you still get a usable solution?</li>
<li>Compare graceful degradation vs.&nbsp;brittle failure in a scheduler. What happens if the algorithm is cut off mid-computation?</li>
<li>Design a fallback policy for a robot: if planning is interrupted, switch to a simple safe behavior (e.g., stop or return to base).</li>
</ol>
</section>
</section>
<section id="metacontrol-allocating-computational-effort" class="level3">
<h3 class="anchored" data-anchor-id="metacontrol-allocating-computational-effort">398. Metacontrol: Allocating Computational Effort</h3>
<p>Metacontrol is the process by which an AI system decides how to allocate its limited computational resources among competing reasoning tasks. Instead of focusing only on the external environment, the agent also manages its internal computation, choosing what to think about, when to think, and when to act.</p>
<section id="picture-in-your-head-97" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-97">Picture in Your Head</h4>
<p>Think of an air traffic controller juggling multiple flights. They cannot analyze every plane in infinite detail, so they allocate more attention to high-priority flights (e.g., those about to land) and less to others. Similarly, AI systems must direct computational effort toward reasoning steps that promise the greatest benefit.</p>
</section>
<section id="deep-dive-97" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-97">Deep Dive</h4>
<p>Core elements of metacontrol:</p>
<ul>
<li>Computational actions: choosing which reasoning step (e.g., expand a node, refine a heuristic, simulate a trajectory) to perform next.</li>
<li>Value of Computation (VoC): expected improvement in decision quality from performing a computation.</li>
<li>Opportunity cost: reasoning too long may delay action and reduce real-world utility.</li>
</ul>
<p>Strategies:</p>
<ul>
<li>Myopic policies: choose the computation with the highest immediate VoC.</li>
<li>Lookahead policies: plan sequences of reasoning steps.</li>
<li>Heuristic metacontrol: rules of thumb (e.g., “stop when improvements &lt; threshold”).</li>
<li>Resource-bounded rationality: optimize computation subject to time or energy budgets.</li>
</ul>
<p>Comparison:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Strategy</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Myopic VoC</td>
<td>Simple, fast decisions</td>
<td>May miss long-term gains</td>
</tr>
<tr class="even">
<td>Lookahead</td>
<td>More thorough</td>
<td>Computationally heavy</td>
</tr>
<tr class="odd">
<td>Heuristic</td>
<td>Lightweight</td>
<td>No optimality guarantee</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-93" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-93">Tiny Code</h4>
<p>Metacontrol with myopic VoC:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> metacontrol(computations, budget):</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    chosen <span class="op">=</span> []</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(budget):</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>        comp <span class="op">=</span> <span class="bu">max</span>(computations, key<span class="op">=</span><span class="kw">lambda</span> c: c[<span class="st">"gain"</span>]<span class="op">/</span>c[<span class="st">"cost"</span>])</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>        chosen.append(comp[<span class="st">"name"</span>])</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>        computations.remove(comp)</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> chosen</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-97" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-97">Why It Matters</h4>
<p>Metacontrol ensures that AI systems use their limited resources intelligently, balancing deliberation and action. This principle is vital in real-time robotics, autonomous driving, and decision-making under deadlines, where overthinking can be just as harmful as underthinking.</p>
</section>
<section id="try-it-yourself-97" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-97">Try It Yourself</h4>
<ol type="1">
<li>Define three computations with different costs and expected gains. Use myopic VoC to decide which to perform under a budget of 2.</li>
<li>Implement a heuristic metacontrol rule: “stop when marginal gain &lt; 5%.” Test it in a scheduling scenario.</li>
<li>Simulate an agent with two competing tasks (navigation and communication). How should it allocate computational effort between them?</li>
</ol>
</section>
</section>
<section id="applications-in-robotics-games-and-real-time-ai" class="level3">
<h3 class="anchored" data-anchor-id="applications-in-robotics-games-and-real-time-ai">399. Applications in Robotics, Games, and Real-Time AI</h3>
<p>Meta-reasoning and anytime computation are not abstract ideas—they are central to real-time AI systems. Robotics, games, and interactive AI must act under tight deadlines, balancing reasoning depth against the need for timely responses. Interruptible, adaptive algorithms make these systems practical.</p>
<section id="picture-in-your-head-98" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-98">Picture in Your Head</h4>
<p>Think of a self-driving car approaching an intersection. It has milliseconds to decide: stop, yield, or accelerate. Too much deliberation risks a crash, too little may cause a poor decision. Its scheduling of “what to think about next” is meta-reasoning in action.</p>
</section>
<section id="deep-dive-98" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-98">Deep Dive</h4>
<ul>
<li><p>Robotics</p>
<ul>
<li>Problems: motion planning, navigation, manipulation.</li>
<li>Use anytime planners (e.g., RRT*, ARA*) that provide feasible paths quickly and refine them over time.</li>
<li>Meta-reasoning decides whether to keep planning or execute.</li>
<li>Example: a delivery robot generating a rough path, then refining while moving.</li>
</ul></li>
<li><p>Games</p>
<ul>
<li>Problems: adversarial decision-making (chess, Go, RTS).</li>
<li>Algorithms: iterative deepening minimax, Monte Carlo Tree Search (MCTS).</li>
<li>Agents allocate more time to critical positions, less to trivial ones.</li>
<li>Example: AlphaGo using bounded rollouts for real-time moves.</li>
</ul></li>
<li><p>Real-Time AI Systems</p>
<ul>
<li>Problems: scheduling in cloud computing, network packet routing, dialogue systems.</li>
<li>Must adapt to unpredictable inputs and resource limits.</li>
<li>Strategies: interruptible scheduling, load balancing, priority reasoning.</li>
<li>Example: online ad auctions balancing computation cost with bidding accuracy.</li>
</ul></li>
</ul>
<p>Comparison of domains:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 35%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Typical Algorithm</th>
<th>Meta-Reasoning Role</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Robotics</td>
<td>Anytime motion planning</td>
<td>Decide when to act vs.&nbsp;refine</td>
</tr>
<tr class="even">
<td>Games</td>
<td>Iterative deepening / MCTS</td>
<td>Allocate time by position importance</td>
</tr>
<tr class="odd">
<td>Real-Time AI</td>
<td>Online schedulers</td>
<td>Balance latency vs.&nbsp;accuracy</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-94" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-94">Tiny Code</h4>
<p>Iterative deepening search with interruptibility:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iterative_deepening(start, goal, expand_fn, max_depth):</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="va">None</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> depth <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, max_depth<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>        path <span class="op">=</span> dfs_limited(start, goal, expand_fn, depth)</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> path:</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> path</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> best  <span class="co"># best-so-far solution</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-98" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-98">Why It Matters</h4>
<p>These applications show why AI cannot just aim for perfect reasoning—it must also manage its computation intelligently. Meta-reasoning and anytime algorithms are what make robots safe, games competitive, and interactive AI responsive.</p>
</section>
<section id="try-it-yourself-98" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-98">Try It Yourself</h4>
<ol type="1">
<li>Run iterative deepening on a puzzle (e.g., 8-puzzle). Stop early and observe how solutions improve with depth.</li>
<li>Simulate a robot planner: generate a rough path in 0.1s, refine in 1s. Compare real-world performance if it stops early vs.&nbsp;refines fully.</li>
<li>Implement MCTS with a fixed time budget. How does solution quality change with 0.1s vs.&nbsp;1s vs.&nbsp;10s of thinking time?</li>
</ol>
</section>
</section>
<section id="case-study-meta-reasoning-in-ai-systems" class="level3">
<h3 class="anchored" data-anchor-id="case-study-meta-reasoning-in-ai-systems">400. Case Study: Meta-Reasoning in AI Systems</h3>
<p>Meta-reasoning gives AI systems the ability to decide how to think, not just what to do. This case study highlights real-world applications where explicit management of computational effort—through anytime algorithms, interruptibility, and performance monitoring—makes the difference between a practical system and an unusable one.</p>
<section id="picture-in-your-head-99" class="level4">
<h4 class="anchored" data-anchor-id="picture-in-your-head-99">Picture in Your Head</h4>
<p>Picture a Mars rover exploring the surface. With limited onboard compute and communication delays to Earth, it must decide: should it spend more time refining a path around a rock, or act now with a less certain plan? Meta-reasoning governs this trade-off, keeping the rover safe and efficient.</p>
</section>
<section id="deep-dive-99" class="level4">
<h4 class="anchored" data-anchor-id="deep-dive-99">Deep Dive</h4>
<ul>
<li><p>Autonomous Vehicles</p>
<ul>
<li>Challenge: real-time motion planning under uncertainty.</li>
<li>Approach: use anytime planning (e.g., ARA*). Start with a feasible path, refine as time allows.</li>
<li>Meta-reasoning monitors performance profile: stop refining if risk reduction no longer justifies computation.</li>
</ul></li>
<li><p>Interactive Dialogue Systems</p>
<ul>
<li>Challenge: must respond quickly to users while reasoning over noisy inputs.</li>
<li>Approach: anytime speech understanding and intent recognition.</li>
<li>Meta-control: allocate compute to ambiguous utterances, shortcut on clear ones.</li>
</ul></li>
<li><p>Cloud Resource Scheduling</p>
<ul>
<li>Challenge: allocate servers under fluctuating demand.</li>
<li>Approach: incremental schedulers with graceful degradation.</li>
<li>Meta-reasoning decides when to recompute allocations vs.&nbsp;accept small inefficiencies.</li>
</ul></li>
<li><p>Scientific Discovery Systems</p>
<ul>
<li>Challenge: reasoning over large hypothesis spaces.</li>
<li>Approach: bounded rationality with satisficing thresholds.</li>
<li>Meta-level decision: “is it worth running another round of simulation, or publish current results?”</li>
</ul></li>
</ul>
<p>Comparison of benefits:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 38%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Meta-Reasoning Role</th>
<th>Benefit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Autonomous driving</td>
<td>Plan vs.&nbsp;refine decision</td>
<td>Safe, timely control</td>
</tr>
<tr class="even">
<td>Dialogue systems</td>
<td>Allocate compute adaptively</td>
<td>Faster, smoother interactions</td>
</tr>
<tr class="odd">
<td>Cloud scheduling</td>
<td>Balance recomputation cost</td>
<td>Efficient resource use</td>
</tr>
<tr class="even">
<td>Scientific AI</td>
<td>Decide when to stop reasoning</td>
<td>Practical discovery process</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-95" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-95">Tiny Code</h4>
<p>Toy meta-reasoning controller:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> meta_controller(problem, time_budget, refine_fn, utility_fn):</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="va">None</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(time_budget):</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>        candidate <span class="op">=</span> refine_fn(best)</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> utility_fn(candidate) <span class="op">&gt;</span> utility_fn(best <span class="kw">or</span> candidate):</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> candidate</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># stop if marginal utility gain is too small</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> utility_fn(best) <span class="op">-</span> utility_fn(candidate) <span class="op">&lt;</span> <span class="fl">0.01</span>:</span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-99" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-99">Why It Matters</h4>
<p>Meta-reasoning turns abstract algorithms into practical systems. It ensures AI agents can adapt reasoning to real-world constraints, producing results that are not only correct but also timely, efficient, and robust. Without it, autonomous systems would overthink, freeze, or fail under pressure.</p>
</section>
<section id="try-it-yourself-99" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-99">Try It Yourself</h4>
<ol type="1">
<li>Implement a path planner with anytime search. Use meta-reasoning to decide when to stop refining.</li>
<li>Simulate a dialogue system where meta-reasoning skips deep reasoning for simple queries but engages for ambiguous ones.</li>
<li>Run a scheduling system under fluctuating load. Compare naive recomputation every second vs.&nbsp;meta-controlled recomputation. Which balances efficiency better?</li>
</ol>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../books/en-US/volume_3.html" class="pagination-link" aria-label="Volume 3. Data and Representation">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">Volume 3. Data and Representation</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../books/en-US/volume_5.html" class="pagination-link" aria-label="Volume 5. Logic and Knowledge">
        <span class="nav-page-text"><span class="chapter-title">Volume 5. Logic and Knowledge</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>